{"version":3,"sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/./esm/ext/lz-aggregation-tests.js","webpack://[name]/external \"raremetal\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","install","LocusZoom","BaseAdapter","Adapters","BaseApiAdapter","ConnectorSource","add","state","chain","fields","required_info","aggregation_tests","header","aggregation_genoset_id","genoset_id","aggregation_genoset_build","genoset_build","aggregation_phenoset_id","phenoset_id","aggregation_pheno","pheno","aggregation_calcs","calcs","mask_data","masks","aggregation_masks","aggregation_mask_ids","map","item","this","url","getURL","JSON","stringify","chrom","chr","start","stop","end","genotypeDataset","phenotypeDataset","phenotype","samples","genomeBuild","body","getCacheKey","fetch","method","headers","then","response","ok","Error","statusText","text","resp","json","parse","error","records","groups","variants","filter","groupType","parsed","parsePortalJSON","byMask","keys","length","results","PortalTestRunner","toJSON","res","mask_id_to_desc","reduce","acc","val","description","data","forEach","group","mask_name","mask","catch","e","console","config","from","super","arguments","parseInit","_from","discrete","constructor","SOURCE_NAME","Promise","resolve","REGEX_EPACTS","RegExp","one_variant","match","variant","chromosome","position","ref_allele","ref_allele_freq","altFreq","log_pvalue","Math","log10","pvalue","sort","a","b","aggregation_source_id","_source_name_mapping","gene_source_id","aggregationData","genesData","groupedAggregation","result","push","gene","gene_id","gene_name","tests","aggregation_best_pvalue","min","apply","use","raremetal"],"mappings":"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","file":"ext/lz-aggregation-tests.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n","/**\n * LocusZoom extensions used to calculate and render aggregation test results. Because these calculations depend on an\n *   external library, the special data adapters are defined here, rather than in LocusZoom core code.\n *\n * This extension provides a number of features that are closely tied to the aggregation tests demo,\n *  and thus the specific UI and data operations are less of a drop-in generic addon than most other extensions.\n *  This tool also depends on a calculation tool (like RAREMETAL-server) with access to sample specific genotypes.\n *\n * ### Loading and usage\n * The page must incorporate and load all libraries before this file can be used, including:\n *    - LocusZoom\n *    - raremetal.js (available via NPM or a related CDN)\n *\n * To use in an environment without special JS build tooling, simply load the extension file as JS from a CDN:\n * ```\n * <script src=\"https://cdn.jsdelivr.net/npm/locuszoom@INSERT_VERSION_HERE/dist/ext/lz-aggregation-tests.min.js\" type=\"application/javascript\"></script>\n * ```\n *\n * To use with ES6 modules, the plugin must be loaded and registered explicitly before use:\n * ```\n * import LocusZoom from 'locuszoom';\n * import aggTests from 'locuszoom/esm/ext/lz-aggregation-tests';\n * LocusZoom.use(aggTests);\n * ```\n *\n * Then use the layouts and data adapters made available by this extension. (see demos and documentation for guidance)\n * @private\n * @module\n */\n// This is defined as a UMD module, to work with multiple different module systems / bundlers\n// Arcane build note: everything defined here gets registered globally. This is not a \"pure\" module, and some build\n//  systems may require being told that this file has side effects.\n\nimport {helpers} from 'raremetal.js';\n\nfunction install (LocusZoom) {\n    const BaseAdapter = LocusZoom.Adapters.get('BaseAdapter');\n    const BaseApiAdapter = LocusZoom.Adapters.get('BaseApiAdapter');\n    const ConnectorSource = LocusZoom.Adapters.get('ConnectorSource');\n\n    /**\n     * Calculates gene or region-based tests based on provided data, using the raremetal.js library.\n     *   It will rarely be used by itself, but rather using a connector that attaches the results to data from\n     *   another source (like genes). Using a separate connector allows us to add caching and run this front-end\n     *   calculation only once, while using it in many different places.\n     * @see module:ext/lz-aggregation-tests\n     * @private\n     */\n    class AggregationTestSourceLZ extends BaseApiAdapter {\n        getURL(state, chain, fields) {\n            // Unlike most sources, calculations may require access to plot state data even after the initial request\n            // This example source REQUIRES that the external UI widget would store the needed test definitions in a plot state\n            //  field called `aggregation_tests` (an object {masks: [], calcs: {})\n            const required_info = state.aggregation_tests || {};\n\n            if (!chain.header) {\n                chain.header = {};\n            }\n            // All of these fields are required in order to use this datasource. TODO: Add validation?\n            chain.header.aggregation_genoset_id = required_info.genoset_id || null; // Number\n            chain.header.aggregation_genoset_build = required_info.genoset_build || null; // String\n            chain.header.aggregation_phenoset_id = required_info.phenoset_id || null;  // Number\n            chain.header.aggregation_pheno = required_info.pheno || null; // String\n            chain.header.aggregation_calcs = required_info.calcs || {};  // String[]\n            const mask_data = required_info.masks || [];\n            chain.header.aggregation_masks = mask_data;  // {name:desc}[]\n            chain.header.aggregation_mask_ids = mask_data.map(function (item) {\n                return item.name;\n            }); // Number[]\n            return this.url;\n        }\n\n        getCacheKey(state, chain, fields) {\n            this.getURL(state, chain, fields);  // TODO: This just sets the chain.header fields\n            return JSON.stringify({\n                chrom: state.chr,\n                start: state.start,\n                stop: state.end,\n                genotypeDataset: chain.header.aggregation_genoset_id,\n                phenotypeDataset: chain.header.aggregation_phenoset_id,\n                phenotype: chain.header.aggregation_pheno,\n                samples: 'ALL',\n                genomeBuild: chain.header.aggregation_genoset_build,\n                masks: chain.header.aggregation_mask_ids,\n            });\n        }\n\n        fetchRequest(state, chain, fields) {\n            const url = this.getURL(state, chain, fields);\n            const body = this.getCacheKey(state, chain, fields);\n            const headers = {\n                'Content-Type': 'application/json',\n            };\n\n            return fetch(url, {method: 'POST', body: body, headers: headers}).then((response) => {\n                if (!response.ok) {\n                    throw new Error(response.statusText);\n                }\n                return response.text();\n            }).then(function (resp) {\n                const json = typeof resp == 'string' ? JSON.parse(resp) : resp;\n                if (json.error) {\n                    // RAREMETAL-server quirk: The API sometimes returns a 200 status code for failed requests,\n                    //    with a human-readable error description as a key\n                    // For now, this should be treated strictly as an error\n                    throw new Error(json.error);\n                }\n                return json;\n            });\n        }\n\n        annotateData(records, chain) {\n            // Operate on the calculated results. The result of this method will be added to chain.discrete\n\n            // In a page using live API data, the UI would only request the masks it needs from the API.\n            // But in our demos, sometimes boilerplate JSON has more masks than the UI asked for. Limit what calcs we run (by\n            //  type, and to the set of groups requested by the user)\n\n            // The Raremetal-server API has a quirk: it returns a different payload structure if no groups are defined\n            //  for the request region. Detect when that happens and end the calculation immediately in that case\n            if (!records.groups) {\n                return { groups: [], variants: [] };\n            }\n\n            records.groups = records.groups.filter(function (item) {\n                return item.groupType === 'GENE';\n            });\n\n            const parsed = helpers.parsePortalJSON(records);\n            let groups = parsed[0];\n            const variants = parsed[1];\n            // Some APIs may return more data than we want (eg simple sites that are just serving up premade scorecov json files).\n            //  Filter the response to just what the user has chosen to analyze.\n            groups = groups.byMask(chain.header.aggregation_mask_ids);\n\n            // Determine what calculations to run\n            const calcs = chain.header.aggregation_calcs;\n            if (!calcs || Object.keys(calcs).length === 0) {\n                // If no calcs have been requested, then return a dummy placeholder immediately\n                return { variants: [], groups: [], results: [] };\n            }\n            const runner = new helpers.PortalTestRunner(groups, variants, calcs);\n\n            return runner.toJSON()\n                .then(function (res) {\n                    // Internally, raremetal helpers track how the calculation is done, but not any display-friendly values\n                    // We will annotate each mask name (id) with a human-friendly description for later use\n                    const mask_id_to_desc = chain.header.aggregation_masks.reduce(function (acc, val) {\n                        acc[val.name] = val.description;\n                        return acc;\n                    }, {});\n                    res.data.groups.forEach(function (group) {\n                        group.mask_name = mask_id_to_desc[group.mask];\n                    });\n                    return res.data;\n                })\n                .catch(function (e) {\n                    console.error(e);\n                    throw new Error('Failed to calculate aggregation test results');\n                });\n        }\n\n        normalizeResponse(data) {\n            return data;\n        }\n\n        combineChainBody(records, chain) {\n            // aggregation tests are a bit unique, in that the data is rarely used directly- instead it is used to annotate many\n            //  other layers in different ways. The calculated result has been added to `chain.discrete`, but will not be returned\n            //  as part of the response body built up by the chain\n            return chain.body;\n        }\n\n    }\n\n    /**\n     * Restructure RAREMETAL-SERVER data used to calculate aggregation tests into a format that can be used to\n     *  display a GWAS scatter plot.\n     * @see module:ext/lz-aggregation-tests\n     * @see module:LocusZoom_Adapters\n     * @private\n     */\n    class AssocFromAggregationLZ extends BaseAdapter {\n        constructor(config) {\n            if (!config || !config.from) {\n                throw 'Must specify the name of the source that contains association data';\n            }\n            super(...arguments);\n        }\n        parseInit(config) {\n            super.parseInit(config);\n            this._from = config.from;\n        }\n\n        getRequest(state, chain, fields) {\n            // Does not actually make a request. Just pick off the specific bundle of data from a known payload structure.\n            if (chain.discrete && !chain.discrete[this._from]) {\n                throw `${this.constructor.SOURCE_NAME} cannot be used before loading required data for: ${this._from}`;\n            }\n            // Copy the data so that mutations (like sorting) don't affect the original\n            return Promise.resolve(JSON.parse(JSON.stringify(chain.discrete[this._from]['variants'])));\n        }\n\n        normalizeResponse(data) {\n            // The payload structure of the association source is slightly different than the one required by association\n            //   plots. For example, we need to parse variant names and convert to log_pvalue\n            const REGEX_EPACTS = new RegExp('(?:chr)?(.+):(\\\\d+)_?(\\\\w+)?/?([^_]+)?_?(.*)?');  // match API variant strings\n            return data.map((one_variant) => {\n                const match = one_variant.variant.match(REGEX_EPACTS);\n                return {\n                    variant: one_variant.variant,\n                    chromosome: match[1],\n                    position: +match[2],\n                    ref_allele: match[3],\n                    ref_allele_freq: 1 - one_variant.altFreq,\n                    log_pvalue: -Math.log10(one_variant.pvalue),\n                };\n            }).sort((a, b) => {\n                a = a.variant;\n                b = b.variant;\n                if (a < b) {\n                    return -1;\n                } else if (a > b) {\n                    return 1;\n                } else {\n                    // names must be equal\n                    return 0;\n                }\n            });\n        }\n    }\n\n    /**\n     * A sample connector that aligns calculated aggregation test data with corresponding gene information. Returns a body\n     *   suitable for use with the genes datalayer.\n     *\n     *  To use this source, one must specify a fields array that calls first the genes source, then a dummy field from\n     *      this source. The output will be to transparently add several new fields to the genes data.\n     * @see module:ext/lz-aggregation-tests\n     * @see module:LocusZoom_Adapters\n     * @private\n     */\n    class GeneAggregationConnectorLZ extends ConnectorSource {\n        _getRequiredSources() {\n            return ['gene_ns', 'aggregation_ns'];\n        }\n\n        combineChainBody(data, chain) {\n            // The genes layer receives all results, and displays only the best pvalue for each gene\n\n            // Tie the calculated group-test results to genes with a matching name\n            const aggregation_source_id = this._source_name_mapping['aggregation_ns'];\n            const gene_source_id = this._source_name_mapping['gene_ns'];\n            // This connector assumes that genes are the main body of records from the chain, and that aggregation tests are\n            //   a standalone source that has not acted on genes data yet\n            const aggregationData = chain.discrete[aggregation_source_id];\n            const genesData = chain.discrete[gene_source_id];\n\n            const groupedAggregation = {};  // Group together all tests done on that gene- any mask, any test\n\n            aggregationData.groups.forEach(function (result) {\n                if (!Object.prototype.hasOwnProperty.call(groupedAggregation, result.group)) {\n                    groupedAggregation[result.group] = [];\n                }\n                groupedAggregation[result.group].push(result.pvalue);\n            });\n\n            // Annotate any genes that have test results\n            genesData.forEach(function (gene) {\n                const gene_id = gene.gene_name;\n                const tests = groupedAggregation[gene_id];\n                if (tests) {\n                    gene.aggregation_best_pvalue = Math.min.apply(null, tests);\n                }\n            });\n            return genesData;\n        }\n    }\n\n\n    LocusZoom.Adapters.add('AggregationTestSourceLZ', AggregationTestSourceLZ);\n    LocusZoom.Adapters.add('AssocFromAggregationLZ', AssocFromAggregationLZ);\n    LocusZoom.Adapters.add('GeneAggregationConnectorLZ', GeneAggregationConnectorLZ);\n}\n\n\nif (typeof LocusZoom !== 'undefined') {\n    // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()\n    // eslint-disable-next-line no-undef\n    LocusZoom.use(install);\n}\n\n\nexport default install;\n","module.exports = raremetal;"],"sourceRoot":""}