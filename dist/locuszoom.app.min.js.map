{"version":3,"sources":["locuszoom.app.min.js","Dashboard.js","Singletons.js","DataLayer.js","Layouts.js","LocusZoom.js","Data.js","annotation_track.js","forest.js","genes.js","genome_legend.js","intervals.js","line.js","scatter.js","Legend.js","Plot.js","Panel.js"],"names":["root","factory","this","d3","obj","components","functions","transformations","parseTrans","sources","findSourceByName","datalayers","l","region_nav_plot_dashboard","covariates_model_plot_dashboard","covariates_model_association","layouts","minimum_d3_version","Error","minimum_version","current_version","minimum_version_array","split","current_version_array","version_is_ok","forEach","d","i","semanticVersionIsOk","version","LocusZoom","selector","datasource","layout","plot","select","html","call","node","id","iterator","empty","attr","Plot","container","dataset","region","parsed_state","parsePositionQuery","Object","keys","key","state","svg","append","style","setDimensions","positionPanels","initialize","length","refresh","plots","selectAll","each","populate","pos","exp","suffix","exp_symbols","0","3","6","9","isNaN","log","Math","LN10","min","max","places_exp","floor","toFixed","min_exp","places","ret","pow","p","val","toUpperCase","replace","suffixre","exec","mult","Number","x","match","center","positionStringToInt","offset","chr","start","end","position","range","clip_range","target_tick_count","parseInt","min_n","abs","c","base","base_toFixed","round","unit","ticks","parseFloat","push","indexOf","slice","pop","method","url","body","headers","timeout","Promise","resolve","reject","xhr","XMLHttpRequest","open","XDomainRequest","onreadystatechange","readyState","status","response","setTimeout","header","setRequestHeader","send","new_state","validated_region","attempted_scale","attempted_midpoint","temp","min_region_scale","max_region_scale","data","tokens","regex","m","index","text","condition","variable","close","console","error","JSON","stringify","astify","token","shift","then","ast","cache","hasOwnProperty","Data","Field","render_node","value","map","join","parentNode","classed","getToolTipData","getDataLayer","data_layer","getToolTipDataLayer","parent","panel","getToolTipPanel","showing","content_selector","hide_delay","show","content","css","curtain","parent_plot","insert","on","hide","bind","update","clearTimeout","page_origin","getPageOrigin","top","y","left","width","height","max-width","max-height","delay","remove","progress_selector","cancel_selector","loader","percent","loader_boundrect","getBoundingClientRect","animate","setPercentCompleted","extra","Sub","constructor","apply","arguments","prototype","create","k","LZ_SIG_THRESHOLD_LOGP","validateBuildSource","class_name","build","source","Layouts","dashboard","tooltip","get","type","name","modifications","merge","unnamespaced","parse","default_namespace","namespace","default","toString","applyNamespaces","element","resolved_namespace","re","r","merge_namespace","namespaced_element","namespaced_property","property","set","add","list","custom_layout","default_layout","custom_type","default_type","Array","isArray","assoc","closable","or","and","intervals","catalog","orientation","recomb","fields","z_index","stroke","stroke-width","x_axis","field","y_axis","axis","ceiling","ld","point_shape","scale_function","parameters","field_value","else","point_size","color","breaks","values","legend","shape","size","label","class","id_field","upper_buffer","min_extent","behaviors","onmouseover","action","onmouseout","onclick","exclusive","onshiftclick","fill_opacity","phewas","tooltip_positioning","category_field","lower_buffer","categories","null_value","spacing","lines","stroke-dasharray","filters","operator","font-size","font-weight","fill","gene","constraint","genome","start_field","end_field","track_split_field","split_tracks","always_hide_legend","{{namespace[intervals]}}state_id","group_position","margin-left","title","subtitle","button_html","button_title","step","min_width","min_height","proportional_width","margin","right","bottom","inner_border","axes","label_offset","tick_format","extent","y1","y2","origin","hidden","interaction","drag_background_to_pan","drag_x_ticks_to_scale","drag_y1_ticks_to_scale","drag_y2_ticks_to_scale","scroll_to_zoom","x_linked","data_layers","layer_name","default_config_display_name","options","display_name","display","text-anchor","transform","data_layer_id","pad_from_bottom","responsive_resize","panels","proportional_height","StandardLayout","mouse_guide","DataLayer","initialized","layout_idx","Panel","DefaultLayout","_base_layout","state_id","setDefaultState","tooltips","global_statuses","highlighted","selected","faded","addField","fieldName","fieldString","layer_state","Statuses","adjectives","verbs","menu_antiverbs","getBaseId","getAbsoluteDataHeight","group","canTransition","transition","panel_boundaries","dragging","panel_id","getElementId","element_id","getElementStatusNodeId","getElementById","applyDataMethods","field_to_match","receive","broadcast_value","lz_match_value","lz_highlight_match","toHTML","deselect","unselectElement","applyCustomDataMethods","clipRect","moveUp","data_layer_ids_by_z_index","resortDataLayers","moveDown","resolveScalableParameter","idx","f","ScaleFunctions","_getDataExtent","axis_config","getAxisExtent","dimension","axis_name","axis_layout","data_extent","original_extent_span","range_min","range_max","getTicks","config","createTooltip","arrow","updateTooltip","positionTooltip","parseFields","destroyTooltip","element_or_id","temporary","label_mark_position","splice","destroyAllTooltips","event","pageX","pageY","positionAllTooltips","showOrHideTooltip","first_time","resolveStatus","statuses","directive","reduce","previousValue","currentValue","sub_status","sub_operator","show_directive","hide_directive","antistatus","show_resolved","hide_resolved","has_tooltip","filter","return_type","matches","operators","=","a","b","!=","<","<=",">",">=","%","filterIndexes","filterElements","verb","adjective","antiverb","setElementStatus","setElementStatusByFilters","setAllElementStatus","active","get_element_id_error","element_status_node_id","element_status_idx","added_status","emit","is_selected","value_to_broadcast","toggle","applyBehaviors","selection","event_match","executeBehaviors","requiredKeyStates","ctrlKey","shiftKey","behavior","current_status_boolean","href","target","window","location","panel_origin","exportData","format","default_format","toLowerCase","e","warn","jsonified","delimiter","record","draw","cliparea","reMap","promise","lzd","getData","new_data","DataLayers","datalayer","extend","parent_name","overrides","child","subclass","hit_area_width","render","self","trackData","visible_lines_group","enter","exit","hit_areas_group","hit_areas_selection","_getX","x_center","x_left","left_node","left_node_x_center","crds","arrow_type","arrow_top","arrow_left","tooltip_box","data_layer_height","data_layer_width","x_scale","y_center","offset_right","offset_left","stroke_width","top_offset","mouse","confidence_intervals","show_no_significance_line","y_scale","sqrt","PI","ci_selection","ci_transform","ci_width","duration","ease","points_selection","initial_y","symbol","element_data","ci_config","item","field_to_add","label_font_size","label_exon_spacing","exon_height","bounding_box_padding","track_vertical_spacing","getTrackHeight","transcript_idx","tracks","gene_track_index","1","assignTracks","getLabelWidth","gene_name","font_size","temp_text","label_width","getBBox","g","gene_id","gene_version","transcript_id","transcripts","display_range","text_anchor","centered_margin","display_domain","invert","track","potential_track","collision_on_potential_track","placed_gene","min_start","t","exons","bboxes","boundaries","labels","strand","exon_id","clickareas","gene_bbox_id","gene_bbox","gene_center_x","arrow_width","chromosome_fill_colors","light","dark","chromosome_label_colors","genome_start","genome_end","chromosomes","variant_parts","variant","track_split_order","track_split_legend_to_y_axis","track_height","previous_tracks","interval_track_index","track_split_field_index","reverse","placed_interval","psuedoElement","sharedstatusnode_style","interval","statusnode_style","statusnodes","rects","interval_name","updateSplitTrackAxis","interval_bbox","interval_center_x","legend_axis","track_spacing","target_height","scaleHeightToData","toggleSplitTracks","interpolate","hitarea_width","mouse_event","line","tooltip_timeout","getMouseDisplayAndData","slope","x_field","y_field","bisect","bisector","datum","startDatum","endDatum","interpolateNumber","x_precision","toPrecision","y_precision","dd","max_arrow_left","path","area","y0","hitarea","hitarea_line","path_class","global_status","decoupled","x_extent","y_extent","y_range","flip_labels","handle_lines","Boolean","min_x","max_x","flip","dn","dnl","dnx","text_swing","dnlx2","line_swing","label_texts","da","dal","label_lines","abound","bbound","separate_labels","seperate_iterations","again","db","delta","adjust","new_a_y","new_b_y","min_y","max_y","label_elements","filtered_data","label_groups","x1","x2","makeLDReference","ref","applyState","ldrefvar","_prepareData","xField","sourceData","sort","ak","bk","av","bv","_generateCategoryBounds","uniqueCategories","category","bounds","categoryNames","_setDynamicColorScheme","_getColorScale","from_source","color_params","find","colors","colorParams","baseParams","parameters_categories_hash","every","scale","category10","category20","concat","categoryBounds","_categories","knownCategories","knownColors","xPos","diff","KnownDataSources","SOURCE_NAME","source_name","newObj","params","Function","getAll","setAll","clear","TransformationFunctions","fun","getTrans","substring","result","funs","parseTransString","fn","ceil","toExponential","str","encodeURIComponent","s","input","threshold","prev","curr","nullval","upper_idx","brk","normalized_input","isFinite","Dashboard","hide_timeout","persist","component","Components","shouldPersist","visibility","destroy","force","Component","parent_panel","parent_svg","button","menu","Button","parent_dashboard","tag","setTag","setHtml","setText","setTitle","setColor","setStyle","getClass","permanent","setPermanent","bool","setStatus","highlight","disable","setOnMouseover","setOnMouseout","setOnclick","preUpdate","postUpdate","outer_selector","inner_selector","scroll_position","scrollTop","page_scroll_top","document","documentElement","container_offset","getContainerOffset","dashboard_client_rect","button_client_rect","menu_client_rect","total_content_height","scrollHeight","base_max_width","container_max_width","content_max_width","base_max_height","max_height","setPopulate","menu_populate_function","div_selector","title_selector","display_width","display_height","positionIntToString","stylesheet","generateBase64SVG","old","URL","revokeObjectURL","css_string","styleSheets","createCORSPromise","outerHTML","dy","initial_html","style_def","insert_at","Blob","createObjectURL","suppress_confirm","confirm","removePanel","is_at_top","y_index","is_at_bottom","panel_ids_by_y_index","can_zoom","current_region_scale","new_region_scale","menu_html","model","covariates","CovariatesModel","element_reference","updateComponent","removeByIdx","removeAll","table","covariate","row","cov","scale_timeout","status_adj","status_idx","status_verb","at_top","at_bottom","td","removeDataLayer","allowed_fields","fields_whitelist","dataLayer","dataLayerLayout","defaultConfig","configSlot","undefined","_selected_item","uniqueID","random","menuLayout","renderRow","display_options","row_id","radioId","field_name","defaultName","Legend","background_rect","elements","elements_group","padding","label_size","line_height","label_x","label_y","path_y","symbolTypes","radius","bcr","right_x","pad_from_right","DataSources","addSource","ns","dsobj","source_id","getSource","removeSource","fromJSON","ds","toJSON","parts","full_name","applyTransformations","Requester","requests","raw","trans","outnames","request_handles","discrete","Source","enableCache","dependentSource","parseInit","init","getCacheKey","chain","getURL","fetchRequest","getRequest","req","cacheKey","_cachedKey","_cachedResponse","preGetData","pre","resp","parseResponse","normalizeResponse","N","records","j","prepareData","annotateData","extractFields","fieldFound","output_record","v","combineChainBody","json","standardized","one_source_body","new_body","parseArraysToObjects","standard","parseObjectsToObjects","parseData","constructorFun","uniqueName","getPrototypeOf","AssociationSource","unshift","analysis","LDSource","findMergeFields","arr","dataFields","position_field","pvalue","pvalue_field","_names_","names","nameMatch","regexes","findRequestedFields","isrefvarin","isrefvarout","ldin","ldout","getRefvar","refVar","columns","pval_field","cmp","test","extremeVal","extremeIdx","findExtremeValue","refSource","ldrefsource","reqFields","corrField","rsquare","lfield","rfield","position2","leftJoin","refvar","idfield","outrefname","outldname","tagRefVariant","LDSource2","genome_build","ld_source","population","ld_pop","combined","chainRequests","payload","next","GwasCatalog","build_option","default_source","posMatch","decider","decider_out","n_matches","outn","chainNames","catNames","GeneSource","GeneConstraintSource","geneids","substr","Content-Type","constraint_fields","RecombinationRateSource","IntervalSource","bedtracksource","StaticSource","_data","PheWASSource","ConnectorSource","_source_name_mapping","specified_ids","REQUIRED_SOURCES","chain_source_id","applyPanelYIndexesToPanelLayouts","pid","remap_promises","window_onresize","event_hooks","layout_changed","data_requested","data_rendered","element_clicked","element_selection","match_requested","panel_removed","state_changed","hook","off","theseHooks","hookMatch","eventData","sourceID","hookToRun","eventContext","bounding_client_rect","x_offset","scrollLeft","y_offset","offsetParent","offsetTop","offsetLeft","canInteract","loading_data","zooming","initializeLayout","aspect_ratio","sumProportional","total","rescaleSVG","clientRect","RESIZE_MODES","panel_layout","addPanel","min-width","min-height","panel_width","panel_height","setOrigin","proportional_origin","clearPanelData","panelId","mode","panelsList","dlid","layer","x_linked_margins","total_proportional_height","proportional_adjustment","calculated_plot_height","mouse_guide_svg","mouse_guide_vertical_svg","mouse_guide_horizontal_svg","vertical","horizontal","generateCurtain","generateLoader","selectors","corner_selector","panel_idx","panel_resize_drag","drag","this_panel","original_panel_height","panel_height_change","new_calculated_plot_height","loop_panel_id","loop_panel_idx","loop_panel","corner_drag","dx","plot_page_origin","panel_page_origin","mouseout_mouse_guide","mousemove_mouse_guide","coords","mouseup","stopDrag","mousemove","preventDefault","dragged_x","start_x","dragged_y","start_y","linked_panel_ids","to_send","client_rect","subscribeToData","success_callback","opts","error_callback","onerror","err","listener","catch","state_changes","validateState","all","message","startDrag","getLinkedPanelIds","overrideAxisLayout","axis_number","y_axis_number","generateID","applyDataLayerZIndexesToDataLayerLayouts","data_promises","y1_scale","y2_scale","y1_extent","y2_extent","x_ticks","y1_ticks","y2_ticks","zoom_timeout","bubble","plot_origin","background_click","y1_linked","y2_linked","panel_count","setMargin","x_range","y1_range","y2_range","label_function","data_layer_layout","addDataLayer","clipPath","clearSelections","x_axis_label","y1_axis","y1_axis_label","y2_axis","y2_axis_label","mousedown","ascending","generateExtents","generateTicks","baseTickConfig","acc","nextLayer","itemConfig","prettyTicks","constrain","limit_exponent","neg_min","neg_max","pos_min","pos_max","Infinity","ranges","base_x_range","x_shifted","base_y1_range","y1_shifted","base_y2_range","y2_shifted","anchor","scalar","current_extent_size","current_scaled_extent_size","zoom_factor","potential_extent_size","new_extent_size","offset_ratio","new_x_extent_start","y_shifted","linear","domain","renderAxis","zoom_handler","wheelDelta","detail","deltaY","zoom_listener","zoom","canRender","axis_params","label_rotate","ticksAreAllNumbers","orient","tickPadding","tickValues","tickFormat","tick_selector","tick_mouseover","focus","cursor","dh","addBasicLoader","show_immediately","plugin_loading_error","define","amd","module","exports","require"],"mappings":"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","file":"locuszoom.app.min.js","sourcesContent":["(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(['d3'], function (d3) {\n            // amd\n            return root.LocusZoom = factory(d3);\n        });\n    } else if (typeof module === 'object' && module.exports) {\n        // commonJS\n        module.exports = root.LocusZoom = factory(require('d3'));\n    } else {\n        // globals\n        root.LocusZoom = factory(root.d3);\n    }\n}(this, function (d3) {\n    var semanticVersionIsOk = function (minimum_version, current_version) {\n        // handle the trivial case\n        if (current_version == minimum_version) {\n            return true;\n        }    // compare semantic versions by component as integers\n        // compare semantic versions by component as integers\n        var minimum_version_array = minimum_version.split('.');\n        var current_version_array = current_version.split('.');\n        var version_is_ok = false;\n        minimum_version_array.forEach(function (d, i) {\n            if (!version_is_ok && +current_version_array[i] > +minimum_version_array[i]) {\n                version_is_ok = true;\n            }\n        });\n        return version_is_ok;\n    };\n    try {\n        // Verify dependency: d3.js\n        var minimum_d3_version = '3.5.6';\n        if (typeof d3 != 'object') {\n            throw new Error('d3 dependency not met. Library missing.');\n        }\n        if (!semanticVersionIsOk(minimum_d3_version, d3.version)) {\n            throw new Error('d3 dependency not met. Outdated version detected.\\nRequired d3 version: ' + minimum_d3_version + ' or higher (found: ' + d3.version + ').');\n        }    // ESTemplate: module content goes here\n        // ESTemplate: module content goes here\n        ;\n        (function (root, factory) {\n            if (typeof define === 'function' && define.amd) {\n                define(['d3'], function (d3) {\n                    // amd\n                    return root.LocusZoom = factory(d3);\n                });\n            } else if (typeof module === 'object' && module.exports) {\n                // commonJS\n                module.exports = root.LocusZoom = factory(require('d3'));\n            } else {\n                // globals\n                root.LocusZoom = factory(root.d3);\n            }\n        }(this, function (d3) {\n            var semanticVersionIsOk = function (minimum_version, current_version) {\n                // handle the trivial case\n                if (current_version == minimum_version) {\n                    return true;\n                }\n                // compare semantic versions by component as integers\n                // compare semantic versions by component as integers\n                var minimum_version_array = minimum_version.split('.');\n                var current_version_array = current_version.split('.');\n                var version_is_ok = false;\n                minimum_version_array.forEach(function (d, i) {\n                    if (!version_is_ok && +current_version_array[i] > +minimum_version_array[i]) {\n                        version_is_ok = true;\n                    }\n                });\n                return version_is_ok;\n            };\n            try {\n                // Verify dependency: d3.js\n                var minimum_d3_version = '3.5.6';\n                if (typeof d3 != 'object') {\n                    throw new Error('d3 dependency not met. Library missing.');\n                }\n                if (!semanticVersionIsOk(minimum_d3_version, d3.version)) {\n                    throw new Error('d3 dependency not met. Outdated version detected.\\nRequired d3 version: ' + minimum_d3_version + ' or higher (found: ' + d3.version + ').');\n                }\n                // ESTemplate: module content goes here\n                // ESTemplate: module content goes here\n                ;\n                var LocusZoom = { version: '0.10.0-beta.1' };\n                /**\n * Populate a single element with a LocusZoom plot.\n * selector can be a string for a DOM Query or a d3 selector.\n * @param {String} selector CSS selector for the container element where the plot will be mounted. Any pre-existing\n *   content in the container will be completely replaced.\n * @param {LocusZoom.DataSources} datasource Ensemble of data providers used by the plot\n * @param {Object} layout A JSON-serializable object of layout configuration parameters\n * @returns {LocusZoom.Plot} The newly created plot instance\n */\n                LocusZoom.populate = function (selector, datasource, layout) {\n                    if (typeof selector == 'undefined') {\n                        throw new Error('LocusZoom.populate selector not defined');\n                    }\n                    // Empty the selector of any existing content\n                    d3.select(selector).html('');\n                    var plot;\n                    d3.select(selector).call(function () {\n                        // Require each containing element have an ID. If one isn't present, create one.\n                        if (typeof this.node().id == 'undefined') {\n                            var iterator = 0;\n                            while (!d3.select('#lz-' + iterator).empty()) {\n                                iterator++;\n                            }\n                            this.attr('id', '#lz-' + iterator);\n                        }\n                        // Create the plot\n                        plot = new LocusZoom.Plot(this.node().id, datasource, layout);\n                        plot.container = this.node();\n                        // Detect data-region and fill in state values if present\n                        if (typeof this.node().dataset !== 'undefined' && typeof this.node().dataset.region !== 'undefined') {\n                            var parsed_state = LocusZoom.parsePositionQuery(this.node().dataset.region);\n                            Object.keys(parsed_state).forEach(function (key) {\n                                plot.state[key] = parsed_state[key];\n                            });\n                        }\n                        // Add an SVG to the div and set its dimensions\n                        plot.svg = d3.select('div#' + plot.id).append('svg').attr('version', '1.1').attr('xmlns', 'http://www.w3.org/2000/svg').attr('id', plot.id + '_svg').attr('class', 'lz-locuszoom').style(plot.layout.style);\n                        plot.setDimensions();\n                        plot.positionPanels();\n                        // Initialize the plot\n                        plot.initialize();\n                        // If the plot has defined data sources then trigger its first mapping based on state values\n                        if (typeof datasource == 'object' && Object.keys(datasource).length) {\n                            plot.refresh();\n                        }\n                    });\n                    return plot;\n                };\n                /**\n * Populate arbitrarily many elements each with a LocusZoom plot\n *   using a common datasource and layout\n * @param {String} selector CSS selector for the container element where the plot will be mounted. Any pre-existing\n *   content in the container will be completely replaced.\n * @param {LocusZoom.DataSources} datasource Ensemble of data providers used by the plot\n * @param {Object} layout A JSON-serializable object of layout configuration parameters\n * @returns {LocusZoom.Plot[]}\n */\n                LocusZoom.populateAll = function (selector, datasource, layout) {\n                    var plots = [];\n                    d3.selectAll(selector).each(function (d, i) {\n                        plots[i] = LocusZoom.populate(this, datasource, layout);\n                    });\n                    return plots;\n                };\n                /**\n * Convert an integer chromosome position to an SI string representation (e.g. 23423456 => \"23.42\" (Mb))\n * @param {Number} pos Position\n * @param {Number} [exp] Exponent to use for the returned string, eg 6=> MB. If not specified, will attempt to guess\n *   the most appropriate SI prefix based on the number provided.\n * @param {Boolean} [suffix=false] Whether or not to append a suffix (e.g. \"Mb\") to the end of the returned string\n * @returns {string}\n */\n                LocusZoom.positionIntToString = function (pos, exp, suffix) {\n                    var exp_symbols = {\n                        0: '',\n                        3: 'K',\n                        6: 'M',\n                        9: 'G'\n                    };\n                    suffix = suffix || false;\n                    if (isNaN(exp) || exp === null) {\n                        var log = Math.log(pos) / Math.LN10;\n                        exp = Math.min(Math.max(log - log % 3, 0), 9);\n                    }\n                    var places_exp = exp - Math.floor((Math.log(pos) / Math.LN10).toFixed(exp + 3));\n                    var min_exp = Math.min(Math.max(exp, 0), 2);\n                    var places = Math.min(Math.max(places_exp, min_exp), 12);\n                    var ret = '' + (pos / Math.pow(10, exp)).toFixed(places);\n                    if (suffix && typeof exp_symbols[exp] !== 'undefined') {\n                        ret += ' ' + exp_symbols[exp] + 'b';\n                    }\n                    return ret;\n                };\n                /**\n * Convert an SI string chromosome position to an integer representation (e.g. \"5.8 Mb\" => 58000000)\n * @param {String} p The chromosome position\n * @returns {Number}\n */\n                LocusZoom.positionStringToInt = function (p) {\n                    var val = p.toUpperCase();\n                    val = val.replace(/,/g, '');\n                    var suffixre = /([KMG])[B]*$/;\n                    var suffix = suffixre.exec(val);\n                    var mult = 1;\n                    if (suffix) {\n                        if (suffix[1] === 'M') {\n                            mult = 1000000;\n                        } else if (suffix[1] === 'G') {\n                            mult = 1000000000;\n                        } else {\n                            mult = 1000;    //K\n                        }\n                        val = val.replace(suffixre, '');\n                    }\n                    val = Number(val) * mult;\n                    return val;\n                };\n                /**\n * Parse region queries into their constituent parts\n * TODO: handle genes (or send off to API)\n * @param {String} x A chromosome position query. May be any of the forms `chr:start-end`, `chr:center+offset`,\n *   or `chr:pos`\n * @returns {{chr:*, start: *, end:*} | {chr:*, position:*}}\n */\n                LocusZoom.parsePositionQuery = function (x) {\n                    var chrposoff = /^(\\w+):([\\d,.]+[kmgbKMGB]*)([-+])([\\d,.]+[kmgbKMGB]*)$/;\n                    var chrpos = /^(\\w+):([\\d,.]+[kmgbKMGB]*)$/;\n                    var match = chrposoff.exec(x);\n                    if (match) {\n                        if (match[3] === '+') {\n                            var center = LocusZoom.positionStringToInt(match[2]);\n                            var offset = LocusZoom.positionStringToInt(match[4]);\n                            return {\n                                chr: match[1],\n                                start: center - offset,\n                                end: center + offset\n                            };\n                        } else {\n                            return {\n                                chr: match[1],\n                                start: LocusZoom.positionStringToInt(match[2]),\n                                end: LocusZoom.positionStringToInt(match[4])\n                            };\n                        }\n                    }\n                    match = chrpos.exec(x);\n                    if (match) {\n                        return {\n                            chr: match[1],\n                            position: LocusZoom.positionStringToInt(match[2])\n                        };\n                    }\n                    return null;\n                };\n                /**\n * Generate a \"pretty\" set of ticks (multiples of 1, 2, or 5 on the same order of magnitude for the range)\n *   Based on R's \"pretty\" function: https://github.com/wch/r-source/blob/b156e3a711967f58131e23c1b1dc1ea90e2f0c43/src/appl/pretty.c\n * @param {Number[]} range A two-item array specifying [low, high] values for the axis range\n * @param {('low'|'high'|'both'|'neither')} [clip_range='neither'] What to do if first and last generated ticks extend\n *   beyond the range. Set this to \"low\", \"high\", \"both\", or \"neither\" to clip the first (low) or last (high) tick to\n *   be inside the range or allow them to extend beyond.\n *   e.g. \"low\" will clip the first (low) tick if it extends beyond the low end of the range but allow the\n *  last (high) tick to extend beyond the range. \"both\" clips both ends, \"neither\" allows both to extend beyond.\n * @param {Number} [target_tick_count=5] The approximate number of ticks you would like to be returned; may not be exact\n * @returns {Number[]}\n */\n                LocusZoom.prettyTicks = function (range, clip_range, target_tick_count) {\n                    if (typeof target_tick_count == 'undefined' || isNaN(parseInt(target_tick_count))) {\n                        target_tick_count = 5;\n                    }\n                    target_tick_count = parseInt(target_tick_count);\n                    var min_n = target_tick_count / 3;\n                    var shrink_sml = 0.75;\n                    var high_u_bias = 1.5;\n                    var u5_bias = 0.5 + 1.5 * high_u_bias;\n                    var d = Math.abs(range[0] - range[1]);\n                    var c = d / target_tick_count;\n                    if (Math.log(d) / Math.LN10 < -2) {\n                        c = Math.max(Math.abs(d)) * shrink_sml / min_n;\n                    }\n                    var base = Math.pow(10, Math.floor(Math.log(c) / Math.LN10));\n                    var base_toFixed = 0;\n                    if (base < 1 && base !== 0) {\n                        base_toFixed = Math.abs(Math.round(Math.log(base) / Math.LN10));\n                    }\n                    var unit = base;\n                    if (2 * base - c < high_u_bias * (c - unit)) {\n                        unit = 2 * base;\n                        if (5 * base - c < u5_bias * (c - unit)) {\n                            unit = 5 * base;\n                            if (10 * base - c < high_u_bias * (c - unit)) {\n                                unit = 10 * base;\n                            }\n                        }\n                    }\n                    var ticks = [];\n                    var i = parseFloat((Math.floor(range[0] / unit) * unit).toFixed(base_toFixed));\n                    while (i < range[1]) {\n                        ticks.push(i);\n                        i += unit;\n                        if (base_toFixed > 0) {\n                            i = parseFloat(i.toFixed(base_toFixed));\n                        }\n                    }\n                    ticks.push(i);\n                    if (typeof clip_range == 'undefined' || [\n                            'low',\n                            'high',\n                            'both',\n                            'neither'\n                        ].indexOf(clip_range) === -1) {\n                        clip_range = 'neither';\n                    }\n                    if (clip_range === 'low' || clip_range === 'both') {\n                        if (ticks[0] < range[0]) {\n                            ticks = ticks.slice(1);\n                        }\n                    }\n                    if (clip_range === 'high' || clip_range === 'both') {\n                        if (ticks[ticks.length - 1] > range[1]) {\n                            ticks.pop();\n                        }\n                    }\n                    return ticks;\n                };\n                /**\n * Make an AJAX request and return a promise.\n * From http://www.html5rocks.com/en/tutorials/cors/\n *   and with promises from https://gist.github.com/kriskowal/593076\n *\n * @param {String} method The HTTP verb\n * @param {String} url\n * @param {String} [body] The request body to send to the server\n * @param {Object} [headers] Object of custom request headers\n * @param {Number} [timeout] If provided, wait this long (in ms) before timing out\n * @returns {Promise}\n */\n                LocusZoom.createCORSPromise = function (method, url, body, headers, timeout) {\n                    return new Promise(function (resolve, reject) {\n                        var xhr = new XMLHttpRequest();\n                        if ('withCredentials' in xhr) {\n                            // Check if the XMLHttpRequest object has a \"withCredentials\" property.\n                            // \"withCredentials\" only exists on XMLHTTPRequest2 objects.\n                            xhr.open(method, url, true);\n                        } else if (typeof XDomainRequest != 'undefined') {\n                            // Otherwise, check if XDomainRequest.\n                            // XDomainRequest only exists in IE, and is IE's way of making CORS requests.\n                            xhr = new XDomainRequest();\n                            xhr.open(method, url);\n                        } else {\n                            // Otherwise, CORS is not supported by the browser.\n                            xhr = null;\n                        }\n                        if (xhr) {\n                            xhr.onreadystatechange = function () {\n                                if (xhr.readyState === 4) {\n                                    if (xhr.status === 200 || xhr.status === 0) {\n                                        resolve(xhr.response);\n                                    } else {\n                                        reject('HTTP ' + xhr.status + ' for ' + url);\n                                    }\n                                }\n                            };\n                            timeout && setTimeout(reject, timeout);\n                            body = typeof body !== 'undefined' ? body : '';\n                            if (typeof headers !== 'undefined') {\n                                for (var header in headers) {\n                                    xhr.setRequestHeader(header, headers[header]);\n                                }\n                            }\n                            // Send the request\n                            xhr.send(body);\n                        }\n                    });\n                };\n                /**\n * Validate a (presumed complete) plot state object against internal rules for consistency, and ensure the plot fits\n *   within any constraints imposed by the layout.\n * @param {Object} new_state\n * @param {Number} new_state.start\n * @param {Number} new_state.end\n * @param {Object} layout\n * @returns {*|{}}\n */\n                LocusZoom.validateState = function (new_state, layout) {\n                    new_state = new_state || {};\n                    layout = layout || {};\n                    // If a \"chr\", \"start\", and \"end\" are present then resolve start and end\n                    // to numeric values that are not decimal, negative, or flipped\n                    var validated_region = false;\n                    if (typeof new_state.chr != 'undefined' && typeof new_state.start != 'undefined' && typeof new_state.end != 'undefined') {\n                        // Determine a numeric scale and midpoint for the attempted region,\n                        var attempted_midpoint = null;\n                        var attempted_scale;\n                        new_state.start = Math.max(parseInt(new_state.start), 1);\n                        new_state.end = Math.max(parseInt(new_state.end), 1);\n                        if (isNaN(new_state.start) && isNaN(new_state.end)) {\n                            new_state.start = 1;\n                            new_state.end = 1;\n                            attempted_midpoint = 0.5;\n                            attempted_scale = 0;\n                        } else if (isNaN(new_state.start) || isNaN(new_state.end)) {\n                            attempted_midpoint = new_state.start || new_state.end;\n                            attempted_scale = 0;\n                            new_state.start = isNaN(new_state.start) ? new_state.end : new_state.start;\n                            new_state.end = isNaN(new_state.end) ? new_state.start : new_state.end;\n                        } else {\n                            attempted_midpoint = Math.round((new_state.start + new_state.end) / 2);\n                            attempted_scale = new_state.end - new_state.start;\n                            if (attempted_scale < 0) {\n                                var temp = new_state.start;\n                                new_state.end = new_state.start;\n                                new_state.start = temp;\n                                attempted_scale = new_state.end - new_state.start;\n                            }\n                            if (attempted_midpoint < 0) {\n                                new_state.start = 1;\n                                new_state.end = 1;\n                                attempted_scale = 0;\n                            }\n                        }\n                        validated_region = true;\n                    }\n                    // Constrain w/r/t layout-defined minimum region scale\n                    if (!isNaN(layout.min_region_scale) && validated_region && attempted_scale < layout.min_region_scale) {\n                        new_state.start = Math.max(attempted_midpoint - Math.floor(layout.min_region_scale / 2), 1);\n                        new_state.end = new_state.start + layout.min_region_scale;\n                    }\n                    // Constrain w/r/t layout-defined maximum region scale\n                    if (!isNaN(layout.max_region_scale) && validated_region && attempted_scale > layout.max_region_scale) {\n                        new_state.start = Math.max(attempted_midpoint - Math.floor(layout.max_region_scale / 2), 1);\n                        new_state.end = new_state.start + layout.max_region_scale;\n                    }\n                    return new_state;\n                };\n                //\n                /**\n * Replace placeholders in an html string with field values defined in a data object\n *  Only works on scalar values! Will ignore non-scalars.\n *\n *  NOTE: Trusts content exactly as given. XSS prevention is the responsibility of the implementer.\n * @param {Object} data\n * @param {String} html A placeholder string in which to substitute fields. Supports several template options:\n *   `{{field_name}}` is a variable placeholder for the value of `field_name` from the provided data\n *   `{{#if field_name}} Conditional text {{/if}}` will insert the contents of the tag only if the value exists.\n *     Since this is only an existence check, **variables with a value of 0 will be evaluated as true**.\n *     This can be used with namespaced values, `{{#if assoc:field}}`; any dynamic namespacing will be applied when the\n *     layout is first retrieved.\n * @returns {string}\n */\n                LocusZoom.parseFields = function (data, html) {\n                    if (typeof data != 'object') {\n                        throw new Error('LocusZoom.parseFields invalid arguments: data is not an object');\n                    }\n                    if (typeof html != 'string') {\n                        throw new Error('LocusZoom.parseFields invalid arguments: html is not a string');\n                    }\n                    // `tokens` is like [token,...]\n                    // `token` is like {text: '...'} or {variable: 'foo|bar'} or {condition: 'foo|bar'} or {close: 'if'}\n                    var tokens = [];\n                    var regex = /\\{\\{(?:(#if )?([A-Za-z0-9_:|]+)|(\\/if))\\}\\}/;\n                    while (html.length > 0) {\n                        var m = regex.exec(html);\n                        if (!m) {\n                            tokens.push({ text: html });\n                            html = '';\n                        } else if (m.index !== 0) {\n                            tokens.push({ text: html.slice(0, m.index) });\n                            html = html.slice(m.index);\n                        } else if (m[1] === '#if ') {\n                            tokens.push({ condition: m[2] });\n                            html = html.slice(m[0].length);\n                        } else if (m[2]) {\n                            tokens.push({ variable: m[2] });\n                            html = html.slice(m[0].length);\n                        } else if (m[3] === '/if') {\n                            tokens.push({ close: 'if' });\n                            html = html.slice(m[0].length);\n                        } else {\n                            console.error('Error tokenizing tooltip when remaining template is ' + JSON.stringify(html) + ' and previous tokens are ' + JSON.stringify(tokens) + ' and current regex match is ' + JSON.stringify([\n                                m[1],\n                                m[2],\n                                m[3]\n                            ]));\n                            html = html.slice(m[0].length);\n                        }\n                    }\n                    var astify = function () {\n                        var token = tokens.shift();\n                        if (typeof token.text !== 'undefined' || token.variable) {\n                            return token;\n                        } else if (token.condition) {\n                            token.then = [];\n                            while (tokens.length > 0) {\n                                if (tokens[0].close === 'if') {\n                                    tokens.shift();\n                                    break;\n                                }\n                                token.then.push(astify());\n                            }\n                            return token;\n                        } else {\n                            console.error('Error making tooltip AST due to unknown token ' + JSON.stringify(token));\n                            return { text: '' };\n                        }\n                    };\n                    // `ast` is like [thing,...]\n                    // `thing` is like {text: \"...\"} or {variable:\"foo|bar\"} or {condition: \"foo|bar\", then:[thing,...]}\n                    var ast = [];\n                    while (tokens.length > 0) {\n                        ast.push(astify());\n                    }\n                    var resolve = function (variable) {\n                        if (!resolve.cache.hasOwnProperty(variable)) {\n                            resolve.cache[variable] = new LocusZoom.Data.Field(variable).resolve(data);\n                        }\n                        return resolve.cache[variable];\n                    };\n                    resolve.cache = {};\n                    var render_node = function (node) {\n                        if (typeof node.text !== 'undefined') {\n                            return node.text;\n                        } else if (node.variable) {\n                            try {\n                                var value = resolve(node.variable);\n                                if ([\n                                        'string',\n                                        'number',\n                                        'boolean'\n                                    ].indexOf(typeof value) !== -1) {\n                                    return value;\n                                }\n                                if (value === null) {\n                                    return '';\n                                }\n                            } catch (error) {\n                                console.error('Error while processing variable ' + JSON.stringify(node.variable));\n                            }\n                            return '{{' + node.variable + '}}';\n                        } else if (node.condition) {\n                            try {\n                                var condition = resolve(node.condition);\n                                if (condition || condition === 0) {\n                                    return node.then.map(render_node).join('');\n                                }\n                            } catch (error) {\n                                console.error('Error while processing condition ' + JSON.stringify(node.variable));\n                            }\n                            return '';\n                        } else {\n                            console.error('Error rendering tooltip due to unknown AST node ' + JSON.stringify(node));\n                        }\n                    };\n                    return ast.map(render_node).join('');\n                };\n                /**\n * Shortcut method for getting the data bound to a tool tip.\n * @param {Element} node\n * @returns {*} The first element of data bound to the tooltip\n */\n                LocusZoom.getToolTipData = function (node) {\n                    if (typeof node != 'object' || typeof node.parentNode == 'undefined') {\n                        throw new Error('Invalid node object');\n                    }\n                    // If this node is a locuszoom tool tip then return its data\n                    var selector = d3.select(node);\n                    if (selector.classed('lz-data_layer-tooltip') && typeof selector.data()[0] != 'undefined') {\n                        return selector.data()[0];\n                    } else {\n                        return LocusZoom.getToolTipData(node.parentNode);\n                    }\n                };\n                /**\n * Shortcut method for getting a reference to the data layer that generated a tool tip.\n * @param {Element} node The element associated with the tooltip, or any element contained inside the tooltip\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.getToolTipDataLayer = function (node) {\n                    var data = LocusZoom.getToolTipData(node);\n                    if (data.getDataLayer) {\n                        return data.getDataLayer();\n                    }\n                    return null;\n                };\n                /**\n * Shortcut method for getting a reference to the panel that generated a tool tip.\n * @param {Element} node The element associated with the tooltip, or any element contained inside the tooltip\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.getToolTipPanel = function (node) {\n                    var data_layer = LocusZoom.getToolTipDataLayer(node);\n                    if (data_layer) {\n                        return data_layer.parent;\n                    }\n                    return null;\n                };\n                /**\n * Shortcut method for getting a reference to the plot that generated a tool tip.\n * @param {Element} node The element associated with the tooltip, or any element contained inside the tooltip\n * @returns {LocusZoom.Plot}\n */\n                LocusZoom.getToolTipPlot = function (node) {\n                    var panel = LocusZoom.getToolTipPanel(node);\n                    if (panel) {\n                        return panel.parent;\n                    }\n                    return null;\n                };\n                /**\n * Generate a curtain object for a plot, panel, or any other subdivision of a layout\n * The panel curtain, like the plot curtain is an HTML overlay that obscures the entire panel. It can be styled\n *   arbitrarily and display arbitrary messages. It is useful for reporting error messages visually to an end user\n *   when the error renders the panel unusable.\n *   TODO: Improve type doc here\n * @returns {object}\n */\n                LocusZoom.generateCurtain = function () {\n                    var curtain = {\n                        showing: false,\n                        selector: null,\n                        content_selector: null,\n                        hide_delay: null,\n                        /**\n         * Generate the curtain. Any content (string) argument passed will be displayed in the curtain as raw HTML.\n         *   CSS (object) can be passed which will apply styles to the curtain and its content.\n         * @param {string} content Content to be displayed on the curtain (as raw HTML)\n         * @param {object} css Apply the specified styles to the curtain and its contents\n         */\n                        show: function (content, css) {\n                            if (!this.curtain.showing) {\n                                this.curtain.selector = d3.select(this.parent_plot.svg.node().parentNode).insert('div').attr('class', 'lz-curtain').attr('id', this.id + '.curtain');\n                                this.curtain.content_selector = this.curtain.selector.append('div').attr('class', 'lz-curtain-content');\n                                this.curtain.selector.append('div').attr('class', 'lz-curtain-dismiss').html('Dismiss').on('click', function () {\n                                    this.curtain.hide();\n                                }.bind(this));\n                                this.curtain.showing = true;\n                            }\n                            return this.curtain.update(content, css);\n                        }.bind(this),\n                        /**\n         * Update the content and css of the curtain that's currently being shown. This method also adjusts the size\n         *   and positioning of the curtain to ensure it still covers the entire panel with no overlap.\n         * @param {string} content Content to be displayed on the curtain (as raw HTML)\n         * @param {object} css Apply the specified styles to the curtain and its contents\n         */\n                        update: function (content, css) {\n                            if (!this.curtain.showing) {\n                                return this.curtain;\n                            }\n                            clearTimeout(this.curtain.hide_delay);\n                            // Apply CSS if provided\n                            if (typeof css == 'object') {\n                                this.curtain.selector.style(css);\n                            }\n                            // Update size and position\n                            var page_origin = this.getPageOrigin();\n                            this.curtain.selector.style({\n                                top: page_origin.y + 'px',\n                                left: page_origin.x + 'px',\n                                width: this.layout.width + 'px',\n                                height: this.layout.height + 'px'\n                            });\n                            this.curtain.content_selector.style({\n                                'max-width': this.layout.width - 40 + 'px',\n                                'max-height': this.layout.height - 40 + 'px'\n                            });\n                            // Apply content if provided\n                            if (typeof content == 'string') {\n                                this.curtain.content_selector.html(content);\n                            }\n                            return this.curtain;\n                        }.bind(this),\n                        /**\n         * Remove the curtain\n         * @param {number} delay Time to wait (in ms)\n         */\n                        hide: function (delay) {\n                            if (!this.curtain.showing) {\n                                return this.curtain;\n                            }\n                            // If a delay was passed then defer to a timeout\n                            if (typeof delay == 'number') {\n                                clearTimeout(this.curtain.hide_delay);\n                                this.curtain.hide_delay = setTimeout(this.curtain.hide, delay);\n                                return this.curtain;\n                            }\n                            // Remove curtain\n                            this.curtain.selector.remove();\n                            this.curtain.selector = null;\n                            this.curtain.content_selector = null;\n                            this.curtain.showing = false;\n                            return this.curtain;\n                        }.bind(this)\n                    };\n                    return curtain;\n                };\n                /**\n * Generate a loader object for a plot, panel, or any other subdivision of a layout\n *\n * The panel loader is a small HTML overlay that appears in the lower left corner of the panel. It cannot be styled\n *   arbitrarily, but can show a custom message and show a minimalist loading bar that can be updated to specific\n *   completion percentages or be animated.\n * TODO Improve type documentation\n * @returns {object}\n */\n                LocusZoom.generateLoader = function () {\n                    var loader = {\n                        showing: false,\n                        selector: null,\n                        content_selector: null,\n                        progress_selector: null,\n                        cancel_selector: null,\n                        /**\n         * Show a loading indicator\n         * @param {string} [content='Loading...'] Loading message (displayed as raw HTML)\n         */\n                        show: function (content) {\n                            // Generate loader\n                            if (!this.loader.showing) {\n                                this.loader.selector = d3.select(this.parent_plot.svg.node().parentNode).insert('div').attr('class', 'lz-loader').attr('id', this.id + '.loader');\n                                this.loader.content_selector = this.loader.selector.append('div').attr('class', 'lz-loader-content');\n                                this.loader.progress_selector = this.loader.selector.append('div').attr('class', 'lz-loader-progress-container').append('div').attr('class', 'lz-loader-progress');\n                                /* TODO: figure out how to make this cancel button work\n                this.loader.cancel_selector = this.loader.selector.append(\"div\")\n                    .attr(\"class\", \"lz-loader-cancel\").html(\"Cancel\")\n                    .on(\"click\", function(){\n                        this.loader.hide();\n                    }.bind(this));\n                */\n                                this.loader.showing = true;\n                                if (typeof content == 'undefined') {\n                                    content = 'Loading...';\n                                }\n                            }\n                            return this.loader.update(content);\n                        }.bind(this),\n                        /**\n         * Update the currently displayed loader and ensure the new content is positioned correctly.\n         * @param {string} content The text to display (as raw HTML). If not a string, will be ignored.\n         * @param {number} [percent] A number from 1-100. If a value is specified, it will stop all animations\n         *   in progress.\n         */\n                        update: function (content, percent) {\n                            if (!this.loader.showing) {\n                                return this.loader;\n                            }\n                            clearTimeout(this.loader.hide_delay);\n                            // Apply content if provided\n                            if (typeof content == 'string') {\n                                this.loader.content_selector.html(content);\n                            }\n                            // Update size and position\n                            var padding = 6;\n                            // is there a better place to store/define this?\n                            var page_origin = this.getPageOrigin();\n                            var loader_boundrect = this.loader.selector.node().getBoundingClientRect();\n                            this.loader.selector.style({\n                                top: page_origin.y + this.layout.height - loader_boundrect.height - padding + 'px',\n                                left: page_origin.x + padding + 'px'\n                            });\n                            /* Uncomment this code when a functional cancel button can be shown\n            var cancel_boundrect = this.loader.cancel_selector.node().getBoundingClientRect();\n            this.loader.content_selector.style({\n                \"padding-right\": (cancel_boundrect.width + padding) + \"px\"\n            });\n            */\n                            // Apply percent if provided\n                            if (typeof percent == 'number') {\n                                this.loader.progress_selector.style({ width: Math.min(Math.max(percent, 1), 100) + '%' });\n                            }\n                            return this.loader;\n                        }.bind(this),\n                        /**\n         * Adds a class to the loading bar that makes it loop infinitely in a loading animation. Useful when exact\n         *   percent progress is not available.\n         */\n                        animate: function () {\n                            this.loader.progress_selector.classed('lz-loader-progress-animated', true);\n                            return this.loader;\n                        }.bind(this),\n                        /**\n         *  Sets the loading bar in the loader to percentage width equal to the percent (number) value passed. Percents\n         *    will automatically be limited to a range of 1 to 100. Will stop all animations in progress.\n         */\n                        setPercentCompleted: function (percent) {\n                            this.loader.progress_selector.classed('lz-loader-progress-animated', false);\n                            return this.loader.update(null, percent);\n                        }.bind(this),\n                        /**\n         * Remove the loader\n         * @param {number} delay Time to wait (in ms)\n         */\n                        hide: function (delay) {\n                            if (!this.loader.showing) {\n                                return this.loader;\n                            }\n                            // If a delay was passed then defer to a timeout\n                            if (typeof delay == 'number') {\n                                clearTimeout(this.loader.hide_delay);\n                                this.loader.hide_delay = setTimeout(this.loader.hide, delay);\n                                return this.loader;\n                            }\n                            // Remove loader\n                            this.loader.selector.remove();\n                            this.loader.selector = null;\n                            this.loader.content_selector = null;\n                            this.loader.progress_selector = null;\n                            this.loader.cancel_selector = null;\n                            this.loader.showing = false;\n                            return this.loader;\n                        }.bind(this)\n                    };\n                    return loader;\n                };\n                /**\n * Create a new subclass following classical inheritance patterns. Some registry singletons use this internally to\n *   enable code reuse and customization of known LZ core functionality.\n *\n * @param {Function} parent A parent class constructor that will be extended by the child class\n * @param {Object} extra An object of additional properties and methods to add/override behavior for the child class.\n *   The special \"constructor\" property can be used to specify a custom constructor, or it will call parent by default.\n *   Implementer must manage super calls when overriding the constructor.\n * @returns {Function} The constructor for the new child class\n */\n                LocusZoom.subclass = function (parent, extra) {\n                    if (typeof parent !== 'function') {\n                        throw new Error('Parent must be a callable constructor');\n                    }\n                    extra = extra || {};\n                    var Sub = extra.hasOwnProperty('constructor') ? extra.constructor : function () {\n                        parent.apply(this, arguments);\n                    };\n                    Sub.prototype = Object.create(parent.prototype);\n                    Object.keys(extra).forEach(function (k) {\n                        Sub.prototype[k] = extra[k];\n                    });\n                    return Sub;\n                };\n                /**\n * LocusZoom optional extensions will live under this namespace.\n *\n * Extension code is not part of the core LocusZoom app.js bundle.\n * @namespace\n * @public\n */\n                LocusZoom.ext = {};\n                /* global LocusZoom */\n                'use strict';\n                var LZ_SIG_THRESHOLD_LOGP = 7.301;\n                // -log10(.05/1e6)\n                /**\n * Manage known layouts for all parts of the LocusZoom plot\n *\n * This registry allows for layouts to be reused and customized many times on a page, using a common base pattern.\n *   It handles the work of ensuring that each new instance of the layout has no shared state with other copies.\n *\n * @class\n */\n                LocusZoom.Layouts = function () {\n                    var obj = {};\n                    var layouts = {\n                        'plot': {},\n                        'panel': {},\n                        'data_layer': {},\n                        'dashboard': {},\n                        'tooltip': {}\n                    };\n                    /**\n     * Generate a layout configuration object\n     * @param {('plot'|'panel'|'data_layer'|'dashboard'|'tooltip')} type The type of layout to retrieve\n     * @param {string} name Identifier of the predefined layout within the specified type\n     * @param {object} [modifications] Custom properties that override default settings for this layout\n     * @returns {object} A JSON-serializable object representation\n     */\n                    obj.get = function (type, name, modifications) {\n                        if (typeof type != 'string' || typeof name != 'string') {\n                            throw new Error('invalid arguments passed to LocusZoom.Layouts.get, requires string (layout type) and string (layout name)');\n                        } else if (layouts[type][name]) {\n                            // Get the base layout\n                            var layout = LocusZoom.Layouts.merge(modifications || {}, layouts[type][name]);\n                            // If \"unnamespaced\" is true then strike that from the layout and return the layout without namespacing\n                            if (layout.unnamespaced) {\n                                delete layout.unnamespaced;\n                                return JSON.parse(JSON.stringify(layout));\n                            }\n                            // Determine the default namespace for namespaced values\n                            var default_namespace = '';\n                            if (typeof layout.namespace == 'string') {\n                                default_namespace = layout.namespace;\n                            } else if (typeof layout.namespace == 'object' && Object.keys(layout.namespace).length) {\n                                if (typeof layout.namespace.default != 'undefined') {\n                                    default_namespace = layout.namespace.default;\n                                } else {\n                                    default_namespace = layout.namespace[Object.keys(layout.namespace)[0]].toString();\n                                }\n                            }\n                            default_namespace += default_namespace.length ? ':' : '';\n                            // Apply namespaces to layout, recursively\n                            var applyNamespaces = function (element, namespace) {\n                                if (namespace) {\n                                    if (typeof namespace == 'string') {\n                                        namespace = { default: namespace };\n                                    }\n                                } else {\n                                    namespace = { default: '' };\n                                }\n                                if (typeof element == 'string') {\n                                    var re = /\\{\\{namespace(\\[[A-Za-z_0-9]+\\]|)\\}\\}/g;\n                                    var match, base, key, resolved_namespace;\n                                    var replace = [];\n                                    while ((match = re.exec(element)) !== null) {\n                                        base = match[0];\n                                        key = match[1].length ? match[1].replace(/(\\[|\\])/g, '') : null;\n                                        resolved_namespace = default_namespace;\n                                        if (namespace != null && typeof namespace == 'object' && typeof namespace[key] != 'undefined') {\n                                            resolved_namespace = namespace[key] + (namespace[key].length ? ':' : '');\n                                        }\n                                        replace.push({\n                                            base: base,\n                                            namespace: resolved_namespace\n                                        });\n                                    }\n                                    for (var r in replace) {\n                                        element = element.replace(replace[r].base, replace[r].namespace);\n                                    }\n                                } else if (typeof element == 'object' && element != null) {\n                                    if (typeof element.namespace != 'undefined') {\n                                        var merge_namespace = typeof element.namespace == 'string' ? { default: element.namespace } : element.namespace;\n                                        namespace = LocusZoom.Layouts.merge(namespace, merge_namespace);\n                                    }\n                                    var namespaced_element, namespaced_property;\n                                    for (var property in element) {\n                                        if (property === 'namespace') {\n                                            continue;\n                                        }\n                                        namespaced_element = applyNamespaces(element[property], namespace);\n                                        namespaced_property = applyNamespaces(property, namespace);\n                                        if (property !== namespaced_property) {\n                                            delete element[property];\n                                        }\n                                        element[namespaced_property] = namespaced_element;\n                                    }\n                                }\n                                return element;\n                            };\n                            layout = applyNamespaces(layout, layout.namespace);\n                            // Return the layout as valid JSON only\n                            return JSON.parse(JSON.stringify(layout));\n                        } else {\n                            throw new Error('layout type [' + type + '] name [' + name + '] not found');\n                        }\n                    };\n                    /** @private */\n                    obj.set = function (type, name, layout) {\n                        if (typeof type != 'string' || typeof name != 'string' || typeof layout != 'object') {\n                            throw new Error('unable to set new layout; bad arguments passed to set()');\n                        }\n                        if (!layouts[type]) {\n                            layouts[type] = {};\n                        }\n                        if (layout) {\n                            return layouts[type][name] = JSON.parse(JSON.stringify(layout));\n                        } else {\n                            delete layouts[type][name];\n                            return null;\n                        }\n                    };\n                    /**\n     * Register a new layout definition by name.\n     *\n     * @param {string} type The type of layout to add. Usually, this will be one of the predefined LocusZoom types,\n     *   but if you pass a different name, this method will automatically create the new `type` bucket\n     * @param {string} name The identifier of the newly added layout\n     * @param {object} [layout] A JSON-serializable object containing configuration properties for this layout\n     * @returns The JSON representation of the newly created layout\n     */\n                    obj.add = function (type, name, layout) {\n                        return obj.set(type, name, layout);\n                    };\n                    /**\n     * List all registered layouts\n     * @param [type] Optionally narrow the list to only layouts of a specific type; else return all known layouts\n     * @returns {*}\n     */\n                    obj.list = function (type) {\n                        if (!layouts[type]) {\n                            var list = {};\n                            Object.keys(layouts).forEach(function (type) {\n                                list[type] = Object.keys(layouts[type]);\n                            });\n                            return list;\n                        } else {\n                            return Object.keys(layouts[type]);\n                        }\n                    };\n                    /**\n     * A helper method used for merging two objects. If a key is present in both, takes the value from the first object\n     *   Values from `default_layout` will be cleanly copied over, ensuring no references or shared state.\n     *\n     * Frequently used for preparing custom layouts. Both objects should be JSON-serializable.\n     *\n     * @param {object} custom_layout An object containing configuration parameters that override or add to defaults\n     * @param {object} default_layout An object containing default settings.\n     * @returns {object} The custom layout is modified in place and also returned from this method.\n     */\n                    obj.merge = function (custom_layout, default_layout) {\n                        if (typeof custom_layout !== 'object' || typeof default_layout !== 'object') {\n                            throw new Error('LocusZoom.Layouts.merge only accepts two layout objects; ' + typeof custom_layout + ', ' + typeof default_layout + ' given');\n                        }\n                        for (var property in default_layout) {\n                            if (!default_layout.hasOwnProperty(property)) {\n                                continue;\n                            }\n                            // Get types for comparison. Treat nulls in the custom layout as undefined for simplicity.\n                            // (javascript treats nulls as \"object\" when we just want to overwrite them as if they're undefined)\n                            // Also separate arrays from objects as a discrete type.\n                            var custom_type = custom_layout[property] === null ? 'undefined' : typeof custom_layout[property];\n                            var default_type = typeof default_layout[property];\n                            if (custom_type === 'object' && Array.isArray(custom_layout[property])) {\n                                custom_type = 'array';\n                            }\n                            if (default_type === 'object' && Array.isArray(default_layout[property])) {\n                                default_type = 'array';\n                            }\n                            // Unsupported property types: throw an exception\n                            if (custom_type === 'function' || default_type === 'function') {\n                                throw new Error('LocusZoom.Layouts.merge encountered an unsupported property type');\n                            }\n                            // Undefined custom value: pull the default value\n                            if (custom_type === 'undefined') {\n                                custom_layout[property] = JSON.parse(JSON.stringify(default_layout[property]));\n                                continue;\n                            }\n                            // Both values are objects: merge recursively\n                            if (custom_type === 'object' && default_type === 'object') {\n                                custom_layout[property] = LocusZoom.Layouts.merge(custom_layout[property], default_layout[property]);\n                                continue;\n                            }\n                        }\n                        return custom_layout;\n                    };\n                    return obj;\n                }();\n                /**\n * Tooltip Layouts\n * @namespace LocusZoom.Layouts.tooltips\n */\n                LocusZoom.Layouts.add('tooltip', 'standard_association', {\n                    namespace: { 'assoc': 'assoc' },\n                    closable: true,\n                    show: {\n                        or: [\n                            'highlighted',\n                            'selected'\n                        ]\n                    },\n                    hide: {\n                        and: [\n                            'unhighlighted',\n                            'unselected'\n                        ]\n                    },\n                    html: '<strong>{{{{namespace[assoc]}}variant|htmlescape}}</strong><br>' + 'P Value: <strong>{{{{namespace[assoc]}}log_pvalue|logtoscinotation|htmlescape}}</strong><br>' + 'Ref. Allele: <strong>{{{{namespace[assoc]}}ref_allele|htmlescape}}</strong><br>' + '<a href=\"javascript:void(0);\" onclick=\"LocusZoom.getToolTipDataLayer(this).makeLDReference(LocusZoom.getToolTipData(this));\">Make LD Reference</a><br>'\n                });\n                LocusZoom.Layouts.add('tooltip', 'covariates_model_association', function () {\n                    var covariates_model_association = LocusZoom.Layouts.get('tooltip', 'standard_association', { unnamespaced: true });\n                    covariates_model_association.html += '<a href=\"javascript:void(0);\" onclick=\"LocusZoom.getToolTipPlot(this).CovariatesModel.add(LocusZoom.getToolTipData(this));\">Condition on Variant</a><br>';\n                    return covariates_model_association;\n                }());\n                LocusZoom.Layouts.add('tooltip', 'standard_genes', {\n                    closable: true,\n                    show: {\n                        or: [\n                            'highlighted',\n                            'selected'\n                        ]\n                    },\n                    hide: {\n                        and: [\n                            'unhighlighted',\n                            'unselected'\n                        ]\n                    },\n                    html: '<h4><strong><i>{{gene_name|htmlescape}}</i></strong></h4>' + '<div style=\"float: left;\">Gene ID: <strong>{{gene_id|htmlescape}}</strong></div>' + '<div style=\"float: right;\">Transcript ID: <strong>{{transcript_id|htmlescape}}</strong></div>' + '<div style=\"clear: both;\"></div>' + '<table>' + '<tr><th>Constraint</th><th>Expected variants</th><th>Observed variants</th><th>Const. Metric</th></tr>' + '<tr><td>Synonymous</td><td>{{exp_syn|htmlescape}}</td><td>{{n_syn|htmlescape}}</td><td>z = {{syn_z|htmlescape}}</td></tr>' + '<tr><td>Missense</td><td>{{exp_mis|htmlescape}}</td><td>{{n_mis|htmlescape}}</td><td>z = {{mis_z|htmlescape}}</td></tr>' + '<tr><td>LoF</td><td>{{exp_lof|htmlescape}}</td><td>{{n_lof|htmlescape}}</td><td>pLI = {{pLI|htmlescape}}</td></tr>' + '</table>' + '<a href=\"http://exac.broadinstitute.org/gene/{{gene_id|htmlescape}}\" target=\"_new\">More data on ExAC</a>'\n                });\n                LocusZoom.Layouts.add('tooltip', 'standard_intervals', {\n                    namespace: { 'intervals': 'intervals' },\n                    closable: false,\n                    show: {\n                        or: [\n                            'highlighted',\n                            'selected'\n                        ]\n                    },\n                    hide: {\n                        and: [\n                            'unhighlighted',\n                            'unselected'\n                        ]\n                    },\n                    html: '{{{{namespace[intervals]}}state_name|htmlescape}}<br>{{{{namespace[intervals]}}start|htmlescape}}-{{{{namespace[intervals]}}end|htmlescape}}'\n                });\n                LocusZoom.Layouts.add('tooltip', 'catalog_variant', {\n                    namespace: {\n                        'assoc': 'assoc',\n                        'catalog': 'catalog'\n                    },\n                    closable: true,\n                    show: {\n                        or: [\n                            'highlighted',\n                            'selected'\n                        ]\n                    },\n                    hide: {\n                        and: [\n                            'unhighlighted',\n                            'unselected'\n                        ]\n                    },\n                    html: '<strong>{{{{namespace[catalog]}}variant|htmlescape}}</strong><br>' + 'Catalog entries: <strong>{{n_catalog_matches|htmlescape}}</strong><br>' + 'Top Trait: <strong>{{{{namespace[catalog]}}trait|htmlescape}}</strong><br>' + 'Top P Value: <strong>{{{{namespace[catalog]}}log_pvalue|logtoscinotation}}</strong><br>'    // User note: if a different catalog is used, the tooltip will need to be replaced with a different link URL\n+ 'More: <a href=\"https://www.ebi.ac.uk/gwas/search?query={{{{namespace[catalog]}}rsid|htmlescape}}\" target=\"_new\">GWAS catalog</a> / <a href=\"https://www.ncbi.nlm.nih.gov/snp/{{{{namespace[catalog]}}rsid|htmlescape}}\" target=\"_new\">dbSNP</a>'\n                });\n                /**\n * Data Layer Layouts: represent specific information from a data source\n * @namespace Layouts.data_layer\n */\n                LocusZoom.Layouts.add('data_layer', 'significance', {\n                    id: 'significance',\n                    type: 'orthogonal_line',\n                    orientation: 'horizontal',\n                    offset: LZ_SIG_THRESHOLD_LOGP\n                });\n                LocusZoom.Layouts.add('data_layer', 'recomb_rate', {\n                    namespace: { 'recomb': 'recomb' },\n                    id: 'recombrate',\n                    type: 'line',\n                    fields: [\n                        '{{namespace[recomb]}}position',\n                        '{{namespace[recomb]}}recomb_rate'\n                    ],\n                    z_index: 1,\n                    style: {\n                        'stroke': '#0000FF',\n                        'stroke-width': '1.5px'\n                    },\n                    x_axis: { field: '{{namespace[recomb]}}position' },\n                    y_axis: {\n                        axis: 2,\n                        field: '{{namespace[recomb]}}recomb_rate',\n                        floor: 0,\n                        ceiling: 100\n                    }\n                });\n                LocusZoom.Layouts.add('data_layer', 'association_pvalues', {\n                    namespace: {\n                        'assoc': 'assoc',\n                        'ld': 'ld'\n                    },\n                    id: 'associationpvalues',\n                    type: 'scatter',\n                    point_shape: {\n                        scale_function: 'if',\n                        field: '{{namespace[ld]}}isrefvar',\n                        parameters: {\n                            field_value: 1,\n                            then: 'diamond',\n                            else: 'circle'\n                        }\n                    },\n                    point_size: {\n                        scale_function: 'if',\n                        field: '{{namespace[ld]}}isrefvar',\n                        parameters: {\n                            field_value: 1,\n                            then: 80,\n                            else: 40\n                        }\n                    },\n                    color: [\n                        {\n                            scale_function: 'if',\n                            field: '{{namespace[ld]}}isrefvar',\n                            parameters: {\n                                field_value: 1,\n                                then: '#9632b8'\n                            }\n                        },\n                        {\n                            scale_function: 'numerical_bin',\n                            field: '{{namespace[ld]}}state',\n                            parameters: {\n                                breaks: [\n                                    0,\n                                    0.2,\n                                    0.4,\n                                    0.6,\n                                    0.8\n                                ],\n                                values: [\n                                    '#357ebd',\n                                    '#46b8da',\n                                    '#5cb85c',\n                                    '#eea236',\n                                    '#d43f3a'\n                                ]\n                            }\n                        },\n                        '#B8B8B8'\n                    ],\n                    legend: [\n                        {\n                            shape: 'diamond',\n                            color: '#9632b8',\n                            size: 40,\n                            label: 'LD Ref Var',\n                            class: 'lz-data_layer-scatter'\n                        },\n                        {\n                            shape: 'circle',\n                            color: '#d43f3a',\n                            size: 40,\n                            label: '1.0 > r\\xB2 \\u2265 0.8',\n                            class: 'lz-data_layer-scatter'\n                        },\n                        {\n                            shape: 'circle',\n                            color: '#eea236',\n                            size: 40,\n                            label: '0.8 > r\\xB2 \\u2265 0.6',\n                            class: 'lz-data_layer-scatter'\n                        },\n                        {\n                            shape: 'circle',\n                            color: '#5cb85c',\n                            size: 40,\n                            label: '0.6 > r\\xB2 \\u2265 0.4',\n                            class: 'lz-data_layer-scatter'\n                        },\n                        {\n                            shape: 'circle',\n                            color: '#46b8da',\n                            size: 40,\n                            label: '0.4 > r\\xB2 \\u2265 0.2',\n                            class: 'lz-data_layer-scatter'\n                        },\n                        {\n                            shape: 'circle',\n                            color: '#357ebd',\n                            size: 40,\n                            label: '0.2 > r\\xB2 \\u2265 0.0',\n                            class: 'lz-data_layer-scatter'\n                        },\n                        {\n                            shape: 'circle',\n                            color: '#B8B8B8',\n                            size: 40,\n                            label: 'no r\\xB2 data',\n                            class: 'lz-data_layer-scatter'\n                        }\n                    ],\n                    label: null,\n                    fields: [\n                        '{{namespace[assoc]}}variant',\n                        '{{namespace[assoc]}}position',\n                        '{{namespace[assoc]}}log_pvalue',\n                        '{{namespace[assoc]}}log_pvalue|logtoscinotation',\n                        '{{namespace[assoc]}}ref_allele',\n                        '{{namespace[ld]}}state',\n                        '{{namespace[ld]}}isrefvar'\n                    ],\n                    id_field: '{{namespace[assoc]}}variant',\n                    z_index: 2,\n                    x_axis: { field: '{{namespace[assoc]}}position' },\n                    y_axis: {\n                        axis: 1,\n                        field: '{{namespace[assoc]}}log_pvalue',\n                        floor: 0,\n                        upper_buffer: 0.1,\n                        min_extent: [\n                            0,\n                            10\n                        ]\n                    },\n                    behaviors: {\n                        onmouseover: [{\n                                action: 'set',\n                                status: 'highlighted'\n                            }],\n                        onmouseout: [{\n                                action: 'unset',\n                                status: 'highlighted'\n                            }],\n                        onclick: [{\n                                action: 'toggle',\n                                status: 'selected',\n                                exclusive: true\n                            }],\n                        onshiftclick: [{\n                                action: 'toggle',\n                                status: 'selected'\n                            }]\n                    },\n                    tooltip: LocusZoom.Layouts.get('tooltip', 'standard_association', { unnamespaced: true })\n                });\n                LocusZoom.Layouts.add('data_layer', 'association_pvalues_catalog', function () {\n                    // Slightly modify an existing layout\n                    var l = LocusZoom.Layouts.get('data_layer', 'association_pvalues', {\n                        unnamespaced: true,\n                        id: 'associationpvaluescatalog',\n                        fill_opacity: 0.7\n                    });\n                    l.tooltip.html += '{{#if {{namespace[catalog]}}rsid}}<br><a href=\"https://www.ebi.ac.uk/gwas/search?query={{{{namespace[catalog]}}rsid|htmlescape}}\" target=\"_new\">See hits in GWAS catalog</a>{{/if}}';\n                    l.namespace.catalog = 'catalog';\n                    l.fields.push('{{namespace[catalog]}}rsid', '{{namespace[catalog]}}trait', '{{namespace[catalog]}}log_pvalue');\n                    return l;\n                }());\n                LocusZoom.Layouts.add('data_layer', 'phewas_pvalues', {\n                    namespace: { 'phewas': 'phewas' },\n                    id: 'phewaspvalues',\n                    type: 'category_scatter',\n                    point_shape: 'circle',\n                    point_size: 70,\n                    tooltip_positioning: 'vertical',\n                    id_field: '{{namespace[phewas]}}id',\n                    fields: [\n                        '{{namespace[phewas]}}id',\n                        '{{namespace[phewas]}}log_pvalue',\n                        '{{namespace[phewas]}}trait_group',\n                        '{{namespace[phewas]}}trait_label'\n                    ],\n                    x_axis: {\n                        field: '{{namespace[phewas]}}x',\n                        // Synthetic/derived field added by `category_scatter` layer\n                        category_field: '{{namespace[phewas]}}trait_group',\n                        lower_buffer: 0.025,\n                        upper_buffer: 0.025\n                    },\n                    y_axis: {\n                        axis: 1,\n                        field: '{{namespace[phewas]}}log_pvalue',\n                        floor: 0,\n                        upper_buffer: 0.15\n                    },\n                    color: [{\n                            field: '{{namespace[phewas]}}trait_group',\n                            scale_function: 'categorical_bin',\n                            parameters: {\n                                categories: [],\n                                values: [],\n                                null_value: '#B8B8B8'\n                            }\n                        }],\n                    fill_opacity: 0.7,\n                    tooltip: {\n                        closable: true,\n                        show: {\n                            or: [\n                                'highlighted',\n                                'selected'\n                            ]\n                        },\n                        hide: {\n                            and: [\n                                'unhighlighted',\n                                'unselected'\n                            ]\n                        },\n                        html: [\n                            '<strong>Trait:</strong> {{{{namespace[phewas]}}trait_label|htmlescape}}<br>',\n                            '<strong>Trait Category:</strong> {{{{namespace[phewas]}}trait_group|htmlescape}}<br>',\n                            '<strong>P-value:</strong> {{{{namespace[phewas]}}log_pvalue|logtoscinotation|htmlescape}}<br>'\n                        ].join('')\n                    },\n                    behaviors: {\n                        onmouseover: [{\n                                action: 'set',\n                                status: 'highlighted'\n                            }],\n                        onmouseout: [{\n                                action: 'unset',\n                                status: 'highlighted'\n                            }],\n                        onclick: [{\n                                action: 'toggle',\n                                status: 'selected',\n                                exclusive: true\n                            }],\n                        onshiftclick: [{\n                                action: 'toggle',\n                                status: 'selected'\n                            }]\n                    },\n                    label: {\n                        text: '{{{{namespace[phewas]}}trait_label|htmlescape}}',\n                        spacing: 6,\n                        lines: {\n                            style: {\n                                'stroke-width': '2px',\n                                'stroke': '#333333',\n                                'stroke-dasharray': '2px 2px'\n                            }\n                        },\n                        filters: [{\n                                field: '{{namespace[phewas]}}log_pvalue',\n                                operator: '>=',\n                                value: 20\n                            }],\n                        style: {\n                            'font-size': '14px',\n                            'font-weight': 'bold',\n                            'fill': '#333333'\n                        }\n                    }\n                });\n                LocusZoom.Layouts.add('data_layer', 'genes', {\n                    namespace: {\n                        'gene': 'gene',\n                        'constraint': 'constraint'\n                    },\n                    id: 'genes',\n                    type: 'genes',\n                    fields: [\n                        '{{namespace[gene]}}all',\n                        '{{namespace[constraint]}}all'\n                    ],\n                    id_field: 'gene_id',\n                    behaviors: {\n                        onmouseover: [{\n                                action: 'set',\n                                status: 'highlighted'\n                            }],\n                        onmouseout: [{\n                                action: 'unset',\n                                status: 'highlighted'\n                            }],\n                        onclick: [{\n                                action: 'toggle',\n                                status: 'selected',\n                                exclusive: true\n                            }],\n                        onshiftclick: [{\n                                action: 'toggle',\n                                status: 'selected'\n                            }]\n                    },\n                    tooltip: LocusZoom.Layouts.get('tooltip', 'standard_genes', { unnamespaced: true })\n                });\n                LocusZoom.Layouts.add('data_layer', 'genome_legend', {\n                    namespace: { 'genome': 'genome' },\n                    id: 'genome_legend',\n                    type: 'genome_legend',\n                    fields: [\n                        '{{namespace[genome]}}chr',\n                        '{{namespace[genome]}}base_pairs'\n                    ],\n                    x_axis: {\n                        floor: 0,\n                        ceiling: 2881033286\n                    }\n                });\n                LocusZoom.Layouts.add('data_layer', 'intervals', {\n                    namespace: { 'intervals': 'intervals' },\n                    id: 'intervals',\n                    type: 'intervals',\n                    fields: [\n                        '{{namespace[intervals]}}start',\n                        '{{namespace[intervals]}}end',\n                        '{{namespace[intervals]}}state_id',\n                        '{{namespace[intervals]}}state_name'\n                    ],\n                    id_field: '{{namespace[intervals]}}start',\n                    start_field: '{{namespace[intervals]}}start',\n                    end_field: '{{namespace[intervals]}}end',\n                    track_split_field: '{{namespace[intervals]}}state_id',\n                    split_tracks: true,\n                    always_hide_legend: false,\n                    color: {\n                        field: '{{namespace[intervals]}}state_id',\n                        scale_function: 'categorical_bin',\n                        parameters: {\n                            categories: [\n                                1,\n                                2,\n                                3,\n                                4,\n                                5,\n                                6,\n                                7,\n                                8,\n                                9,\n                                10,\n                                11,\n                                12,\n                                13\n                            ],\n                            values: [\n                                'rgb(212,63,58)',\n                                'rgb(250,120,105)',\n                                'rgb(252,168,139)',\n                                'rgb(240,189,66)',\n                                'rgb(250,224,105)',\n                                'rgb(240,238,84)',\n                                'rgb(244,252,23)',\n                                'rgb(23,232,252)',\n                                'rgb(32,191,17)',\n                                'rgb(23,166,77)',\n                                'rgb(32,191,17)',\n                                'rgb(162,133,166)',\n                                'rgb(212,212,212)'\n                            ],\n                            null_value: '#B8B8B8'\n                        }\n                    },\n                    legend: [\n                        {\n                            shape: 'rect',\n                            color: 'rgb(212,63,58)',\n                            width: 9,\n                            label: 'Active Promoter',\n                            '{{namespace[intervals]}}state_id': 1\n                        },\n                        {\n                            shape: 'rect',\n                            color: 'rgb(250,120,105)',\n                            width: 9,\n                            label: 'Weak Promoter',\n                            '{{namespace[intervals]}}state_id': 2\n                        },\n                        {\n                            shape: 'rect',\n                            color: 'rgb(252,168,139)',\n                            width: 9,\n                            label: 'Poised Promoter',\n                            '{{namespace[intervals]}}state_id': 3\n                        },\n                        {\n                            shape: 'rect',\n                            color: 'rgb(240,189,66)',\n                            width: 9,\n                            label: 'Strong enhancer',\n                            '{{namespace[intervals]}}state_id': 4\n                        },\n                        {\n                            shape: 'rect',\n                            color: 'rgb(250,224,105)',\n                            width: 9,\n                            label: 'Strong enhancer',\n                            '{{namespace[intervals]}}state_id': 5\n                        },\n                        {\n                            shape: 'rect',\n                            color: 'rgb(240,238,84)',\n                            width: 9,\n                            label: 'Weak enhancer',\n                            '{{namespace[intervals]}}state_id': 6\n                        },\n                        {\n                            shape: 'rect',\n                            color: 'rgb(244,252,23)',\n                            width: 9,\n                            label: 'Weak enhancer',\n                            '{{namespace[intervals]}}state_id': 7\n                        },\n                        {\n                            shape: 'rect',\n                            color: 'rgb(23,232,252)',\n                            width: 9,\n                            label: 'Insulator',\n                            '{{namespace[intervals]}}state_id': 8\n                        },\n                        {\n                            shape: 'rect',\n                            color: 'rgb(32,191,17)',\n                            width: 9,\n                            label: 'Transcriptional transition',\n                            '{{namespace[intervals]}}state_id': 9\n                        },\n                        {\n                            shape: 'rect',\n                            color: 'rgb(23,166,77)',\n                            width: 9,\n                            label: 'Transcriptional elongation',\n                            '{{namespace[intervals]}}state_id': 10\n                        },\n                        {\n                            shape: 'rect',\n                            color: 'rgb(136,240,129)',\n                            width: 9,\n                            label: 'Weak transcribed',\n                            '{{namespace[intervals]}}state_id': 11\n                        },\n                        {\n                            shape: 'rect',\n                            color: 'rgb(162,133,166)',\n                            width: 9,\n                            label: 'Polycomb-repressed',\n                            '{{namespace[intervals]}}state_id': 12\n                        },\n                        {\n                            shape: 'rect',\n                            color: 'rgb(212,212,212)',\n                            width: 9,\n                            label: 'Heterochromatin / low signal',\n                            '{{namespace[intervals]}}state_id': 13\n                        }\n                    ],\n                    behaviors: {\n                        onmouseover: [{\n                                action: 'set',\n                                status: 'highlighted'\n                            }],\n                        onmouseout: [{\n                                action: 'unset',\n                                status: 'highlighted'\n                            }],\n                        onclick: [{\n                                action: 'toggle',\n                                status: 'selected',\n                                exclusive: true\n                            }],\n                        onshiftclick: [{\n                                action: 'toggle',\n                                status: 'selected'\n                            }]\n                    },\n                    tooltip: LocusZoom.Layouts.get('tooltip', 'standard_intervals', { unnamespaced: true })\n                });\n                LocusZoom.Layouts.add('data_layer', 'annotation_catalog', {\n                    // Identify GWAS hits that are present in the GWAS catalog\n                    namespace: {\n                        'assoc': 'assoc',\n                        'catalog': 'catalog'\n                    },\n                    id: 'annotation_catalog',\n                    type: 'annotation_track',\n                    id_field: '{{namespace[catalog]}}variant',\n                    x_axis: { field: '{{namespace[assoc]}}position' },\n                    color: '#0000CC',\n                    fields: [\n                        '{{namespace[assoc]}}variant',\n                        '{{namespace[assoc]}}chromosome',\n                        '{{namespace[assoc]}}position',\n                        '{{namespace[catalog]}}variant',\n                        '{{namespace[catalog]}}rsid',\n                        '{{namespace[catalog]}}trait',\n                        '{{namespace[catalog]}}log_pvalue',\n                        '{{namespace[catalog]}}pos'\n                    ],\n                    filters: [\n                        // Specify which points to show on the track. Any selection must satisfy ALL filters\n                        [\n                            '{{namespace[catalog]}}rsid',\n                            '!=',\n                            null\n                        ],\n                        [\n                            '{{namespace[catalog]}}log_pvalue',\n                            '>',\n                            LZ_SIG_THRESHOLD_LOGP\n                        ]\n                    ],\n                    behaviors: {\n                        onmouseover: [{\n                                action: 'set',\n                                status: 'highlighted'\n                            }],\n                        onmouseout: [{\n                                action: 'unset',\n                                status: 'highlighted'\n                            }],\n                        onclick: [{\n                                action: 'toggle',\n                                status: 'selected',\n                                exclusive: true\n                            }],\n                        onshiftclick: [{\n                                action: 'toggle',\n                                status: 'selected'\n                            }]\n                    },\n                    tooltip: LocusZoom.Layouts.get('tooltip', 'catalog_variant', { unnamespaced: true }),\n                    tooltip_positioning: 'top'\n                });\n                /**\n * Dashboard Layouts: toolbar buttons etc\n * @namespace Layouts.dashboard\n */\n                LocusZoom.Layouts.add('dashboard', 'standard_panel', {\n                    components: [\n                        {\n                            type: 'remove_panel',\n                            position: 'right',\n                            color: 'red',\n                            group_position: 'end'\n                        },\n                        {\n                            type: 'move_panel_up',\n                            position: 'right',\n                            group_position: 'middle'\n                        },\n                        {\n                            type: 'move_panel_down',\n                            position: 'right',\n                            group_position: 'start',\n                            style: { 'margin-left': '0.75em' }\n                        }\n                    ]\n                });\n                LocusZoom.Layouts.add('dashboard', 'standard_plot', {\n                    components: [\n                        {\n                            type: 'title',\n                            title: 'LocusZoom',\n                            subtitle: '<a href=\"https://statgen.github.io/locuszoom/\" target=\"_blank\">v' + LocusZoom.version + '</a>',\n                            position: 'left'\n                        },\n                        {\n                            type: 'download',\n                            position: 'right'\n                        }\n                    ]\n                });\n                LocusZoom.Layouts.add('dashboard', 'covariates_model_plot', function () {\n                    var covariates_model_plot_dashboard = LocusZoom.Layouts.get('dashboard', 'standard_plot', { unnamespaced: true });\n                    covariates_model_plot_dashboard.components.push({\n                        type: 'covariates_model',\n                        button_html: 'Model',\n                        button_title: 'Show and edit covariates currently in model',\n                        position: 'left'\n                    });\n                    return covariates_model_plot_dashboard;\n                }());\n                LocusZoom.Layouts.add('dashboard', 'region_nav_plot', function () {\n                    var region_nav_plot_dashboard = LocusZoom.Layouts.get('dashboard', 'standard_plot', { unnamespaced: true });\n                    region_nav_plot_dashboard.components.push({\n                        type: 'shift_region',\n                        step: 500000,\n                        button_html: '>>',\n                        position: 'right',\n                        group_position: 'end'\n                    }, {\n                        type: 'shift_region',\n                        step: 50000,\n                        button_html: '>',\n                        position: 'right',\n                        group_position: 'middle'\n                    }, {\n                        type: 'zoom_region',\n                        step: 0.2,\n                        position: 'right',\n                        group_position: 'middle'\n                    }, {\n                        type: 'zoom_region',\n                        step: -0.2,\n                        position: 'right',\n                        group_position: 'middle'\n                    }, {\n                        type: 'shift_region',\n                        step: -50000,\n                        button_html: '<',\n                        position: 'right',\n                        group_position: 'middle'\n                    }, {\n                        type: 'shift_region',\n                        step: -500000,\n                        button_html: '<<',\n                        position: 'right',\n                        group_position: 'start'\n                    });\n                    return region_nav_plot_dashboard;\n                }());\n                /**\n * Panel Layouts\n * @namespace Layouts.panel\n */\n                LocusZoom.Layouts.add('panel', 'association', {\n                    id: 'association',\n                    width: 800,\n                    height: 225,\n                    min_width: 400,\n                    min_height: 200,\n                    proportional_width: 1,\n                    margin: {\n                        top: 35,\n                        right: 50,\n                        bottom: 40,\n                        left: 50\n                    },\n                    inner_border: 'rgb(210, 210, 210)',\n                    dashboard: function () {\n                        var l = LocusZoom.Layouts.get('dashboard', 'standard_panel', { unnamespaced: true });\n                        l.components.push({\n                            type: 'toggle_legend',\n                            position: 'right'\n                        });\n                        return l;\n                    }(),\n                    axes: {\n                        x: {\n                            label: 'Chromosome {{chr}} (Mb)',\n                            label_offset: 32,\n                            tick_format: 'region',\n                            extent: 'state'\n                        },\n                        y1: {\n                            label: '-log10 p-value',\n                            label_offset: 28\n                        },\n                        y2: {\n                            label: 'Recombination Rate (cM/Mb)',\n                            label_offset: 40\n                        }\n                    },\n                    legend: {\n                        orientation: 'vertical',\n                        origin: {\n                            x: 55,\n                            y: 40\n                        },\n                        hidden: true\n                    },\n                    interaction: {\n                        drag_background_to_pan: true,\n                        drag_x_ticks_to_scale: true,\n                        drag_y1_ticks_to_scale: true,\n                        drag_y2_ticks_to_scale: true,\n                        scroll_to_zoom: true,\n                        x_linked: true\n                    },\n                    data_layers: [\n                        LocusZoom.Layouts.get('data_layer', 'significance', { unnamespaced: true }),\n                        LocusZoom.Layouts.get('data_layer', 'recomb_rate', { unnamespaced: true }),\n                        LocusZoom.Layouts.get('data_layer', 'association_pvalues', { unnamespaced: true })\n                    ]\n                });\n                LocusZoom.Layouts.add('panel', 'association_catalog', function () {\n                    var l = LocusZoom.Layouts.get('panel', 'association', {\n                        unnamespaced: true,\n                        id: 'associationcatalog',\n                        namespace: {\n                            'assoc': 'assoc',\n                            'ld': 'ld',\n                            'catalog': 'catalog'\n                        }    // Required to resolve display options\n                    });\n                    l.dashboard.components.push({\n                        type: 'display_options',\n                        position: 'right',\n                        color: 'blue',\n                        // Below: special config specific to this widget\n                        button_html: 'Display options...',\n                        button_title: 'Control how plot items are displayed',\n                        layer_name: 'associationpvaluescatalog',\n                        default_config_display_name: 'No catalog labels (default)',\n                        // display name for the default plot color option (allow user to revert to plot defaults)\n                        options: [{\n                                // First dropdown menu item\n                                display_name: 'Label catalog traits',\n                                // Human readable representation of field name\n                                display: {\n                                    // Specify layout directives that control display of the plot for this option\n                                    label: {\n                                        text: '{{{{namespace[catalog]}}trait|htmlescape}}',\n                                        spacing: 6,\n                                        lines: {\n                                            style: {\n                                                'stroke-width': '2px',\n                                                'stroke': '#333333',\n                                                'stroke-dasharray': '2px 2px'\n                                            }\n                                        },\n                                        filters: [\n                                            // Only label points if they are significant for some trait in the catalog, AND in high LD\n                                            //  with the top hit of interest\n                                            {\n                                                field: '{{namespace[catalog]}}trait',\n                                                operator: '!=',\n                                                value: null\n                                            },\n                                            {\n                                                field: '{{namespace[catalog]}}log_pvalue',\n                                                operator: '>',\n                                                value: LZ_SIG_THRESHOLD_LOGP\n                                            },\n                                            {\n                                                field: '{{namespace[ld]}}state',\n                                                operator: '>',\n                                                value: 0.4\n                                            }\n                                        ],\n                                        style: {\n                                            'font-size': '10px',\n                                            'font-weight': 'bold',\n                                            'fill': '#333333'\n                                        }\n                                    }\n                                }\n                            }]\n                    });\n                    l.data_layers = [\n                        LocusZoom.Layouts.get('data_layer', 'significance', { unnamespaced: true }),\n                        LocusZoom.Layouts.get('data_layer', 'recomb_rate', { unnamespaced: true }),\n                        LocusZoom.Layouts.get('data_layer', 'association_pvalues_catalog', { unnamespaced: true })\n                    ];\n                    return l;\n                }());\n                LocusZoom.Layouts.add('panel', 'genes', {\n                    id: 'genes',\n                    width: 800,\n                    height: 225,\n                    min_width: 400,\n                    min_height: 112.5,\n                    proportional_width: 1,\n                    margin: {\n                        top: 20,\n                        right: 50,\n                        bottom: 20,\n                        left: 50\n                    },\n                    axes: {},\n                    interaction: {\n                        drag_background_to_pan: true,\n                        scroll_to_zoom: true,\n                        x_linked: true\n                    },\n                    dashboard: function () {\n                        var l = LocusZoom.Layouts.get('dashboard', 'standard_panel', { unnamespaced: true });\n                        l.components.push({\n                            type: 'resize_to_data',\n                            position: 'right'\n                        });\n                        return l;\n                    }(),\n                    data_layers: [LocusZoom.Layouts.get('data_layer', 'genes', { unnamespaced: true })]\n                });\n                LocusZoom.Layouts.add('panel', 'phewas', {\n                    id: 'phewas',\n                    width: 800,\n                    height: 300,\n                    min_width: 800,\n                    min_height: 300,\n                    proportional_width: 1,\n                    margin: {\n                        top: 20,\n                        right: 50,\n                        bottom: 120,\n                        left: 50\n                    },\n                    inner_border: 'rgb(210, 210, 210)',\n                    axes: {\n                        x: {\n                            ticks: {\n                                // Object based config (shared defaults; allow layers to specify ticks)\n                                style: {\n                                    'font-weight': 'bold',\n                                    'font-size': '11px',\n                                    'text-anchor': 'start'\n                                },\n                                transform: 'rotate(50)',\n                                position: 'left'    // Special param recognized by `category_scatter` layers\n                            }\n                        },\n                        y1: {\n                            label: '-log10 p-value',\n                            label_offset: 28\n                        }\n                    },\n                    data_layers: [\n                        LocusZoom.Layouts.get('data_layer', 'significance', { unnamespaced: true }),\n                        LocusZoom.Layouts.get('data_layer', 'phewas_pvalues', { unnamespaced: true })\n                    ]\n                });\n                LocusZoom.Layouts.add('panel', 'genome_legend', {\n                    id: 'genome_legend',\n                    width: 800,\n                    height: 50,\n                    origin: {\n                        x: 0,\n                        y: 300\n                    },\n                    min_width: 800,\n                    min_height: 50,\n                    proportional_width: 1,\n                    margin: {\n                        top: 0,\n                        right: 50,\n                        bottom: 35,\n                        left: 50\n                    },\n                    axes: {\n                        x: {\n                            label: 'Genomic Position (number denotes chromosome)',\n                            label_offset: 35,\n                            ticks: [\n                                {\n                                    x: 124625310,\n                                    text: '1',\n                                    style: {\n                                        'fill': 'rgb(120, 120, 186)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 370850307,\n                                    text: '2',\n                                    style: {\n                                        'fill': 'rgb(0, 0, 66)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 591461209,\n                                    text: '3',\n                                    style: {\n                                        'fill': 'rgb(120, 120, 186)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 786049562,\n                                    text: '4',\n                                    style: {\n                                        'fill': 'rgb(0, 0, 66)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 972084330,\n                                    text: '5',\n                                    style: {\n                                        'fill': 'rgb(120, 120, 186)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 1148099493,\n                                    text: '6',\n                                    style: {\n                                        'fill': 'rgb(0, 0, 66)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 1313226358,\n                                    text: '7',\n                                    style: {\n                                        'fill': 'rgb(120, 120, 186)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 1465977701,\n                                    text: '8',\n                                    style: {\n                                        'fill': 'rgb(0, 0, 66)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 1609766427,\n                                    text: '9',\n                                    style: {\n                                        'fill': 'rgb(120, 120, 186)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 1748140516,\n                                    text: '10',\n                                    style: {\n                                        'fill': 'rgb(0, 0, 66)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 1883411148,\n                                    text: '11',\n                                    style: {\n                                        'fill': 'rgb(120, 120, 186)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 2017840353,\n                                    text: '12',\n                                    style: {\n                                        'fill': 'rgb(0, 0, 66)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 2142351240,\n                                    text: '13',\n                                    style: {\n                                        'fill': 'rgb(120, 120, 186)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 2253610949,\n                                    text: '14',\n                                    style: {\n                                        'fill': 'rgb(0, 0, 66)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 2358551415,\n                                    text: '15',\n                                    style: {\n                                        'fill': 'rgb(120, 120, 186)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 2454994487,\n                                    text: '16',\n                                    style: {\n                                        'fill': 'rgb(0, 0, 66)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 2540769469,\n                                    text: '17',\n                                    style: {\n                                        'fill': 'rgb(120, 120, 186)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 2620405698,\n                                    text: '18',\n                                    style: {\n                                        'fill': 'rgb(0, 0, 66)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 2689008813,\n                                    text: '19',\n                                    style: {\n                                        'fill': 'rgb(120, 120, 186)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 2750086065,\n                                    text: '20',\n                                    style: {\n                                        'fill': 'rgb(0, 0, 66)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 2805663772,\n                                    text: '21',\n                                    style: {\n                                        'fill': 'rgb(120, 120, 186)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                },\n                                {\n                                    x: 2855381003,\n                                    text: '22',\n                                    style: {\n                                        'fill': 'rgb(0, 0, 66)',\n                                        'text-anchor': 'center',\n                                        'font-size': '13px',\n                                        'font-weight': 'bold'\n                                    },\n                                    transform: 'translate(0, 2)'\n                                }\n                            ]\n                        }\n                    },\n                    data_layers: [LocusZoom.Layouts.get('data_layer', 'genome_legend', { unnamespaced: true })]\n                });\n                LocusZoom.Layouts.add('panel', 'intervals', {\n                    id: 'intervals',\n                    width: 1000,\n                    height: 50,\n                    min_width: 500,\n                    min_height: 50,\n                    margin: {\n                        top: 25,\n                        right: 150,\n                        bottom: 5,\n                        left: 50\n                    },\n                    dashboard: function () {\n                        var l = LocusZoom.Layouts.get('dashboard', 'standard_panel', { unnamespaced: true });\n                        l.components.push({\n                            type: 'toggle_split_tracks',\n                            data_layer_id: 'intervals',\n                            position: 'right'\n                        });\n                        return l;\n                    }(),\n                    axes: {},\n                    interaction: {\n                        drag_background_to_pan: true,\n                        scroll_to_zoom: true,\n                        x_linked: true\n                    },\n                    legend: {\n                        hidden: true,\n                        orientation: 'horizontal',\n                        origin: {\n                            x: 50,\n                            y: 0\n                        },\n                        pad_from_bottom: 5\n                    },\n                    data_layers: [LocusZoom.Layouts.get('data_layer', 'intervals', { unnamespaced: true })]\n                });\n                LocusZoom.Layouts.add('panel', 'annotation_catalog', {\n                    id: 'annotationcatalog',\n                    width: 800,\n                    height: 50,\n                    min_height: 50,\n                    proportional_width: 1,\n                    margin: {\n                        top: 25,\n                        right: 50,\n                        bottom: 0,\n                        left: 50\n                    },\n                    inner_border: 'rgb(210, 210, 210)',\n                    dashboard: LocusZoom.Layouts.get('dashboard', 'standard_panel', { unnamespaced: true }),\n                    interaction: {\n                        drag_background_to_pan: true,\n                        scroll_to_zoom: true,\n                        x_linked: true\n                    },\n                    data_layers: [LocusZoom.Layouts.get('data_layer', 'annotation_catalog', { unnamespaced: true })]\n                });\n                /**\n * Plot Layouts\n * @namespace Layouts.plot\n */\n                LocusZoom.Layouts.add('plot', 'standard_association', {\n                    state: {},\n                    width: 800,\n                    height: 450,\n                    responsive_resize: 'both',\n                    min_region_scale: 20000,\n                    max_region_scale: 1000000,\n                    dashboard: LocusZoom.Layouts.get('dashboard', 'standard_plot', { unnamespaced: true }),\n                    panels: [\n                        LocusZoom.Layouts.get('panel', 'association', {\n                            unnamespaced: true,\n                            proportional_height: 0.5\n                        }),\n                        LocusZoom.Layouts.get('panel', 'genes', {\n                            unnamespaced: true,\n                            proportional_height: 0.5\n                        })\n                    ]\n                });\n                LocusZoom.Layouts.add('plot', 'association_catalog', {\n                    state: {},\n                    width: 800,\n                    height: 500,\n                    responsive_resize: 'width_only',\n                    min_region_scale: 20000,\n                    max_region_scale: 1000000,\n                    dashboard: LocusZoom.Layouts.get('dashboard', 'standard_plot', { unnamespaced: true }),\n                    panels: [\n                        LocusZoom.Layouts.get('panel', 'annotation_catalog', { unnamespaced: true }),\n                        LocusZoom.Layouts.get('panel', 'association_catalog', { unnamespaced: true }),\n                        LocusZoom.Layouts.get('panel', 'genes', { unnamespaced: true })\n                    ]\n                });\n                // Shortcut to \"StandardLayout\" for backward compatibility\n                LocusZoom.StandardLayout = LocusZoom.Layouts.get('plot', 'standard_association');\n                LocusZoom.Layouts.add('plot', 'standard_phewas', {\n                    width: 800,\n                    height: 600,\n                    min_width: 800,\n                    min_height: 600,\n                    responsive_resize: 'both',\n                    dashboard: LocusZoom.Layouts.get('dashboard', 'standard_plot', { unnamespaced: true }),\n                    panels: [\n                        LocusZoom.Layouts.get('panel', 'phewas', {\n                            unnamespaced: true,\n                            proportional_height: 0.45\n                        }),\n                        LocusZoom.Layouts.get('panel', 'genome_legend', {\n                            unnamespaced: true,\n                            proportional_height: 0.1\n                        }),\n                        LocusZoom.Layouts.get('panel', 'genes', {\n                            unnamespaced: true,\n                            proportional_height: 0.45,\n                            margin: { bottom: 40 },\n                            axes: {\n                                x: {\n                                    label: 'Chromosome {{chr}} (Mb)',\n                                    label_offset: 32,\n                                    tick_format: 'region',\n                                    extent: 'state'\n                                }\n                            }\n                        })\n                    ],\n                    mouse_guide: false\n                });\n                LocusZoom.Layouts.add('plot', 'interval_association', {\n                    state: {},\n                    width: 800,\n                    height: 550,\n                    responsive_resize: 'both',\n                    min_region_scale: 20000,\n                    max_region_scale: 1000000,\n                    dashboard: LocusZoom.Layouts.get('dashboard', 'standard_plot', { unnamespaced: true }),\n                    panels: [\n                        LocusZoom.Layouts.get('panel', 'association', {\n                            unnamespaced: true,\n                            width: 800,\n                            proportional_height: 225 / 570\n                        }),\n                        LocusZoom.Layouts.get('panel', 'intervals', {\n                            unnamespaced: true,\n                            proportional_height: 120 / 570\n                        }),\n                        LocusZoom.Layouts.get('panel', 'genes', {\n                            unnamespaced: true,\n                            width: 800,\n                            proportional_height: 225 / 570\n                        })\n                    ]\n                });\n                /* global LocusZoom */\n                'use strict';\n                /**\n * A data layer is an abstract class representing a data set and its graphical representation within a panel\n * @public\n * @class\n * @param {Object} layout A JSON-serializable object describing the layout for this layer\n * @param {LocusZoom.DataLayer|LocusZoom.Panel} parent Where this layout is used\n*/\n                LocusZoom.DataLayer = function (layout, parent) {\n                    /** @member {Boolean} */\n                    this.initialized = false;\n                    /** @member {Number} */\n                    this.layout_idx = null;\n                    /** @member {String} */\n                    this.id = null;\n                    /** @member {LocusZoom.Panel} */\n                    this.parent = parent || null;\n                    /**\n     * @member {{group: d3.selection, container: d3.selection, clipRect: d3.selection}}\n     */\n                    this.svg = {};\n                    /** @member {LocusZoom.Plot} */\n                    this.parent_plot = null;\n                    if (typeof parent != 'undefined' && parent instanceof LocusZoom.Panel) {\n                        this.parent_plot = parent.parent;\n                    }\n                    /** @member {Object} */\n                    this.layout = LocusZoom.Layouts.merge(layout || {}, LocusZoom.DataLayer.DefaultLayout);\n                    if (this.layout.id) {\n                        this.id = this.layout.id;\n                    }\n                    // Ensure any axes defined in the layout have an explicit axis number (default: 1)\n                    if (this.layout.x_axis !== {} && typeof this.layout.x_axis.axis !== 'number') {\n                        this.layout.x_axis.axis = 1;\n                    }\n                    if (this.layout.y_axis !== {} && typeof this.layout.y_axis.axis !== 'number') {\n                        this.layout.y_axis.axis = 1;\n                    }\n                    /**\n     * Values in the layout object may change during rendering etc. Retain a copy of the original data layer state\n     * @member {Object}\n     */\n                    this._base_layout = JSON.parse(JSON.stringify(this.layout));\n                    /** @member {Object} */\n                    this.state = {};\n                    /** @member {String} */\n                    this.state_id = null;\n                    this.setDefaultState();\n                    // Initialize parameters for storing data and tool tips\n                    /** @member {Array} */\n                    this.data = [];\n                    if (this.layout.tooltip) {\n                        /** @member {Object} */\n                        this.tooltips = {};\n                    }\n                    // Initialize flags for tracking global statuses\n                    this.global_statuses = {\n                        'highlighted': false,\n                        'selected': false,\n                        'faded': false,\n                        'hidden': false\n                    };\n                    return this;\n                };\n                /**\n * Instruct this datalayer to begin tracking additional fields from data sources (does not guarantee that such a field actually exists)\n *\n * Custom plots can use this to dynamically extend datalayer functionality after the plot is drawn\n *\n *  (since removing core fields may break layer functionality, there is presently no hook for the inverse behavior)\n * @param fieldName\n * @param namespace\n * @param {String|String[]} transformations The name (or array of names) of transformations to apply to this field\n * @returns {String} The raw string added to the fields array\n */\n                LocusZoom.DataLayer.prototype.addField = function (fieldName, namespace, transformations) {\n                    if (!fieldName || !namespace) {\n                        throw new Error('Must specify field name and namespace to use when adding field');\n                    }\n                    var fieldString = namespace + ':' + fieldName;\n                    if (transformations) {\n                        fieldString += '|';\n                        if (typeof transformations === 'string') {\n                            fieldString += transformations;\n                        } else if (Array.isArray(transformations)) {\n                            fieldString += transformations.join('|');\n                        } else {\n                            throw new Error('Must provide transformations as either a string or array of strings');\n                        }\n                    }\n                    var fields = this.layout.fields;\n                    if (fields.indexOf(fieldString) === -1) {\n                        fields.push(fieldString);\n                    }\n                    return fieldString;\n                };\n                /**\n * Define default state that should get tracked during the lifetime of this layer.\n *\n * In some special custom usages, it may be useful to completely reset a panel (eg \"click for\n *   genome region\" links), plotting new data that invalidates any previously tracked state.  This hook makes it\n *   possible to reset without destroying the panel entirely. It is used by `Plot.clearPanelData`.\n */\n                LocusZoom.DataLayer.prototype.setDefaultState = function () {\n                    // Define state parameters specific to this data layer. Within plot state, this will live under a key\n                    //  `panel_name.layer_name`.\n                    if (this.parent) {\n                        this.state = this.parent.state;\n                        this.state_id = this.parent.id + '.' + this.id;\n                        this.state[this.state_id] = this.state[this.state_id] || {};\n                        var layer_state = this.state[this.state_id];\n                        LocusZoom.DataLayer.Statuses.adjectives.forEach(function (status) {\n                            layer_state[status] = layer_state[status] || [];\n                        });\n                        // Also initialize \"internal-only\" state fields\n                        layer_state['has_tooltip'] = layer_state['has_tooltip'] || [];\n                    }\n                };\n                /**\n * A basic description of keys expected in a layout. Not intended to be directly used or modified by an end user.\n * @protected\n * @type {{type: string, fields: Array, x_axis: {}, y_axis: {}}}\n */\n                LocusZoom.DataLayer.DefaultLayout = {\n                    type: '',\n                    fields: [],\n                    x_axis: {},\n                    y_axis: {}\n                };\n                /**\n * Available statuses that individual elements can have. Each status is described by\n *   a verb/antiverb and an adjective. Verbs and antiverbs are used to generate data layer\n *   methods for updating the status on one or more elements. Adjectives are used in class\n *   names and applied or removed from elements to have a visual representation of the status,\n *   as well as used as keys in the state for tracking which elements are in which status(es)\n * @static\n * @type {{verbs: String[], adjectives: String[], menu_antiverbs: String[]}}\n */\n                LocusZoom.DataLayer.Statuses = {\n                    verbs: [\n                        'highlight',\n                        'select',\n                        'fade',\n                        'hide'\n                    ],\n                    adjectives: [\n                        'highlighted',\n                        'selected',\n                        'faded',\n                        'hidden'\n                    ],\n                    menu_antiverbs: [\n                        'unhighlight',\n                        'deselect',\n                        'unfade',\n                        'show'\n                    ]\n                };\n                /**\n * Get the fully qualified identifier for the data layer, prefixed by any parent or container elements\n *\n * @returns {string} A dot-delimited string of the format <plot>.<panel>.<data_layer>\n */\n                LocusZoom.DataLayer.prototype.getBaseId = function () {\n                    return this.parent_plot.id + '.' + this.parent.id + '.' + this.id;\n                };\n                /**\n * Determine the pixel height of data-bound objects represented inside this data layer. (excluding elements such as axes)\n *\n * May be used by operations that resize the data layer to fit available data\n *\n * @public\n * @returns {number}\n */\n                LocusZoom.DataLayer.prototype.getAbsoluteDataHeight = function () {\n                    var dataBCR = this.svg.group.node().getBoundingClientRect();\n                    return dataBCR.height;\n                };\n                /**\n * Whether transitions can be applied to this data layer\n * @returns {boolean}\n */\n                LocusZoom.DataLayer.prototype.canTransition = function () {\n                    if (!this.layout.transition) {\n                        return false;\n                    }\n                    return !(this.parent_plot.panel_boundaries.dragging || this.parent_plot.interaction.panel_id);\n                };\n                /**\n * Fetch the fully qualified ID to be associated with a specific visual element, based on the data to which that\n *   element is bound. In general this element ID will be unique, allowing it to be addressed directly via selectors.\n * @param {String|Object} element\n * @returns {String}\n */\n                LocusZoom.DataLayer.prototype.getElementId = function (element) {\n                    var element_id = 'element';\n                    if (typeof element == 'string') {\n                        element_id = element;\n                    } else if (typeof element == 'object') {\n                        var id_field = this.layout.id_field || 'id';\n                        if (typeof element[id_field] == 'undefined') {\n                            throw new Error('Unable to generate element ID');\n                        }\n                        element_id = element[id_field].toString().replace(/\\W/g, '');\n                    }\n                    return (this.getBaseId() + '-' + element_id).replace(/([:.[\\],])/g, '_');\n                };\n                /**\n * Fetch an ID that may bind a data element to a separate visual node for displaying status\n * Examples of this might be seperate visual nodes to show select/highlight statuses, or\n * even a common/shared node to show status across many elements in a set.\n * Abstract method. It should be overridden by data layers that implement seperate status\n * nodes specifically to the use case of the data layer type.\n * @param {String|Object} element\n * @returns {String|null}\n */\n                LocusZoom.DataLayer.prototype.getElementStatusNodeId = function (element) {\n                    return null;\n                };\n                /**\n * Returns a reference to the underlying data associated with a single visual element in the data layer, as\n *   referenced by the unique identifier for the element\n\n * @param {String} id The unique identifier for the element, as defined by `getElementId`\n * @returns {Object|null} The data bound to that element\n */\n                LocusZoom.DataLayer.prototype.getElementById = function (id) {\n                    var selector = d3.select('#' + id.replace(/([:.[\\],])/g, '\\\\$1'));\n                    // escape special characters\n                    if (!selector.empty() && selector.data() && selector.data().length) {\n                        return selector.data()[0];\n                    } else {\n                        return null;\n                    }\n                };\n                /**\n * Basic method to apply arbitrary methods and properties to data elements.\n *   This is called on all data immediately after being fetched.\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.DataLayer.prototype.applyDataMethods = function () {\n                    var field_to_match = this.layout.match && this.layout.match.receive;\n                    var broadcast_value = this.parent_plot.state.lz_match_value;\n                    this.data.forEach(function (d, i) {\n                        // Basic toHTML() method - return the stringified value in the id_field, if defined.\n                        // When this layer receives data, mark whether points match (via a synthetic boolean field)\n                        //   Any field-based layout directives (color, size, shape) can then be used to control display\n                        if (field_to_match && broadcast_value !== null && broadcast_value !== undefined) {\n                            d.lz_highlight_match = d[field_to_match] === broadcast_value;\n                        }\n                        this.data[i].toHTML = function () {\n                            var id_field = this.layout.id_field || 'id';\n                            var html = '';\n                            if (this.data[i][id_field]) {\n                                html = this.data[i][id_field].toString();\n                            }\n                            return html;\n                        }.bind(this);\n                        // getDataLayer() method - return a reference to the data layer\n                        this.data[i].getDataLayer = function () {\n                            return this;\n                        }.bind(this);\n                        // deselect() method - shortcut method to deselect the element\n                        this.data[i].deselect = function () {\n                            var data_layer = this.getDataLayer();\n                            data_layer.unselectElement(this);\n                        };\n                    }.bind(this));\n                    this.applyCustomDataMethods();\n                    return this;\n                };\n                /**\n * Hook that allows custom datalayers to apply additional methods and properties to data elements as needed\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.DataLayer.prototype.applyCustomDataMethods = function () {\n                    return this;\n                };\n                /**\n * Initialize a data layer\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.DataLayer.prototype.initialize = function () {\n                    // Append a container group element to house the main data layer group element and the clip path\n                    this.svg.container = this.parent.svg.group.append('g').attr('class', 'lz-data_layer-container').attr('id', this.getBaseId() + '.data_layer_container');\n                    // Append clip path to the container element\n                    this.svg.clipRect = this.svg.container.append('clipPath').attr('id', this.getBaseId() + '.clip').append('rect');\n                    // Append svg group for rendering all data layer elements, clipped by the clip path\n                    this.svg.group = this.svg.container.append('g').attr('id', this.getBaseId() + '.data_layer').attr('clip-path', 'url(#' + this.getBaseId() + '.clip)');\n                    return this;\n                };\n                /**\n * Move a data layer up relative to others by z-index\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.DataLayer.prototype.moveUp = function () {\n                    if (this.parent.data_layer_ids_by_z_index[this.layout.z_index + 1]) {\n                        this.parent.data_layer_ids_by_z_index[this.layout.z_index] = this.parent.data_layer_ids_by_z_index[this.layout.z_index + 1];\n                        this.parent.data_layer_ids_by_z_index[this.layout.z_index + 1] = this.id;\n                        this.parent.resortDataLayers();\n                    }\n                    return this;\n                };\n                /**\n * Move a data layer down relative to others by z-index\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.DataLayer.prototype.moveDown = function () {\n                    if (this.parent.data_layer_ids_by_z_index[this.layout.z_index - 1]) {\n                        this.parent.data_layer_ids_by_z_index[this.layout.z_index] = this.parent.data_layer_ids_by_z_index[this.layout.z_index - 1];\n                        this.parent.data_layer_ids_by_z_index[this.layout.z_index - 1] = this.id;\n                        this.parent.resortDataLayers();\n                    }\n                    return this;\n                };\n                /**\n * Apply scaling functions to an element or parameter as needed, based on its layout and the element's data\n * If the layout parameter is already a primitive type, simply return the value as given\n * @param {Array|Number|String|Object} layout\n * @param {*} data The value to be used with the filter\n * @returns {*} The transformed value\n */\n                LocusZoom.DataLayer.prototype.resolveScalableParameter = function (layout, data) {\n                    var ret = null;\n                    if (Array.isArray(layout)) {\n                        var idx = 0;\n                        while (ret === null && idx < layout.length) {\n                            ret = this.resolveScalableParameter(layout[idx], data);\n                            idx++;\n                        }\n                    } else {\n                        switch (typeof layout) {\n                        case 'number':\n                        case 'string':\n                            ret = layout;\n                            break;\n                        case 'object':\n                            if (layout.scale_function) {\n                                if (layout.field) {\n                                    var f = new LocusZoom.Data.Field(layout.field);\n                                    ret = LocusZoom.ScaleFunctions.get(layout.scale_function, layout.parameters || {}, f.resolve(data));\n                                } else {\n                                    ret = LocusZoom.ScaleFunctions.get(layout.scale_function, layout.parameters || {}, data);\n                                }\n                            }\n                            break;\n                        }\n                    }\n                    return ret;\n                };\n                /**\n * Implementation hook for fetching the min and max values of available data. Used to determine axis range, if no other\n *   explicit axis settings override. Useful for data layers where the data extent depends on more than one field.\n *   (eg confidence intervals in a forest plot)\n * @param data\n * @param axis_config The configuration object for the specified axis.\n * @returns {Array} [min, max] without any padding applied\n * @private\n */\n                LocusZoom.DataLayer.prototype._getDataExtent = function (data, axis_config) {\n                    data = data || this.data;\n                    // By default this depends only on a single field.\n                    return d3.extent(data, function (d) {\n                        var f = new LocusZoom.Data.Field(axis_config.field);\n                        return +f.resolve(d);\n                    });\n                };\n                /**\n * Generate dimension extent function based on layout parameters\n * @param {('x'|'y')} dimension\n */\n                LocusZoom.DataLayer.prototype.getAxisExtent = function (dimension) {\n                    if ([\n                            'x',\n                            'y'\n                        ].indexOf(dimension) === -1) {\n                        throw new Error('Invalid dimension identifier passed to LocusZoom.DataLayer.getAxisExtent()');\n                    }\n                    var axis_name = dimension + '_axis';\n                    var axis_layout = this.layout[axis_name];\n                    // If a floor AND a ceiling are explicitly defined then just return that extent and be done\n                    if (!isNaN(axis_layout.floor) && !isNaN(axis_layout.ceiling)) {\n                        return [\n                            +axis_layout.floor,\n                            +axis_layout.ceiling\n                        ];\n                    }\n                    // If a field is defined for the axis and the data layer has data then generate the extent from the data set\n                    var data_extent = [];\n                    if (axis_layout.field && this.data) {\n                        if (!this.data.length) {\n                            // If data has been fetched (but no points in region), enforce the min_extent (with no buffers,\n                            //  because we don't need padding around an empty screen)\n                            data_extent = axis_layout.min_extent || [];\n                            return data_extent;\n                        } else {\n                            data_extent = this._getDataExtent(this.data, axis_layout);\n                            // Apply upper/lower buffers, if applicable\n                            var original_extent_span = data_extent[1] - data_extent[0];\n                            if (!isNaN(axis_layout.lower_buffer)) {\n                                data_extent[0] -= original_extent_span * axis_layout.lower_buffer;\n                            }\n                            if (!isNaN(axis_layout.upper_buffer)) {\n                                data_extent[1] += original_extent_span * axis_layout.upper_buffer;\n                            }\n                            if (typeof axis_layout.min_extent == 'object') {\n                                // The data should span at least the range specified by min_extent, an array with [low, high]\n                                var range_min = axis_layout.min_extent[0];\n                                var range_max = axis_layout.min_extent[1];\n                                if (!isNaN(range_min) && !isNaN(range_max)) {\n                                    data_extent[0] = Math.min(data_extent[0], range_min);\n                                }\n                                if (!isNaN(range_max)) {\n                                    data_extent[1] = Math.max(data_extent[1], range_max);\n                                }\n                            }\n                            // If specified, floor and ceiling will override the actual data range\n                            return [\n                                isNaN(axis_layout.floor) ? data_extent[0] : axis_layout.floor,\n                                isNaN(axis_layout.ceiling) ? data_extent[1] : axis_layout.ceiling\n                            ];\n                        }\n                    }\n                    // If this is for the x axis and no extent could be generated yet but state has a defined start and end\n                    // then default to using the state-defined region as the extent\n                    if (dimension === 'x' && !isNaN(this.state.start) && !isNaN(this.state.end)) {\n                        return [\n                            this.state.start,\n                            this.state.end\n                        ];\n                    }\n                    // No conditions met for generating a valid extent, return an empty array\n                    return [];\n                };\n                /**\n * Allow this data layer to tell the panel what axis ticks it thinks it will require. The panel may choose whether\n *   to use some, all, or none of these when rendering, either alone or in conjunction with other data layers.\n *\n *   This method is a stub and should be overridden in data layers that need to specify custom behavior.\n *\n * @param {('x'|'y1'|'y2')} dimension\n * @param {Object} [config] Additional parameters for the panel to specify how it wants ticks to be drawn. The names\n *   and meanings of these parameters may vary between different data layers.\n * @returns {Object[]}\n *   An array of objects: each object must have an 'x' attribute to position the tick.\n *   Other supported object keys:\n *     * text: string to render for a given tick\n *     * style: d3-compatible CSS style object\n *     * transform: SVG transform attribute string\n *     * color: string or LocusZoom scalable parameter object\n */\n                LocusZoom.DataLayer.prototype.getTicks = function (dimension, config) {\n                    if ([\n                            'x',\n                            'y1',\n                            'y2'\n                        ].indexOf(dimension) === -1) {\n                        throw new Error('Invalid dimension identifier at layer level' + dimension);\n                    }\n                    return [];\n                };\n                /**\n * Generate a tool tip for a given element\n * @param {String|Object} data Data for the element associated with the tooltip\n */\n                LocusZoom.DataLayer.prototype.createTooltip = function (data) {\n                    if (typeof this.layout.tooltip != 'object') {\n                        throw new Error('DataLayer [' + this.id + '] layout does not define a tooltip');\n                    }\n                    var id = this.getElementId(data);\n                    if (this.tooltips[id]) {\n                        this.positionTooltip(id);\n                        return;\n                    }\n                    this.tooltips[id] = {\n                        data: data,\n                        arrow: null,\n                        selector: d3.select(this.parent_plot.svg.node().parentNode).append('div').attr('class', 'lz-data_layer-tooltip').attr('id', id + '-tooltip')\n                    };\n                    this.state[this.state_id]['has_tooltip'].push(id);\n                    this.updateTooltip(data);\n                    return this;\n                };\n                /**\n * Update a tool tip (generate its inner HTML)\n * @param {String|Object} d The element associated with the tooltip\n * @param {String} [id] An identifier to the tooltip\n */\n                LocusZoom.DataLayer.prototype.updateTooltip = function (d, id) {\n                    if (typeof id == 'undefined') {\n                        id = this.getElementId(d);\n                    }\n                    // Empty the tooltip of all HTML (including its arrow!)\n                    this.tooltips[id].selector.html('');\n                    this.tooltips[id].arrow = null;\n                    // Set the new HTML\n                    if (this.layout.tooltip.html) {\n                        this.tooltips[id].selector.html(LocusZoom.parseFields(d, this.layout.tooltip.html));\n                    }\n                    // If the layout allows tool tips on this data layer to be closable then add the close button\n                    // and add padding to the tooltip to accommodate it\n                    if (this.layout.tooltip.closable) {\n                        this.tooltips[id].selector.insert('button', ':first-child').attr('class', 'lz-tooltip-close-button').attr('title', 'Close').text('\\xD7').on('click', function () {\n                            this.destroyTooltip(id);\n                        }.bind(this));\n                    }\n                    // Apply data directly to the tool tip for easier retrieval by custom UI elements inside the tool tip\n                    this.tooltips[id].selector.data([d]);\n                    // Reposition and draw a new arrow\n                    this.positionTooltip(id);\n                    return this;\n                };\n                /**\n * Destroy tool tip - remove the tool tip element from the DOM and delete the tool tip's record on the data layer\n * @param {String|Object} element_or_id The element (or id) associated with the tooltip\n * @param {boolean} [temporary=false] Whether this is temporary (not to be tracked in state). Differentiates\n *  \"recreate tooltips on re-render\" (which is temporary) from \"user has closed this tooltip\" (permanent)\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.DataLayer.prototype.destroyTooltip = function (element_or_id, temporary) {\n                    var id;\n                    if (typeof element_or_id == 'string') {\n                        id = element_or_id;\n                    } else {\n                        id = this.getElementId(element_or_id);\n                    }\n                    if (this.tooltips[id]) {\n                        if (typeof this.tooltips[id].selector == 'object') {\n                            this.tooltips[id].selector.remove();\n                        }\n                        delete this.tooltips[id];\n                    }\n                    // When a tooltip is removed, also remove the reference from the state\n                    if (!temporary) {\n                        var state = this.state[this.state_id]['has_tooltip'];\n                        var label_mark_position = state.indexOf(id);\n                        state.splice(label_mark_position, 1);\n                    }\n                    return this;\n                };\n                /**\n * Loop through and destroy all tool tips on this data layer\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.DataLayer.prototype.destroyAllTooltips = function () {\n                    for (var id in this.tooltips) {\n                        this.destroyTooltip(id, true);\n                    }\n                    return this;\n                };\n                //\n                /**\n * Position tool tip - nave function to place a tool tip to the lower right of the current mouse element\n *   Most data layers reimplement this method to position tool tips specifically for the data they display\n * @param {String} id The identifier of the tooltip to position\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.DataLayer.prototype.positionTooltip = function (id) {\n                    if (typeof id != 'string') {\n                        throw new Error('Unable to position tooltip: id is not a string');\n                    }\n                    // Position the div itself\n                    this.tooltips[id].selector.style('left', d3.event.pageX + 'px').style('top', d3.event.pageY + 'px');\n                    // Create / update position on arrow connecting tooltip to data\n                    if (!this.tooltips[id].arrow) {\n                        this.tooltips[id].arrow = this.tooltips[id].selector.append('div').style('position', 'absolute').attr('class', 'lz-data_layer-tooltip-arrow_top_left');\n                    }\n                    this.tooltips[id].arrow.style('left', '-1px').style('top', '-1px');\n                    return this;\n                };\n                /**\n * Loop through and position all tool tips on this data layer\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.DataLayer.prototype.positionAllTooltips = function () {\n                    for (var id in this.tooltips) {\n                        this.positionTooltip(id);\n                    }\n                    return this;\n                };\n                /**\n * Show or hide a tool tip by ID depending on directives in the layout and state values relative to the ID\n * @param {String|Object} element The element associated with the tooltip\n * @param {boolean} first_time Because panels can re-render, the rules for showing a tooltip\n *  depend on whether this is the first time a status change affecting display has been applied.\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.DataLayer.prototype.showOrHideTooltip = function (element, first_time) {\n                    if (typeof this.layout.tooltip != 'object') {\n                        return;\n                    }\n                    var id = this.getElementId(element);\n                    /**\n     * Apply rules and decide whether to show or hide the tooltip\n     * @param {Object} statuses All statuses that apply to an element\n     * @param {String[]|object} directive A layout directive object\n     * @param operator\n     * @returns {null|bool}\n     */\n                    var resolveStatus = function (statuses, directive, operator) {\n                        var status = null;\n                        if (typeof statuses != 'object' || statuses === null) {\n                            return null;\n                        }\n                        if (Array.isArray(directive)) {\n                            // This happens when the function is called on the inner part of the directive\n                            operator = operator || 'and';\n                            if (directive.length === 1) {\n                                status = statuses[directive[0]];\n                            } else {\n                                status = directive.reduce(function (previousValue, currentValue) {\n                                    if (operator === 'and') {\n                                        return statuses[previousValue] && statuses[currentValue];\n                                    } else if (operator === 'or') {\n                                        return statuses[previousValue] || statuses[currentValue];\n                                    }\n                                    return null;\n                                });\n                            }\n                        } else if (typeof directive == 'object') {\n                            var sub_status;\n                            for (var sub_operator in directive) {\n                                sub_status = resolveStatus(statuses, directive[sub_operator], sub_operator);\n                                if (status === null) {\n                                    status = sub_status;\n                                } else if (operator === 'and') {\n                                    status = status && sub_status;\n                                } else if (operator === 'or') {\n                                    status = status || sub_status;\n                                }\n                            }\n                        } else {\n                            return false;\n                        }\n                        return status;\n                    };\n                    var show_directive = {};\n                    if (typeof this.layout.tooltip.show == 'string') {\n                        show_directive = { and: [this.layout.tooltip.show] };\n                    } else if (typeof this.layout.tooltip.show == 'object') {\n                        show_directive = this.layout.tooltip.show;\n                    }\n                    var hide_directive = {};\n                    if (typeof this.layout.tooltip.hide == 'string') {\n                        hide_directive = { and: [this.layout.tooltip.hide] };\n                    } else if (typeof this.layout.tooltip.hide == 'object') {\n                        hide_directive = this.layout.tooltip.hide;\n                    }\n                    // Find all the statuses that apply to just this single element\n                    var layer_state = this.state[this.state_id];\n                    var statuses = {};\n                    // {status_name: bool}\n                    LocusZoom.DataLayer.Statuses.adjectives.forEach(function (status) {\n                        var antistatus = 'un' + status;\n                        statuses[status] = layer_state[status].indexOf(id) !== -1;\n                        statuses[antistatus] = !statuses[status];\n                    });\n                    // Decide whether to show/hide the tooltip based solely on the underlying element\n                    var show_resolved = resolveStatus(statuses, show_directive);\n                    var hide_resolved = resolveStatus(statuses, hide_directive);\n                    // Most of the tooltip display logic depends on behavior layouts: was point (un)selected, (un)highlighted, etc.\n                    // But sometimes, a point is selected, and the user then closes the tooltip. If the panel is re-rendered for\n                    //  some outside reason (like state change), we must track this in the create/destroy events as tooltip state.\n                    var has_tooltip = layer_state['has_tooltip'].indexOf(id) !== -1;\n                    var tooltip_was_closed = first_time ? false : !has_tooltip;\n                    if (show_resolved && !tooltip_was_closed && !hide_resolved) {\n                        this.createTooltip(element);\n                    } else {\n                        this.destroyTooltip(element);\n                    }\n                    return this;\n                };\n                /**\n * Find the elements (or indices) that match any of a set of provided filters\n * @protected\n * @param {Array[]} filters A list of filter entries: [field, value] (for equivalence testing) or\n *   [field, operator, value] for other operators\n * @param {('indexes'|'elements')} [return_type='indexes'] Specify whether to return either the indices of the matching\n *   elements, or references to the elements themselves\n * @returns {Array}\n */\n                LocusZoom.DataLayer.prototype.filter = function (filters, return_type) {\n                    if (typeof return_type == 'undefined' || [\n                            'indexes',\n                            'elements'\n                        ].indexOf(return_type) === -1) {\n                        return_type = 'indexes';\n                    }\n                    if (!Array.isArray(filters)) {\n                        return [];\n                    }\n                    var test = function (element, filter) {\n                        var operators = {\n                            '=': function (a, b) {\n                                return a === b;\n                            },\n                            // eslint-disable-next-line eqeqeq\n                            '!=': function (a, b) {\n                                return a != b;\n                            },\n                            // For absence of a value, deliberately allow weak comparisons (eg undefined/null)\n                            '<': function (a, b) {\n                                return a < b;\n                            },\n                            '<=': function (a, b) {\n                                return a <= b;\n                            },\n                            '>': function (a, b) {\n                                return a > b;\n                            },\n                            '>=': function (a, b) {\n                                return a >= b;\n                            },\n                            '%': function (a, b) {\n                                return a % b;\n                            }\n                        };\n                        if (!Array.isArray(filter)) {\n                            return false;\n                        }\n                        if (filter.length === 2) {\n                            return element[filter[0]] === filter[1];\n                        } else if (filter.length === 3 && operators[filter[1]]) {\n                            return operators[filter[1]](element[filter[0]], filter[2]);\n                        } else {\n                            return false;\n                        }\n                    };\n                    var matches = [];\n                    this.data.forEach(function (element, idx) {\n                        var match = true;\n                        filters.forEach(function (filter) {\n                            if (!test(element, filter)) {\n                                match = false;\n                            }\n                        });\n                        if (match) {\n                            matches.push(return_type === 'indexes' ? idx : element);\n                        }\n                    });\n                    return matches;\n                };\n                /**\n * @param filters\n * @returns {Array}\n */\n                LocusZoom.DataLayer.prototype.filterIndexes = function (filters) {\n                    return this.filter(filters, 'indexes');\n                };\n                /**\n * @param filters\n * @returns {Array}\n */\n                LocusZoom.DataLayer.prototype.filterElements = function (filters) {\n                    return this.filter(filters, 'elements');\n                };\n                LocusZoom.DataLayer.Statuses.verbs.forEach(function (verb, idx) {\n                    var adjective = LocusZoom.DataLayer.Statuses.adjectives[idx];\n                    var antiverb = 'un' + verb;\n                    // Set/unset a single element's status\n                    // TODO: Improve documentation for dynamically generated methods/properties\n                    LocusZoom.DataLayer.prototype[verb + 'Element'] = function (element, exclusive) {\n                        if (typeof exclusive == 'undefined') {\n                            exclusive = false;\n                        } else {\n                            exclusive = !!exclusive;\n                        }\n                        this.setElementStatus(adjective, element, true, exclusive);\n                        return this;\n                    };\n                    LocusZoom.DataLayer.prototype[antiverb + 'Element'] = function (element, exclusive) {\n                        if (typeof exclusive == 'undefined') {\n                            exclusive = false;\n                        } else {\n                            exclusive = !!exclusive;\n                        }\n                        this.setElementStatus(adjective, element, false, exclusive);\n                        return this;\n                    };\n                    // Set/unset status for arbitrarily many elements given a set of filters\n                    LocusZoom.DataLayer.prototype[verb + 'ElementsByFilters'] = function (filters, exclusive) {\n                        if (typeof exclusive == 'undefined') {\n                            exclusive = false;\n                        } else {\n                            exclusive = !!exclusive;\n                        }\n                        return this.setElementStatusByFilters(adjective, true, filters, exclusive);\n                    };\n                    LocusZoom.DataLayer.prototype[antiverb + 'ElementsByFilters'] = function (filters, exclusive) {\n                        if (typeof exclusive == 'undefined') {\n                            exclusive = false;\n                        } else {\n                            exclusive = !!exclusive;\n                        }\n                        return this.setElementStatusByFilters(adjective, false, filters, exclusive);\n                    };\n                    // Set/unset status for all elements\n                    LocusZoom.DataLayer.prototype[verb + 'AllElements'] = function () {\n                        this.setAllElementStatus(adjective, true);\n                        return this;\n                    };\n                    LocusZoom.DataLayer.prototype[antiverb + 'AllElements'] = function () {\n                        this.setAllElementStatus(adjective, false);\n                        return this;\n                    };\n                });\n                /**\n * Toggle a status (e.g. highlighted, selected, identified) on an element\n * @param {String} status The name of a recognized status to be added/removed on an appropriate element\n * @param {String|Object} element The data bound to the element of interest\n * @param {Boolean} active True to add the status (and associated CSS styles); false to remove it\n * @param {Boolean} exclusive Whether to only allow a state for a single element at a time\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.DataLayer.prototype.setElementStatus = function (status, element, active, exclusive) {\n                    if (status === 'has_tooltip') {\n                        // This is a special adjective that exists solely to track tooltip state. It has no CSS and never gets set\n                        //  directly. It is invisible to the official enums.\n                        return this;\n                    }\n                    // Sanity checks\n                    if (typeof status == 'undefined' || LocusZoom.DataLayer.Statuses.adjectives.indexOf(status) === -1) {\n                        throw new Error('Invalid status passed to DataLayer.setElementStatus()');\n                    }\n                    if (typeof element == 'undefined') {\n                        throw new Error('Invalid element passed to DataLayer.setElementStatus()');\n                    }\n                    if (typeof active == 'undefined') {\n                        active = true;\n                    }\n                    // Get an ID for the element or return having changed nothing\n                    try {\n                        var element_id = this.getElementId(element);\n                    } catch (get_element_id_error) {\n                        return this;\n                    }\n                    // Enforce exclusivity (force all elements to have the opposite of toggle first)\n                    if (exclusive) {\n                        this.setAllElementStatus(status, !active);\n                    }\n                    // Set/unset the proper status class on the appropriate DOM element(s)\n                    d3.select('#' + element_id).classed('lz-data_layer-' + this.layout.type + '-' + status, active);\n                    var element_status_node_id = this.getElementStatusNodeId(element);\n                    if (element_status_node_id !== null) {\n                        d3.select('#' + element_status_node_id).classed('lz-data_layer-' + this.layout.type + '-statusnode-' + status, active);\n                    }\n                    // Track element ID in the proper status state array\n                    var element_status_idx = this.state[this.state_id][status].indexOf(element_id);\n                    var added_status = element_status_idx === -1;\n                    // On a re-render, existing statuses will be reapplied.\n                    if (active && added_status) {\n                        this.state[this.state_id][status].push(element_id);\n                    }\n                    if (!active && !added_status) {\n                        this.state[this.state_id][status].splice(element_status_idx, 1);\n                    }\n                    // Trigger tool tip show/hide logic\n                    this.showOrHideTooltip(element, added_status);\n                    // Trigger layout changed event hook\n                    if (added_status) {\n                        this.parent.emit('layout_changed', true);\n                    }\n                    var is_selected = status === 'selected';\n                    if (is_selected && (added_status || !active)) {\n                        // Notify parents that an element has changed selection status (either active, or inactive)\n                        this.parent.emit('element_selection', {\n                            element: element,\n                            active: active\n                        }, true);\n                    }\n                    var value_to_broadcast = this.layout.match && this.layout.match.send;\n                    if (is_selected && value_to_broadcast && (added_status || !active)) {\n                        this.parent.emit('match_requested', {\n                            value: element[value_to_broadcast],\n                            active: active\n                        }, true);\n                    }\n                    return this;\n                };\n                /**\n * Toggle a status on elements in the data layer based on a set of filters\n * @param {String} status\n * @param {Boolean} toggle\n * @param {Array} filters\n * @param {Boolean} exclusive\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.DataLayer.prototype.setElementStatusByFilters = function (status, toggle, filters, exclusive) {\n                    // Sanity check\n                    if (typeof status == 'undefined' || LocusZoom.DataLayer.Statuses.adjectives.indexOf(status) === -1) {\n                        throw new Error('Invalid status passed to DataLayer.setElementStatusByFilters()');\n                    }\n                    if (typeof this.state[this.state_id][status] == 'undefined') {\n                        return this;\n                    }\n                    if (typeof toggle == 'undefined') {\n                        toggle = true;\n                    } else {\n                        toggle = !!toggle;\n                    }\n                    if (typeof exclusive == 'undefined') {\n                        exclusive = false;\n                    } else {\n                        exclusive = !!exclusive;\n                    }\n                    if (!Array.isArray(filters)) {\n                        filters = [];\n                    }\n                    // Enforce exclusivity (force all elements to have the opposite of toggle first)\n                    if (exclusive) {\n                        this.setAllElementStatus(status, !toggle);\n                    }\n                    // Apply statuses\n                    this.filterElements(filters).forEach(function (element) {\n                        this.setElementStatus(status, element, toggle);\n                    }.bind(this));\n                    return this;\n                };\n                /**\n * Toggle a status on all elements in the data layer\n * @param {String} status\n * @param {Boolean} toggle\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.DataLayer.prototype.setAllElementStatus = function (status, toggle) {\n                    // Sanity check\n                    if (typeof status == 'undefined' || LocusZoom.DataLayer.Statuses.adjectives.indexOf(status) === -1) {\n                        throw new Error('Invalid status passed to DataLayer.setAllElementStatus()');\n                    }\n                    if (typeof this.state[this.state_id][status] == 'undefined') {\n                        return this;\n                    }\n                    if (typeof toggle == 'undefined') {\n                        toggle = true;\n                    }\n                    // Apply statuses\n                    if (toggle) {\n                        this.data.forEach(function (element) {\n                            this.setElementStatus(status, element, true);\n                        }.bind(this));\n                    } else {\n                        var status_ids = this.state[this.state_id][status].slice();\n                        status_ids.forEach(function (id) {\n                            var element = this.getElementById(id);\n                            if (typeof element == 'object' && element !== null) {\n                                this.setElementStatus(status, element, false);\n                            }\n                        }.bind(this));\n                        this.state[this.state_id][status] = [];\n                    }\n                    // Update global status flag\n                    this.global_statuses[status] = toggle;\n                    return this;\n                };\n                /**\n * Apply all layout-defined behaviors (DOM event handlers) to a selection of elements\n * @param {d3.selection} selection\n */\n                LocusZoom.DataLayer.prototype.applyBehaviors = function (selection) {\n                    if (typeof this.layout.behaviors != 'object') {\n                        return;\n                    }\n                    Object.keys(this.layout.behaviors).forEach(function (directive) {\n                        var event_match = /(click|mouseover|mouseout)/.exec(directive);\n                        if (!event_match) {\n                            return;\n                        }\n                        selection.on(event_match[0] + '.' + directive, this.executeBehaviors(directive, this.layout.behaviors[directive]));\n                    }.bind(this));\n                };\n                /**\n * Generate a function that executes an arbitrary list of behaviors on an element during an event\n * @param {String} directive The name of the event, as described in layout.behaviors for this datalayer\n * @param {Object} behaviors An object describing the behavior to attach to this single element\n * @param {string} behaviors.action The name of the action that would trigger this behavior (eg click, mouseover, etc)\n * @param {string} behaviors.status What status to apply to the element when this behavior is triggered (highlighted,\n *  selected, etc)\n * @param {string} [behaviors.exclusive] Whether triggering the event for this element should unset the relevant status\n *   for all other elements. Useful for, eg, click events that exclusively highlight one thing.\n * @returns {function(this:LocusZoom.DataLayer)} Return a function that handles the event in context with the behavior\n *   and the element- can be attached as an event listener\n */\n                LocusZoom.DataLayer.prototype.executeBehaviors = function (directive, behaviors) {\n                    // Determine the required state of control and shift keys during the event\n                    var requiredKeyStates = {\n                        'ctrl': directive.indexOf('ctrl') !== -1,\n                        'shift': directive.indexOf('shift') !== -1\n                    };\n                    return function (element) {\n                        // Do nothing if the required control and shift key presses (or lack thereof) doesn't match the event\n                        if (requiredKeyStates.ctrl !== !!d3.event.ctrlKey || requiredKeyStates.shift !== !!d3.event.shiftKey) {\n                            return;\n                        }\n                        // Loop through behaviors making each one go in succession\n                        behaviors.forEach(function (behavior) {\n                            // Route first by the action, if defined\n                            if (typeof behavior != 'object' || behavior === null) {\n                                return;\n                            }\n                            switch (behavior.action) {\n                            // Set a status (set to true regardless of current status, optionally with exclusivity)\n                            case 'set':\n                                this.setElementStatus(behavior.status, element, true, behavior.exclusive);\n                                break;\n                            // Unset a status (set to false regardless of current status, optionally with exclusivity)\n                            case 'unset':\n                                this.setElementStatus(behavior.status, element, false, behavior.exclusive);\n                                break;\n                            // Toggle a status\n                            case 'toggle':\n                                var current_status_boolean = this.state[this.state_id][behavior.status].indexOf(this.getElementId(element)) !== -1;\n                                var exclusive = behavior.exclusive && !current_status_boolean;\n                                this.setElementStatus(behavior.status, element, !current_status_boolean, exclusive);\n                                break;\n                            // Link to a dynamic URL\n                            case 'link':\n                                if (typeof behavior.href == 'string') {\n                                    var url = LocusZoom.parseFields(element, behavior.href);\n                                    if (typeof behavior.target == 'string') {\n                                        window.open(url, behavior.target);\n                                    } else {\n                                        window.location.href = url;\n                                    }\n                                }\n                                break;\n                            // Action not defined, just return\n                            default:\n                                break;\n                            }\n                            return;\n                        }.bind(this));\n                    }.bind(this);\n                };\n                /**\n * Get an object with the x and y coordinates of the panel's origin in terms of the entire page\n *   Necessary for positioning any HTML elements over the panel\n * @returns {{x: Number, y: Number}}\n */\n                LocusZoom.DataLayer.prototype.getPageOrigin = function () {\n                    var panel_origin = this.parent.getPageOrigin();\n                    return {\n                        x: panel_origin.x + this.parent.layout.margin.left,\n                        y: panel_origin.y + this.parent.layout.margin.top\n                    };\n                };\n                /**\n * Get a data layer's current underlying data in a standard format (e.g. JSON or CSV)\n * @param {('csv'|'tsv'|'json')} format How to export the data\n * @returns {*}\n */\n                LocusZoom.DataLayer.prototype.exportData = function (format) {\n                    var default_format = 'json';\n                    format = format || default_format;\n                    format = typeof format == 'string' ? format.toLowerCase() : default_format;\n                    if ([\n                            'json',\n                            'csv',\n                            'tsv'\n                        ].indexOf(format) === -1) {\n                        format = default_format;\n                    }\n                    var ret;\n                    switch (format) {\n                    case 'json':\n                        try {\n                            ret = JSON.stringify(this.data);\n                        } catch (e) {\n                            ret = null;\n                            console.warn('Unable to export JSON data from data layer: ' + this.getBaseId());\n                            console.error(e);\n                        }\n                        break;\n                    case 'tsv':\n                    case 'csv':\n                        try {\n                            var jsonified = JSON.parse(JSON.stringify(this.data));\n                            if (typeof jsonified != 'object') {\n                                ret = jsonified.toString();\n                            } else if (!Array.isArray(jsonified)) {\n                                ret = 'Object';\n                            } else {\n                                var delimiter = format === 'tsv' ? '\\t' : ',';\n                                var header = this.layout.fields.map(function (header) {\n                                    return JSON.stringify(header);\n                                }).join(delimiter) + '\\n';\n                                ret = header + jsonified.map(function (record) {\n                                    return this.layout.fields.map(function (field) {\n                                        if (typeof record[field] == 'undefined') {\n                                            return JSON.stringify(null);\n                                        } else if (typeof record[field] == 'object' && record[field] !== null) {\n                                            return Array.isArray(record[field]) ? '\"[Array(' + record[field].length + ')]\"' : '\"[Object]\"';\n                                        } else {\n                                            return JSON.stringify(record[field]);\n                                        }\n                                    }).join(delimiter);\n                                }.bind(this)).join('\\n');\n                            }\n                        } catch (e) {\n                            ret = null;\n                            console.error('Unable to export CSV data from data layer: ' + this.getBaseId() + ';', e);\n                        }\n                        break;\n                    }\n                    return ret;\n                };\n                /**\n * Position the datalayer and all tooltips\n * @returns {LocusZoom.DataLayer}\n */\n                LocusZoom.DataLayer.prototype.draw = function () {\n                    this.svg.container.attr('transform', 'translate(' + this.parent.layout.cliparea.origin.x + ',' + this.parent.layout.cliparea.origin.y + ')');\n                    this.svg.clipRect.attr('width', this.parent.layout.cliparea.width).attr('height', this.parent.layout.cliparea.height);\n                    this.positionAllTooltips();\n                    return this;\n                };\n                /**\n * Re-Map a data layer to reflect changes in the state of a plot (such as viewing region/ chromosome range)\n * @return {Promise}\n */\n                LocusZoom.DataLayer.prototype.reMap = function () {\n                    this.destroyAllTooltips();\n                    // hack - only non-visible tooltips should be destroyed\n                    // and then recreated if returning to visibility\n                    // Fetch new data. Datalayers are only given access to the final consolidated data from the chain (not headers or raw payloads)\n                    var promise = this.parent_plot.lzd.getData(this.state, this.layout.fields);\n                    promise.then(function (new_data) {\n                        this.data = new_data.body;\n                        this.applyDataMethods();\n                        this.initialized = true;\n                    }.bind(this));\n                    return promise;\n                };\n                /**\n * The central registry of known data layer definitions (which may be stored in separate files due to length)\n * @namespace\n */\n                LocusZoom.DataLayers = function () {\n                    var obj = {};\n                    var datalayers = {};\n                    /**\n     * @name LocusZoom.DataLayers.get\n     * @param {String} name The name of the datalayer\n     * @param {Object} layout The configuration object for this data layer\n     * @param {LocusZoom.DataLayer|LocusZoom.Panel} parent Where this layout is used\n     * @returns {LocusZoom.DataLayer}\n     */\n                    obj.get = function (name, layout, parent) {\n                        if (!name) {\n                            return null;\n                        } else if (datalayers[name]) {\n                            if (typeof layout != 'object') {\n                                throw new Error('invalid layout argument for data layer [' + name + ']');\n                            } else {\n                                return new datalayers[name](layout, parent);\n                            }\n                        } else {\n                            throw new Error('data layer [' + name + '] not found');\n                        }\n                    };\n                    /**\n     * @name LocusZoom.DataLayers.set\n     * @protected\n     * @param {String} name\n     * @param {Function} datalayer Constructor for the datalayer\n     */\n                    obj.set = function (name, datalayer) {\n                        if (datalayer) {\n                            if (typeof datalayer != 'function') {\n                                throw new Error('unable to set data layer [' + name + '], argument provided is not a function');\n                            } else {\n                                datalayers[name] = datalayer;\n                                datalayers[name].prototype = new LocusZoom.DataLayer();\n                            }\n                        } else {\n                            delete datalayers[name];\n                        }\n                    };\n                    /**\n     * Add a new type of datalayer to the registry of known layer types\n     * @name LocusZoom.DataLayers.add\n     * @param {String} name The name of the data layer to register\n     * @param {Function} datalayer\n     */\n                    obj.add = function (name, datalayer) {\n                        if (datalayers[name]) {\n                            throw new Error('data layer already exists with name: ' + name);\n                        } else {\n                            obj.set(name, datalayer);\n                        }\n                    };\n                    /**\n     * Register a new datalayer that inherits and extends basic behaviors from a known datalayer\n     * @param {String} parent_name The name of the parent data layer whose behavior is to be extended\n     * @param {String} name The name of the new datalayer to register\n     * @param {Object} [overrides] Object of properties and methods to combine with the prototype of the parent datalayer\n     * @returns {Function} The constructor for the new child class\n     */\n                    obj.extend = function (parent_name, name, overrides) {\n                        // TODO: Consider exposing additional constructor argument, if there is a use case for very granular extension\n                        overrides = overrides || {};\n                        var parent = datalayers[parent_name];\n                        if (!parent) {\n                            throw new Error('Attempted to subclass an unknown or unregistered datalayer type');\n                        }\n                        if (typeof overrides !== 'object') {\n                            throw new Error('Must specify an object of properties and methods');\n                        }\n                        var child = LocusZoom.subclass(parent, overrides);\n                        // Bypass .set() because we want a layer of inheritance below `DataLayer`\n                        datalayers[name] = child;\n                        return child;\n                    };\n                    /**\n     * List the names of all known datalayers\n     * @name LocusZoom.DataLayers.list\n     * @returns {String[]}\n     */\n                    obj.list = function () {\n                        return Object.keys(datalayers);\n                    };\n                    return obj;\n                }();\n                'use strict';\n                /**\n * Create a single continuous 2D track that provides information about each datapoint\n *\n * For example, this can be used to color by membership in a group, alongside information in other panels\n *\n * @class LocusZoom.DataLayers.annotation_track\n * @augments LocusZoom.DataLayer\n * @param {Object} layout\n * @param {Object|String} [layout.color]\n * @param {Array[]} An array of filter entries specifying which points to draw annotations for.\n *  See `LocusZoom.DataLayer.filter` for details\n */\n                LocusZoom.DataLayers.add('annotation_track', function (layout) {\n                    // In the future we may add additional options for controlling marker size/ shape, based on user feedback\n                    this.DefaultLayout = {\n                        color: '#000000',\n                        filters: [],\n                        tooltip_positioning: 'middle',\n                        // Allowed values: top, middle, bottom\n                        hit_area_width: 8\n                    };\n                    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n                    if (!Array.isArray(layout.filters)) {\n                        throw new Error('Annotation track must specify array of filters for selecting points to annotate');\n                    }\n                    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n                    LocusZoom.DataLayer.apply(this, arguments);\n                    this.render = function () {\n                        var self = this;\n                        // Only render points that currently satisfy all provided filter conditions.\n                        var trackData = this.filter(this.layout.filters, 'elements');\n                        // Put the <g> containing visible lines before the one containing hit areas, so that the hit areas will be on top.\n                        var visible_lines_group = this.svg.group.select('g.lz-data_layer-' + self.layout.type + '-visible_lines');\n                        if (visible_lines_group.size() === 0) {\n                            visible_lines_group = this.svg.group.append('g').attr('class', 'lz-data_layer-' + self.layout.type + '-visible_lines');\n                        }\n                        var selection = visible_lines_group.selectAll('rect.lz-data_layer-' + self.layout.type).data(trackData, function (d) {\n                            return d[self.layout.id_field];\n                        });\n                        // Draw rectangles (visual and tooltip positioning)\n                        selection.enter().append('rect').attr('class', 'lz-data_layer-' + this.layout.type).attr('id', function (d) {\n                            return self.getElementId(d);\n                        });\n                        var width = 1;\n                        selection.attr('x', function (d) {\n                            return self.parent['x_scale'](d[self.layout.x_axis.field]) - width / 2;\n                        }).attr('width', width).attr('height', self.parent.layout.height).attr('fill', function (d) {\n                            return self.resolveScalableParameter(self.layout.color, d);\n                        });\n                        // Remove unused elements\n                        selection.exit().remove();\n                        var hit_areas_group = this.svg.group.select('g.lz-data_layer-' + self.layout.type + '-hit_areas');\n                        if (hit_areas_group.size() === 0) {\n                            hit_areas_group = this.svg.group.append('g').attr('class', 'lz-data_layer-' + self.layout.type + '-hit_areas');\n                        }\n                        var hit_areas_selection = hit_areas_group.selectAll('rect.lz-data_layer-' + self.layout.type).data(trackData, function (d) {\n                            return d[self.layout.id_field];\n                        });\n                        // Add new elements as needed\n                        hit_areas_selection.enter().append('rect').attr('class', 'lz-data_layer-' + this.layout.type).attr('id', function (d) {\n                            return self.getElementId(d);\n                        });\n                        // Update the set of elements to reflect new data\n                        var _getX = function (d, i) {\n                            // Helper for position calcs below\n                            var x_center = self.parent['x_scale'](d[self.layout.x_axis.field]);\n                            var x_left = x_center - self.layout.hit_area_width / 2;\n                            if (i >= 1) {\n                                // This assumes that the data are in sorted order.\n                                var left_node = trackData[i - 1];\n                                var left_node_x_center = self.parent['x_scale'](left_node[self.layout.x_axis.field]);\n                                x_left = Math.max(x_left, (x_center + left_node_x_center) / 2);\n                            }\n                            return [\n                                x_left,\n                                x_center\n                            ];\n                        };\n                        hit_areas_selection.attr('height', self.parent.layout.height).attr('opacity', 0).attr('x', function (d, i) {\n                            var crds = _getX(d, i);\n                            return crds[0];\n                        }).attr('width', function (d, i) {\n                            var crds = _getX(d, i);\n                            return crds[1] - crds[0] + self.layout.hit_area_width / 2;\n                        });\n                        // Remove unused elements\n                        hit_areas_selection.exit().remove();\n                        // Set up tooltips and mouse interaction\n                        this.applyBehaviors(hit_areas_selection);\n                    };\n                    // Reimplement the positionTooltip() method to be annotation-specific\n                    this.positionTooltip = function (id) {\n                        if (typeof id != 'string') {\n                            throw new Error('Unable to position tooltip: id is not a string');\n                        }\n                        if (!this.tooltips[id]) {\n                            throw new Error('Unable to position tooltip: id does not point to a valid tooltip');\n                        }\n                        var top, left, arrow_type, arrow_top, arrow_left;\n                        var tooltip = this.tooltips[id];\n                        var arrow_width = 7;\n                        // as defined in the default stylesheet\n                        var stroke_width = 1;\n                        // as defined in the default stylesheet\n                        var offset = stroke_width / 2;\n                        var page_origin = this.getPageOrigin();\n                        var tooltip_box = tooltip.selector.node().getBoundingClientRect();\n                        var data_layer_height = this.parent.layout.height - (this.parent.layout.margin.top + this.parent.layout.margin.bottom);\n                        var data_layer_width = this.parent.layout.width - (this.parent.layout.margin.left + this.parent.layout.margin.right);\n                        var x_center = this.parent.x_scale(tooltip.data[this.layout.x_axis.field]);\n                        var y_center = data_layer_height / 2;\n                        // Tooltip should be horizontally centered above the point to be annotated. (or below if space is limited)\n                        var offset_right = Math.max(tooltip_box.width / 2 - x_center, 0);\n                        var offset_left = Math.max(tooltip_box.width / 2 + x_center - data_layer_width, 0);\n                        left = page_origin.x + x_center - tooltip_box.width / 2 - offset_left + offset_right;\n                        arrow_left = tooltip_box.width / 2 - arrow_width + offset_left - offset_right - offset;\n                        var top_offset = 0;\n                        switch (this.layout.tooltip_positioning) {\n                        case 'top':\n                            arrow_type = 'down';\n                            break;\n                        case 'bottom':\n                            top_offset = data_layer_height;\n                            arrow_type = 'up';\n                            break;\n                        case 'middle':\n                        default:\n                            var position = d3.mouse(this.svg.container.node());\n                            // Position the tooltip so that it does not overlap the mouse pointer\n                            top_offset = y_center;\n                            if (position[1] > data_layer_height / 2) {\n                                arrow_type = 'down';\n                            } else {\n                                arrow_type = 'up';\n                            }\n                        }\n                        if (arrow_type === 'up') {\n                            top = page_origin.y + top_offset + stroke_width + arrow_width;\n                            arrow_top = 0 - stroke_width - arrow_width;\n                        } else if (arrow_type === 'down') {\n                            top = page_origin.y + top_offset - (tooltip_box.height + stroke_width + arrow_width);\n                            arrow_top = tooltip_box.height - stroke_width;\n                        }\n                        // Apply positions to the main div\n                        tooltip.selector.style('left', left + 'px').style('top', top + 'px');\n                        // Create / update position on arrow connecting tooltip to data\n                        if (!tooltip.arrow) {\n                            tooltip.arrow = tooltip.selector.append('div').style('position', 'absolute');\n                        }\n                        tooltip.arrow.attr('class', 'lz-data_layer-tooltip-arrow_' + arrow_type).style('left', arrow_left + 'px').style('top', arrow_top + 'px');\n                    };\n                    return this;\n                });\n                'use strict';\n                /**\n * Forest Data Layer\n * Implements a standard forest plot. In order to space out points, any layout using this must specify axis ticks\n *  and extent in advance.\n *\n * If you are using dynamically fetched data, consider using `category_forest` instead.\n *\n * @class LocusZoom.DataLayers.forest\n */\n                LocusZoom.DataLayers.add('forest', function (layout) {\n                    // Define a default layout for this DataLayer type and merge it with the passed argument\n                    this.DefaultLayout = {\n                        point_size: 40,\n                        point_shape: 'square',\n                        color: '#888888',\n                        fill_opacity: 1,\n                        y_axis: { axis: 2 },\n                        id_field: 'id',\n                        confidence_intervals: {\n                            start_field: 'ci_start',\n                            end_field: 'ci_end'\n                        },\n                        show_no_significance_line: true\n                    };\n                    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n                    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n                    LocusZoom.DataLayer.apply(this, arguments);\n                    // Reimplement the positionTooltip() method to be forest-specific\n                    this.positionTooltip = function (id) {\n                        if (typeof id != 'string') {\n                            throw new Error('Unable to position tooltip: id is not a string');\n                        }\n                        if (!this.tooltips[id]) {\n                            throw new Error('Unable to position tooltip: id does not point to a valid tooltip');\n                        }\n                        var tooltip = this.tooltips[id];\n                        var point_size = this.resolveScalableParameter(this.layout.point_size, tooltip.data);\n                        var arrow_width = 7;\n                        // as defined in the default stylesheet\n                        var stroke_width = 1;\n                        // as defined in the default stylesheet\n                        var border_radius = 6;\n                        // as defined in the default stylesheet\n                        var page_origin = this.getPageOrigin();\n                        var x_center = this.parent.x_scale(tooltip.data[this.layout.x_axis.field]);\n                        var y_scale = 'y' + this.layout.y_axis.axis + '_scale';\n                        var y_center = this.parent[y_scale](tooltip.data[this.layout.y_axis.field]);\n                        var tooltip_box = tooltip.selector.node().getBoundingClientRect();\n                        // Position horizontally on the left or the right depending on which side of the plot the point is on\n                        var offset = Math.sqrt(point_size / Math.PI);\n                        var left, arrow_type, arrow_left;\n                        if (x_center <= this.parent.layout.width / 2) {\n                            left = page_origin.x + x_center + offset + arrow_width + stroke_width;\n                            arrow_type = 'left';\n                            arrow_left = -1 * (arrow_width + stroke_width);\n                        } else {\n                            left = page_origin.x + x_center - tooltip_box.width - offset - arrow_width - stroke_width;\n                            arrow_type = 'right';\n                            arrow_left = tooltip_box.width - stroke_width;\n                        }\n                        // Position vertically centered unless we're at the top or bottom of the plot\n                        var data_layer_height = this.parent.layout.height - (this.parent.layout.margin.top + this.parent.layout.margin.bottom);\n                        var top, arrow_top;\n                        if (y_center - tooltip_box.height / 2 <= 0) {\n                            // Too close to the top, push it down\n                            top = page_origin.y + y_center - 1.5 * arrow_width - border_radius;\n                            arrow_top = border_radius;\n                        } else if (y_center + tooltip_box.height / 2 >= data_layer_height) {\n                            // Too close to the bottom, pull it up\n                            top = page_origin.y + y_center + arrow_width + border_radius - tooltip_box.height;\n                            arrow_top = tooltip_box.height - 2 * arrow_width - border_radius;\n                        } else {\n                            // vertically centered\n                            top = page_origin.y + y_center - tooltip_box.height / 2;\n                            arrow_top = tooltip_box.height / 2 - arrow_width;\n                        }\n                        // Apply positions to the main div\n                        tooltip.selector.style('left', left + 'px').style('top', top + 'px');\n                        // Create / update position on arrow connecting tooltip to data\n                        if (!tooltip.arrow) {\n                            tooltip.arrow = tooltip.selector.append('div').style('position', 'absolute');\n                        }\n                        tooltip.arrow.attr('class', 'lz-data_layer-tooltip-arrow_' + arrow_type).style('left', arrow_left + 'px').style('top', arrow_top + 'px');\n                    };\n                    // Implement the main render function\n                    this.render = function () {\n                        var x_scale = 'x_scale';\n                        var y_scale = 'y' + this.layout.y_axis.axis + '_scale';\n                        // Generate confidence interval paths if fields are defined\n                        if (this.layout.confidence_intervals && this.layout.fields.indexOf(this.layout.confidence_intervals.start_field) !== -1 && this.layout.fields.indexOf(this.layout.confidence_intervals.end_field) !== -1) {\n                            // Generate a selection for all forest plot confidence intervals\n                            var ci_selection = this.svg.group.selectAll('rect.lz-data_layer-forest.lz-data_layer-forest-ci').data(this.data, function (d) {\n                                return d[this.layout.id_field];\n                            }.bind(this));\n                            // Create confidence interval rect elements\n                            ci_selection.enter().append('rect').attr('class', 'lz-data_layer-forest lz-data_layer-forest-ci').attr('id', function (d) {\n                                return this.getElementId(d) + '_ci';\n                            }.bind(this)).attr('transform', 'translate(0,' + (isNaN(this.parent.layout.height) ? 0 : this.parent.layout.height) + ')');\n                            // Apply position and size parameters using transition if necessary\n                            var ci_transform = function (d) {\n                                var x = this.parent[x_scale](d[this.layout.confidence_intervals.start_field]);\n                                var y = this.parent[y_scale](d[this.layout.y_axis.field]);\n                                if (isNaN(x)) {\n                                    x = -1000;\n                                }\n                                if (isNaN(y)) {\n                                    y = -1000;\n                                }\n                                return 'translate(' + x + ',' + y + ')';\n                            }.bind(this);\n                            var ci_width = function (d) {\n                                return this.parent[x_scale](d[this.layout.confidence_intervals.end_field]) - this.parent[x_scale](d[this.layout.confidence_intervals.start_field]);\n                            }.bind(this);\n                            var ci_height = 1;\n                            if (this.canTransition()) {\n                                ci_selection.transition().duration(this.layout.transition.duration || 0).ease(this.layout.transition.ease || 'cubic-in-out').attr('transform', ci_transform).attr('width', ci_width).attr('height', ci_height);\n                            } else {\n                                ci_selection.attr('transform', ci_transform).attr('width', ci_width).attr('height', ci_height);\n                            }\n                            // Remove old elements as needed\n                            ci_selection.exit().remove();\n                        }\n                        // Generate a selection for all forest plot points\n                        var points_selection = this.svg.group.selectAll('path.lz-data_layer-forest.lz-data_layer-forest-point').data(this.data, function (d) {\n                            return d[this.layout.id_field];\n                        }.bind(this));\n                        // Create elements, apply class, ID, and initial position\n                        var initial_y = isNaN(this.parent.layout.height) ? 0 : this.parent.layout.height;\n                        points_selection.enter().append('path').attr('class', 'lz-data_layer-forest lz-data_layer-forest-point').attr('id', function (d) {\n                            return this.getElementId(d);\n                        }.bind(this)).attr('transform', 'translate(0,' + initial_y + ')');\n                        // Generate new values (or functions for them) for position, color, size, and shape\n                        var transform = function (d) {\n                            var x = this.parent[x_scale](d[this.layout.x_axis.field]);\n                            var y = this.parent[y_scale](d[this.layout.y_axis.field]);\n                            if (isNaN(x)) {\n                                x = -1000;\n                            }\n                            if (isNaN(y)) {\n                                y = -1000;\n                            }\n                            return 'translate(' + x + ',' + y + ')';\n                        }.bind(this);\n                        var fill = function (d) {\n                            return this.resolveScalableParameter(this.layout.color, d);\n                        }.bind(this);\n                        var fill_opacity = function (d) {\n                            return this.resolveScalableParameter(this.layout.fill_opacity, d);\n                        }.bind(this);\n                        var shape = d3.svg.symbol().size(function (d) {\n                            return this.resolveScalableParameter(this.layout.point_size, d);\n                        }.bind(this)).type(function (d) {\n                            return this.resolveScalableParameter(this.layout.point_shape, d);\n                        }.bind(this));\n                        // Apply position and color, using a transition if necessary\n                        if (this.canTransition()) {\n                            points_selection.transition().duration(this.layout.transition.duration || 0).ease(this.layout.transition.ease || 'cubic-in-out').attr('transform', transform).attr('fill', fill).attr('fill-opacity', fill_opacity).attr('d', shape);\n                        } else {\n                            points_selection.attr('transform', transform).attr('fill', fill).attr('fill-opacity', fill_opacity).attr('d', shape);\n                        }\n                        // Remove old elements as needed\n                        points_selection.exit().remove();\n                        // Apply default event emitters to selection\n                        points_selection.on('click.event_emitter', function (element_data) {\n                            this.parent.emit('element_clicked', element_data, true);\n                        }.bind(this));\n                        // Apply behaviors to points\n                        this.applyBehaviors(points_selection);\n                    };\n                    return this;\n                });\n                /**\n * A y-aligned forest plot in which the y-axis represents item labels, which are dynamically chosen when data is loaded.\n *   Each item is assumed to include both data and confidence intervals.\n *   This allows generating forest plots without defining the layout in advance.\n *\n * @class LocusZoom.DataLayers.category_forest\n * @augments LocusZoom.DataLayers.forest\n */\n                LocusZoom.DataLayers.extend('forest', 'category_forest', {\n                    _getDataExtent: function (data, axis_config) {\n                        // In a forest plot, the data range is determined by *three* fields (beta + CI start/end)\n                        var ci_config = this.layout.confidence_intervals;\n                        if (ci_config && this.layout.fields.indexOf(ci_config.start_field) !== -1 && this.layout.fields.indexOf(ci_config.end_field) !== -1) {\n                            var min = function (d) {\n                                var f = new LocusZoom.Data.Field(ci_config.start_field);\n                                return +f.resolve(d);\n                            };\n                            var max = function (d) {\n                                var f = new LocusZoom.Data.Field(ci_config.end_field);\n                                return +f.resolve(d);\n                            };\n                            return [\n                                d3.min(data, min),\n                                d3.max(data, max)\n                            ];\n                        }\n                        // If there are no confidence intervals set, then range must depend only on a single field\n                        return LocusZoom.DataLayer.prototype._getDataExtent.call(this, data, axis_config);\n                    },\n                    getTicks: function (dimension, config) {\n                        // Overrides parent method\n                        if ([\n                                'x',\n                                'y1',\n                                'y2'\n                            ].indexOf(dimension) === -1) {\n                            throw new Error('Invalid dimension identifier' + dimension);\n                        }\n                        // Design assumption: one axis (y1 or y2) has the ticks, and the layout says which to use\n                        // Also assumes that every tick gets assigned a unique matching label\n                        var axis_num = this.layout.y_axis.axis;\n                        if (dimension === 'y' + axis_num) {\n                            var category_field = this.layout.y_axis.category_field;\n                            if (!category_field) {\n                                throw new Error('Layout for ' + this.layout.id + ' must specify category_field');\n                            }\n                            return this.data.map(function (item, index) {\n                                return {\n                                    y: index + 1,\n                                    text: item[category_field]\n                                };\n                            });\n                        } else {\n                            return [];\n                        }\n                    },\n                    applyCustomDataMethods: function () {\n                        // Add a synthetic yaxis field to ensure data is spread out on plot. Then, set axis floor and ceiling to\n                        //  correct extents.\n                        var field_to_add = this.layout.y_axis.field;\n                        if (!field_to_add) {\n                            throw new Error('Layout for ' + this.layout.id + ' must specify yaxis.field');\n                        }\n                        this.data = this.data.map(function (item, index) {\n                            item[field_to_add] = index + 1;\n                            return item;\n                        });\n                        // Update axis extents based on one label for every point (with a bit of padding above and below)\n                        this.layout.y_axis.floor = 0;\n                        this.layout.y_axis.ceiling = this.data.length + 1;\n                        return this;\n                    }\n                });\n                'use strict';\n                /*********************\n * Genes Data Layer\n * Implements a data layer that will render gene tracks\n * @class\n * @augments LocusZoom.DataLayer\n*/\n                LocusZoom.DataLayers.add('genes', function (layout) {\n                    /**\n     * Define a default layout for this DataLayer type and merge it with the passed argument\n     * @protected\n     * @member {Object}\n     * */\n                    this.DefaultLayout = {\n                        // Optionally specify different fill and stroke properties\n                        stroke: 'rgb(54, 54, 150)',\n                        color: '#363696',\n                        label_font_size: 12,\n                        label_exon_spacing: 4,\n                        exon_height: 16,\n                        bounding_box_padding: 6,\n                        track_vertical_spacing: 10\n                    };\n                    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n                    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n                    LocusZoom.DataLayer.apply(this, arguments);\n                    /**\n     * Generate a statusnode ID for a given element\n     * @override\n     * @returns {String}\n     */\n                    this.getElementStatusNodeId = function (element) {\n                        return this.getElementId(element) + '-statusnode';\n                    };\n                    /**\n     * Helper function to sum layout values to derive total height for a single gene track\n     * @returns {number}\n     */\n                    this.getTrackHeight = function () {\n                        return 2 * this.layout.bounding_box_padding + this.layout.label_font_size + this.layout.label_exon_spacing + this.layout.exon_height + this.layout.track_vertical_spacing;\n                    };\n                    /**\n     * A gene may have arbitrarily many transcripts, but this data layer isn't set up to render them yet.\n     * Stash a transcript_idx to point to the first transcript and use that for all transcript refs.\n     * @member {number}\n     * @type {number}\n     */\n                    this.transcript_idx = 0;\n                    /**\n     * An internal counter for the number of tracks in the data layer. Used as an internal counter for looping\n     *   over positions / assignments\n     * @protected\n     * @member {number}\n     */\n                    this.tracks = 1;\n                    /**\n     * Store information about genes in dataset, in a hash indexed by track number: {track_number: [gene_indices]}\n     * @member {Object.<Number, Array>}\n     */\n                    this.gene_track_index = { 1: [] };\n                    /**\n     * Ensure that genes in overlapping chromosome regions are positioned so that parts of different genes do not\n     *   overlap in the view. A track is a row used to vertically separate overlapping genes.\n     * @returns {LocusZoom.DataLayer}\n     */\n                    this.assignTracks = function () {\n                        /**\n         * Function to get the width in pixels of a label given the text and layout attributes\n         *      TODO: Move to outer scope?\n         * @param {String} gene_name\n         * @param {number|string} font_size\n         * @returns {number}\n         */\n                        this.getLabelWidth = function (gene_name, font_size) {\n                            try {\n                                var temp_text = this.svg.group.append('text').attr('x', 0).attr('y', 0).attr('class', 'lz-data_layer-genes lz-label').style('font-size', font_size).text(gene_name + '\\u2192');\n                                var label_width = temp_text.node().getBBox().width;\n                                temp_text.remove();\n                                return label_width;\n                            } catch (e) {\n                                return 0;\n                            }\n                        };\n                        // Reinitialize some metadata\n                        this.tracks = 1;\n                        this.gene_track_index = { 1: [] };\n                        this.data.map(function (d, g) {\n                            // If necessary, split combined gene id / version fields into discrete fields.\n                            // NOTE: this may be an issue with CSG's genes data source that may eventually be solved upstream.\n                            if (this.data[g].gene_id && this.data[g].gene_id.indexOf('.')) {\n                                var split = this.data[g].gene_id.split('.');\n                                this.data[g].gene_id = split[0];\n                                this.data[g].gene_version = split[1];\n                            }\n                            // Stash the transcript ID on the parent gene\n                            this.data[g].transcript_id = this.data[g].transcripts[this.transcript_idx].transcript_id;\n                            // Determine display range start and end, based on minimum allowable gene display width, bounded by what we can see\n                            // (range: values in terms of pixels on the screen)\n                            this.data[g].display_range = {\n                                start: this.parent.x_scale(Math.max(d.start, this.state.start)),\n                                end: this.parent.x_scale(Math.min(d.end, this.state.end))\n                            };\n                            this.data[g].display_range.label_width = this.getLabelWidth(this.data[g].gene_name, this.layout.label_font_size);\n                            this.data[g].display_range.width = this.data[g].display_range.end - this.data[g].display_range.start;\n                            // Determine label text anchor (default to middle)\n                            this.data[g].display_range.text_anchor = 'middle';\n                            if (this.data[g].display_range.width < this.data[g].display_range.label_width) {\n                                if (d.start < this.state.start) {\n                                    this.data[g].display_range.end = this.data[g].display_range.start + this.data[g].display_range.label_width + this.layout.label_font_size;\n                                    this.data[g].display_range.text_anchor = 'start';\n                                } else if (d.end > this.state.end) {\n                                    this.data[g].display_range.start = this.data[g].display_range.end - this.data[g].display_range.label_width - this.layout.label_font_size;\n                                    this.data[g].display_range.text_anchor = 'end';\n                                } else {\n                                    var centered_margin = (this.data[g].display_range.label_width - this.data[g].display_range.width) / 2 + this.layout.label_font_size;\n                                    if (this.data[g].display_range.start - centered_margin < this.parent.x_scale(this.state.start)) {\n                                        this.data[g].display_range.start = this.parent.x_scale(this.state.start);\n                                        this.data[g].display_range.end = this.data[g].display_range.start + this.data[g].display_range.label_width;\n                                        this.data[g].display_range.text_anchor = 'start';\n                                    } else if (this.data[g].display_range.end + centered_margin > this.parent.x_scale(this.state.end)) {\n                                        this.data[g].display_range.end = this.parent.x_scale(this.state.end);\n                                        this.data[g].display_range.start = this.data[g].display_range.end - this.data[g].display_range.label_width;\n                                        this.data[g].display_range.text_anchor = 'end';\n                                    } else {\n                                        this.data[g].display_range.start -= centered_margin;\n                                        this.data[g].display_range.end += centered_margin;\n                                    }\n                                }\n                                this.data[g].display_range.width = this.data[g].display_range.end - this.data[g].display_range.start;\n                            }\n                            // Add bounding box padding to the calculated display range start, end, and width\n                            this.data[g].display_range.start -= this.layout.bounding_box_padding;\n                            this.data[g].display_range.end += this.layout.bounding_box_padding;\n                            this.data[g].display_range.width += 2 * this.layout.bounding_box_padding;\n                            // Convert and stash display range values into domain values\n                            // (domain: values in terms of the data set, e.g. megabases)\n                            this.data[g].display_domain = {\n                                start: this.parent.x_scale.invert(this.data[g].display_range.start),\n                                end: this.parent.x_scale.invert(this.data[g].display_range.end)\n                            };\n                            this.data[g].display_domain.width = this.data[g].display_domain.end - this.data[g].display_domain.start;\n                            // Using display range/domain data generated above cast each gene to tracks such that none overlap\n                            this.data[g].track = null;\n                            var potential_track = 1;\n                            while (this.data[g].track === null) {\n                                var collision_on_potential_track = false;\n                                this.gene_track_index[potential_track].map(function (placed_gene) {\n                                    if (!collision_on_potential_track) {\n                                        var min_start = Math.min(placed_gene.display_range.start, this.display_range.start);\n                                        var max_end = Math.max(placed_gene.display_range.end, this.display_range.end);\n                                        if (max_end - min_start < placed_gene.display_range.width + this.display_range.width) {\n                                            collision_on_potential_track = true;\n                                        }\n                                    }\n                                }.bind(this.data[g]));\n                                if (!collision_on_potential_track) {\n                                    this.data[g].track = potential_track;\n                                    this.gene_track_index[potential_track].push(this.data[g]);\n                                } else {\n                                    potential_track++;\n                                    if (potential_track > this.tracks) {\n                                        this.tracks = potential_track;\n                                        this.gene_track_index[potential_track] = [];\n                                    }\n                                }\n                            }\n                            // Stash parent references on all genes, trascripts, and exons\n                            this.data[g].parent = this;\n                            this.data[g].transcripts.map(function (d, t) {\n                                this.data[g].transcripts[t].parent = this.data[g];\n                                this.data[g].transcripts[t].exons.map(function (d, e) {\n                                    this.data[g].transcripts[t].exons[e].parent = this.data[g].transcripts[t];\n                                }.bind(this));\n                            }.bind(this));\n                        }.bind(this));\n                        return this;\n                    };\n                    /**\n     * Main render function\n     */\n                    this.render = function () {\n                        var self = this;\n                        this.assignTracks();\n                        var width, height, x, y;\n                        // Render gene groups\n                        var selection = this.svg.group.selectAll('g.lz-data_layer-genes').data(this.data, function (d) {\n                            return d.gene_name;\n                        });\n                        selection.enter().append('g').attr('class', 'lz-data_layer-genes');\n                        selection.attr('id', function (d) {\n                            return this.getElementId(d);\n                        }.bind(this)).each(function (gene) {\n                            var data_layer = gene.parent;\n                            // Render gene bounding boxes (status nodes to show selected/highlighted)\n                            var bboxes = d3.select(this).selectAll('rect.lz-data_layer-genes.lz-data_layer-genes-statusnode').data([gene], function (d) {\n                                return data_layer.getElementStatusNodeId(d);\n                            });\n                            bboxes.enter().append('rect').attr('class', 'lz-data_layer-genes lz-data_layer-genes-statusnode');\n                            bboxes.attr('id', function (d) {\n                                return data_layer.getElementStatusNodeId(d);\n                            }).attr('rx', function () {\n                                return data_layer.layout.bounding_box_padding;\n                            }).attr('ry', function () {\n                                return data_layer.layout.bounding_box_padding;\n                            });\n                            width = function (d) {\n                                return d.display_range.width;\n                            };\n                            height = function () {\n                                return data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing;\n                            };\n                            x = function (d) {\n                                return d.display_range.start;\n                            };\n                            y = function (d) {\n                                return (d.track - 1) * data_layer.getTrackHeight();\n                            };\n                            if (data_layer.canTransition()) {\n                                bboxes.transition().duration(data_layer.layout.transition.duration || 0).ease(data_layer.layout.transition.ease || 'cubic-in-out').attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                            } else {\n                                bboxes.attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                            }\n                            bboxes.exit().remove();\n                            // Render gene boundaries\n                            var boundary_fill = function (d) {\n                                return self.resolveScalableParameter(self.layout.color, d);\n                            };\n                            var boundary_stroke = function (d) {\n                                return self.resolveScalableParameter(self.layout.stroke, d);\n                            };\n                            var boundaries = d3.select(this).selectAll('rect.lz-data_layer-genes.lz-boundary').data([gene], function (d) {\n                                return d.gene_name + '_boundary';\n                            }).style({\n                                fill: boundary_fill,\n                                stroke: boundary_stroke\n                            });\n                            boundaries.enter().append('rect').attr('class', 'lz-data_layer-genes lz-boundary');\n                            width = function (d) {\n                                return data_layer.parent.x_scale(d.end) - data_layer.parent.x_scale(d.start);\n                            };\n                            height = function () {\n                                return 1;    // TODO: scale dynamically?\n                            };\n                            x = function (d) {\n                                return data_layer.parent.x_scale(d.start);\n                            };\n                            y = function (d) {\n                                return (d.track - 1) * data_layer.getTrackHeight() + data_layer.layout.bounding_box_padding + data_layer.layout.label_font_size + data_layer.layout.label_exon_spacing + Math.max(data_layer.layout.exon_height, 3) / 2;\n                            };\n                            if (data_layer.canTransition()) {\n                                boundaries.transition().duration(data_layer.layout.transition.duration || 0).ease(data_layer.layout.transition.ease || 'cubic-in-out').attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                            } else {\n                                boundaries.attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                            }\n                            boundaries.exit().remove();\n                            // Render gene labels\n                            var labels = d3.select(this).selectAll('text.lz-data_layer-genes.lz-label').data([gene], function (d) {\n                                return d.gene_name + '_label';\n                            });\n                            labels.enter().append('text').attr('class', 'lz-data_layer-genes lz-label');\n                            labels.attr('text-anchor', function (d) {\n                                return d.display_range.text_anchor;\n                            }).text(function (d) {\n                                return d.strand === '+' ? d.gene_name + '\\u2192' : '\\u2190' + d.gene_name;\n                            }).style('font-size', gene.parent.layout.label_font_size);\n                            x = function (d) {\n                                if (d.display_range.text_anchor === 'middle') {\n                                    return d.display_range.start + d.display_range.width / 2;\n                                } else if (d.display_range.text_anchor === 'start') {\n                                    return d.display_range.start + data_layer.layout.bounding_box_padding;\n                                } else if (d.display_range.text_anchor === 'end') {\n                                    return d.display_range.end - data_layer.layout.bounding_box_padding;\n                                }\n                            };\n                            y = function (d) {\n                                return (d.track - 1) * data_layer.getTrackHeight() + data_layer.layout.bounding_box_padding + data_layer.layout.label_font_size;\n                            };\n                            if (data_layer.canTransition()) {\n                                labels.transition().duration(data_layer.layout.transition.duration || 0).ease(data_layer.layout.transition.ease || 'cubic-in-out').attr('x', x).attr('y', y);\n                            } else {\n                                labels.attr('x', x).attr('y', y);\n                            }\n                            labels.exit().remove();\n                            // Render exon rects (first transcript only, for now)\n                            // Exons: by default color on gene properties for consistency with the gene boundary track- hence color uses d.parent.parent\n                            var exon_fill = function (d) {\n                                return self.resolveScalableParameter(self.layout.color, d.parent.parent);\n                            };\n                            var exon_stroke = function (d) {\n                                return self.resolveScalableParameter(self.layout.stroke, d.parent.parent);\n                            };\n                            var exons = d3.select(this).selectAll('rect.lz-data_layer-genes.lz-exon').data(gene.transcripts[gene.parent.transcript_idx].exons, function (d) {\n                                return d.exon_id;\n                            });\n                            exons.enter().append('rect').attr('class', 'lz-data_layer-genes lz-exon');\n                            exons.style({\n                                fill: exon_fill,\n                                stroke: exon_stroke\n                            });\n                            width = function (d) {\n                                return data_layer.parent.x_scale(d.end) - data_layer.parent.x_scale(d.start);\n                            };\n                            height = function () {\n                                return data_layer.layout.exon_height;\n                            };\n                            x = function (d) {\n                                return data_layer.parent.x_scale(d.start);\n                            };\n                            y = function () {\n                                return (gene.track - 1) * data_layer.getTrackHeight() + data_layer.layout.bounding_box_padding + data_layer.layout.label_font_size + data_layer.layout.label_exon_spacing;\n                            };\n                            if (data_layer.canTransition()) {\n                                exons.transition().duration(data_layer.layout.transition.duration || 0).ease(data_layer.layout.transition.ease || 'cubic-in-out').attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                            } else {\n                                exons.attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                            }\n                            exons.exit().remove();\n                            // Render gene click area\n                            var clickareas = d3.select(this).selectAll('rect.lz-data_layer-genes.lz-clickarea').data([gene], function (d) {\n                                return d.gene_name + '_clickarea';\n                            });\n                            clickareas.enter().append('rect').attr('class', 'lz-data_layer-genes lz-clickarea');\n                            clickareas.attr('id', function (d) {\n                                return data_layer.getElementId(d) + '_clickarea';\n                            }).attr('rx', function () {\n                                return data_layer.layout.bounding_box_padding;\n                            }).attr('ry', function () {\n                                return data_layer.layout.bounding_box_padding;\n                            });\n                            width = function (d) {\n                                return d.display_range.width;\n                            };\n                            height = function () {\n                                return data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing;\n                            };\n                            x = function (d) {\n                                return d.display_range.start;\n                            };\n                            y = function (d) {\n                                return (d.track - 1) * data_layer.getTrackHeight();\n                            };\n                            if (data_layer.canTransition()) {\n                                clickareas.transition().duration(data_layer.layout.transition.duration || 0).ease(data_layer.layout.transition.ease || 'cubic-in-out').attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                            } else {\n                                clickareas.attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                            }\n                            // Remove old clickareas as needed\n                            clickareas.exit().remove();\n                            // Apply default event emitters to clickareas\n                            clickareas.on('click.event_emitter', function (element) {\n                                element.parent.parent.emit('element_clicked', element, true);\n                            });\n                            // Apply mouse behaviors to clickareas\n                            data_layer.applyBehaviors(clickareas);\n                        });\n                        // Remove old elements as needed\n                        selection.exit().remove();\n                    };\n                    /**\n     * Reimplement the positionTooltip() method to be gene-specific\n     * @param {String} id\n     */\n                    this.positionTooltip = function (id) {\n                        if (typeof id != 'string') {\n                            throw new Error('Unable to position tooltip: id is not a string');\n                        }\n                        if (!this.tooltips[id]) {\n                            throw new Error('Unable to position tooltip: id does not point to a valid tooltip');\n                        }\n                        var tooltip = this.tooltips[id];\n                        var arrow_width = 7;\n                        // as defined in the default stylesheet\n                        var stroke_width = 1;\n                        // as defined in the default stylesheet\n                        var page_origin = this.getPageOrigin();\n                        var tooltip_box = tooltip.selector.node().getBoundingClientRect();\n                        var gene_bbox_id = this.getElementStatusNodeId(tooltip.data);\n                        var gene_bbox = d3.select('#' + gene_bbox_id).node().getBBox();\n                        var data_layer_height = this.parent.layout.height - (this.parent.layout.margin.top + this.parent.layout.margin.bottom);\n                        var data_layer_width = this.parent.layout.width - (this.parent.layout.margin.left + this.parent.layout.margin.right);\n                        // Position horizontally: attempt to center on the portion of the gene that's visible,\n                        // pad to either side if bumping up against the edge of the data layer\n                        var gene_center_x = (tooltip.data.display_range.start + tooltip.data.display_range.end) / 2 - this.layout.bounding_box_padding / 2;\n                        var offset_right = Math.max(tooltip_box.width / 2 - gene_center_x, 0);\n                        var offset_left = Math.max(tooltip_box.width / 2 + gene_center_x - data_layer_width, 0);\n                        var left = page_origin.x + gene_center_x - tooltip_box.width / 2 - offset_left + offset_right;\n                        var arrow_left = tooltip_box.width / 2 - arrow_width / 2 + offset_left - offset_right;\n                        // Position vertically below the gene unless there's insufficient space\n                        var top, arrow_type, arrow_top;\n                        if (tooltip_box.height + stroke_width + arrow_width > data_layer_height - (gene_bbox.y + gene_bbox.height)) {\n                            top = page_origin.y + gene_bbox.y - (tooltip_box.height + stroke_width + arrow_width);\n                            arrow_type = 'down';\n                            arrow_top = tooltip_box.height - stroke_width;\n                        } else {\n                            top = page_origin.y + gene_bbox.y + gene_bbox.height + stroke_width + arrow_width;\n                            arrow_type = 'up';\n                            arrow_top = 0 - stroke_width - arrow_width;\n                        }\n                        // Apply positions to the main div\n                        tooltip.selector.style('left', left + 'px').style('top', top + 'px');\n                        // Create / update position on arrow connecting tooltip to data\n                        if (!tooltip.arrow) {\n                            tooltip.arrow = tooltip.selector.append('div').style('position', 'absolute');\n                        }\n                        tooltip.arrow.attr('class', 'lz-data_layer-tooltip-arrow_' + arrow_type).style('left', arrow_left + 'px').style('top', arrow_top + 'px');\n                    };\n                    return this;\n                });\n                'use strict';\n                /*********************\n  Genome Legend Data Layer\n  Implements a data layer that will render a genome legend\n*/\n                // Build a custom data layer for a genome legend\n                LocusZoom.DataLayers.add('genome_legend', function (layout) {\n                    // Define a default layout for this DataLayer type and merge it with the passed argument\n                    this.DefaultLayout = {\n                        chromosome_fill_colors: {\n                            light: 'rgb(155, 155, 188)',\n                            dark: 'rgb(95, 95, 128)'\n                        },\n                        chromosome_label_colors: {\n                            light: 'rgb(120, 120, 186)',\n                            dark: 'rgb(0, 0, 66)'\n                        }\n                    };\n                    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n                    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n                    LocusZoom.DataLayer.apply(this, arguments);\n                    // Implement the main render function\n                    this.render = function () {\n                        // Iterate over data to generate genome-wide start/end values for each chromosome\n                        var position = 0;\n                        this.data.forEach(function (d, i) {\n                            this.data[i].genome_start = position;\n                            this.data[i].genome_end = position + d['genome:base_pairs'];\n                            position += d['genome:base_pairs'];\n                        }.bind(this));\n                        var chromosomes = this.svg.group.selectAll('rect.lz-data_layer-genome_legend').data(this.data, function (d) {\n                            return d['genome:chr'];\n                        });\n                        // Create chromosome elements, apply class\n                        chromosomes.enter().append('rect').attr('class', 'lz-data_layer-genome_legend');\n                        // Position and fill chromosome rects\n                        var data_layer = this;\n                        var panel = this.parent;\n                        chromosomes.attr('fill', function (d) {\n                            return d['genome:chr'] % 2 ? data_layer.layout.chromosome_fill_colors.light : data_layer.layout.chromosome_fill_colors.dark;\n                        }).attr('x', function (d) {\n                            return panel.x_scale(d.genome_start);\n                        }).attr('y', 0).attr('width', function (d) {\n                            return panel.x_scale(d['genome:base_pairs']);\n                        }).attr('height', panel.layout.cliparea.height);\n                        // Remove old elements as needed\n                        chromosomes.exit().remove();\n                        // Parse current state variant into a position\n                        // Assumes that variant string is of the format 10:123352136_C/T or 10:123352136\n                        var variant_parts = /([^:]+):(\\d+)(?:_.*)?/.exec(this.state.variant);\n                        if (!variant_parts) {\n                            throw new Error('Genome legend cannot understand the specified variant position');\n                        }\n                        var chr = variant_parts[1];\n                        var offset = variant_parts[2];\n                        // TODO: How does this handle representation of X or Y chromosomes?\n                        position = +this.data[chr - 1].genome_start + +offset;\n                        // Render the position\n                        var region = this.svg.group.selectAll('rect.lz-data_layer-genome_legend-marker').data([{\n                                start: position,\n                                end: position + 1\n                            }]);\n                        region.enter().append('rect').attr('class', 'lz-data_layer-genome_legend-marker');\n                        region.transition().duration(500).style({\n                            'fill': 'rgba(255, 250, 50, 0.8)',\n                            'stroke': 'rgba(255, 250, 50, 0.8)',\n                            'stroke-width': '3px'\n                        }).attr('x', function (d) {\n                            return panel.x_scale(d.start);\n                        }).attr('y', 0).attr('width', function (d) {\n                            return panel.x_scale(d.end - d.start);\n                        }).attr('height', panel.layout.cliparea.height);\n                        region.exit().remove();\n                    };\n                    return this;\n                });\n                'use strict';\n                /**\n * Intervals Data Layer\n * Implements a data layer that will render interval annotation tracks (intervals must provide start and end values)\n * @class LocusZoom.DataLayers.intervals\n * @augments LocusZoom.DataLayer\n */\n                LocusZoom.DataLayers.add('intervals', function (layout) {\n                    // Define a default layout for this DataLayer type and merge it with the passed argument\n                    this.DefaultLayout = {\n                        start_field: 'start',\n                        end_field: 'end',\n                        track_split_field: 'state_id',\n                        track_split_order: 'DESC',\n                        track_split_legend_to_y_axis: 2,\n                        split_tracks: true,\n                        track_height: 15,\n                        track_vertical_spacing: 3,\n                        bounding_box_padding: 2,\n                        always_hide_legend: false,\n                        color: '#B8B8B8',\n                        fill_opacity: 1\n                    };\n                    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n                    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n                    LocusZoom.DataLayer.apply(this, arguments);\n                    /**\n     * To define shared highlighting on the track split field define the status node id override\n     * to generate an ID common to the track when we're actively splitting data out to separate tracks\n     * @override\n     * @returns {String}\n     */\n                    this.getElementStatusNodeId = function (element) {\n                        if (this.layout.split_tracks) {\n                            return (this.getBaseId() + '-statusnode-' + element[this.layout.track_split_field]).replace(/[:.[\\],]/g, '_');\n                        }\n                        return this.getElementId(element) + '-statusnode';\n                    }.bind(this);\n                    // Helper function to sum layout values to derive total height for a single interval track\n                    this.getTrackHeight = function () {\n                        return this.layout.track_height + this.layout.track_vertical_spacing + 2 * this.layout.bounding_box_padding;\n                    };\n                    this.tracks = 1;\n                    this.previous_tracks = 1;\n                    // track-number-indexed object with arrays of interval indexes in the dataset\n                    this.interval_track_index = { 1: [] };\n                    // After we've loaded interval data interpret it to assign\n                    // each to a track so that they do not overlap in the view\n                    this.assignTracks = function () {\n                        // Reinitialize some metadata\n                        this.previous_tracks = this.tracks;\n                        this.tracks = 0;\n                        this.interval_track_index = { 1: [] };\n                        this.track_split_field_index = {};\n                        // If splitting tracks by a field's value then do a first pass determine\n                        // a value/track mapping that preserves the order of possible values\n                        if (this.layout.track_split_field && this.layout.split_tracks) {\n                            this.data.map(function (d) {\n                                this.track_split_field_index[d[this.layout.track_split_field]] = null;\n                            }.bind(this));\n                            var index = Object.keys(this.track_split_field_index);\n                            if (this.layout.track_split_order === 'DESC') {\n                                index.reverse();\n                            }\n                            index.forEach(function (val) {\n                                this.track_split_field_index[val] = this.tracks + 1;\n                                this.interval_track_index[this.tracks + 1] = [];\n                                this.tracks++;\n                            }.bind(this));\n                        }\n                        this.data.map(function (d, i) {\n                            // Stash a parent reference on the interval\n                            this.data[i].parent = this;\n                            // Determine display range start and end, based on minimum allowable interval display width,\n                            // bounded by what we can see (range: values in terms of pixels on the screen)\n                            this.data[i].display_range = {\n                                start: this.parent.x_scale(Math.max(d[this.layout.start_field], this.state.start)),\n                                end: this.parent.x_scale(Math.min(d[this.layout.end_field], this.state.end))\n                            };\n                            this.data[i].display_range.width = this.data[i].display_range.end - this.data[i].display_range.start;\n                            // Convert and stash display range values into domain values\n                            // (domain: values in terms of the data set, e.g. megabases)\n                            this.data[i].display_domain = {\n                                start: this.parent.x_scale.invert(this.data[i].display_range.start),\n                                end: this.parent.x_scale.invert(this.data[i].display_range.end)\n                            };\n                            this.data[i].display_domain.width = this.data[i].display_domain.end - this.data[i].display_domain.start;\n                            // If splitting to tracks based on the value of the designated track split field\n                            // then don't bother with collision detection (intervals will be grouped on tracks\n                            // solely by the value of track_split_field)\n                            if (this.layout.track_split_field && this.layout.split_tracks) {\n                                var val = this.data[i][this.layout.track_split_field];\n                                this.data[i].track = this.track_split_field_index[val];\n                                this.interval_track_index[this.data[i].track].push(i);\n                            } else {\n                                // If not splitting to tracks based on a field value then do so based on collision\n                                // detection (as how it's done for genes). Use display range/domain data generated\n                                // above and cast each interval to tracks such that none overlap\n                                this.tracks = 1;\n                                this.data[i].track = null;\n                                var potential_track = 1;\n                                while (this.data[i].track === null) {\n                                    var collision_on_potential_track = false;\n                                    this.interval_track_index[potential_track].map(function (placed_interval) {\n                                        if (!collision_on_potential_track) {\n                                            var min_start = Math.min(placed_interval.display_range.start, this.display_range.start);\n                                            var max_end = Math.max(placed_interval.display_range.end, this.display_range.end);\n                                            if (max_end - min_start < placed_interval.display_range.width + this.display_range.width) {\n                                                collision_on_potential_track = true;\n                                            }\n                                        }\n                                    }.bind(this.data[i]));\n                                    if (!collision_on_potential_track) {\n                                        this.data[i].track = potential_track;\n                                        this.interval_track_index[potential_track].push(this.data[i]);\n                                    } else {\n                                        potential_track++;\n                                        if (potential_track > this.tracks) {\n                                            this.tracks = potential_track;\n                                            this.interval_track_index[potential_track] = [];\n                                        }\n                                    }\n                                }\n                            }\n                        }.bind(this));\n                        return this;\n                    };\n                    // Implement the main render function\n                    this.render = function () {\n                        this.assignTracks();\n                        // Remove any shared highlight nodes and re-render them if we're splitting on tracks\n                        // At most there will only be dozen or so nodes here (one per track) and each time\n                        // we render data we may have new tracks, so wiping/redrawing all is reasonable.\n                        this.svg.group.selectAll('.lz-data_layer-intervals-statusnode.lz-data_layer-intervals-shared').remove();\n                        Object.keys(this.track_split_field_index).forEach(function (key) {\n                            // Make a psuedo-element so that we can generate an id for the shared node\n                            var psuedoElement = {};\n                            psuedoElement[this.layout.track_split_field] = key;\n                            // Insert the shared node\n                            var sharedstatusnode_style = { display: this.layout.split_tracks ? null : 'none' };\n                            this.svg.group.insert('rect', ':first-child').attr('id', this.getElementStatusNodeId(psuedoElement)).attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-shared').attr('rx', this.layout.bounding_box_padding).attr('ry', this.layout.bounding_box_padding).attr('width', this.parent.layout.cliparea.width).attr('height', this.getTrackHeight() - this.layout.track_vertical_spacing).attr('x', 0).attr('y', (this.track_split_field_index[key] - 1) * this.getTrackHeight()).style(sharedstatusnode_style);\n                        }.bind(this));\n                        var width, height, x, y, fill, fill_opacity;\n                        // Render interval groups\n                        var selection = this.svg.group.selectAll('g.lz-data_layer-intervals').data(this.data, function (d) {\n                            return d[this.layout.id_field];\n                        }.bind(this));\n                        selection.enter().append('g').attr('class', 'lz-data_layer-intervals');\n                        selection.attr('id', function (d) {\n                            return this.getElementId(d);\n                        }.bind(this)).each(function (interval) {\n                            var data_layer = interval.parent;\n                            // Render interval status nodes (displayed behind intervals to show highlight\n                            // without needing to modify interval display element(s))\n                            var statusnode_style = { display: data_layer.layout.split_tracks ? 'none' : null };\n                            var statusnodes = d3.select(this).selectAll('rect.lz-data_layer-intervals.lz-data_layer-intervals-statusnode.lz-data_layer-intervals-statusnode-discrete').data([interval], function (d) {\n                                return data_layer.getElementId(d) + '-statusnode';\n                            });\n                            statusnodes.enter().insert('rect', ':first-child').attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-statusnode-discrete');\n                            statusnodes.attr('id', function (d) {\n                                return data_layer.getElementId(d) + '-statusnode';\n                            }).attr('rx', function () {\n                                return data_layer.layout.bounding_box_padding;\n                            }).attr('ry', function () {\n                                return data_layer.layout.bounding_box_padding;\n                            }).style(statusnode_style);\n                            width = function (d) {\n                                return d.display_range.width + 2 * data_layer.layout.bounding_box_padding;\n                            };\n                            height = function () {\n                                return data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing;\n                            };\n                            x = function (d) {\n                                return d.display_range.start - data_layer.layout.bounding_box_padding;\n                            };\n                            y = function (d) {\n                                return (d.track - 1) * data_layer.getTrackHeight();\n                            };\n                            if (data_layer.canTransition()) {\n                                statusnodes.transition().duration(data_layer.layout.transition.duration || 0).ease(data_layer.layout.transition.ease || 'cubic-in-out').attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                            } else {\n                                statusnodes.attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                            }\n                            statusnodes.exit().remove();\n                            // Render primary interval rects\n                            var rects = d3.select(this).selectAll('rect.lz-data_layer-intervals.lz-interval_rect').data([interval], function (d) {\n                                return d[data_layer.layout.id_field] + '_interval_rect';\n                            });\n                            rects.enter().append('rect').attr('class', 'lz-data_layer-intervals lz-interval_rect');\n                            height = data_layer.layout.track_height;\n                            width = function (d) {\n                                return d.display_range.width;\n                            };\n                            x = function (d) {\n                                return d.display_range.start;\n                            };\n                            y = function (d) {\n                                return (d.track - 1) * data_layer.getTrackHeight() + data_layer.layout.bounding_box_padding;\n                            };\n                            fill = function (d) {\n                                return data_layer.resolveScalableParameter(data_layer.layout.color, d);\n                            };\n                            fill_opacity = function (d) {\n                                return data_layer.resolveScalableParameter(data_layer.layout.fill_opacity, d);\n                            };\n                            if (data_layer.canTransition()) {\n                                rects.transition().duration(data_layer.layout.transition.duration || 0).ease(data_layer.layout.transition.ease || 'cubic-in-out').attr('width', width).attr('height', height).attr('x', x).attr('y', y).attr('fill', fill).attr('fill-opacity', fill_opacity);\n                            } else {\n                                rects.attr('width', width).attr('height', height).attr('x', x).attr('y', y).attr('fill', fill).attr('fill-opacity', fill_opacity);\n                            }\n                            rects.exit().remove();\n                            // Render interval click areas\n                            var clickareas = d3.select(this).selectAll('rect.lz-data_layer-intervals.lz-clickarea').data([interval], function (d) {\n                                return d.interval_name + '_clickarea';\n                            });\n                            clickareas.enter().append('rect').attr('class', 'lz-data_layer-intervals lz-clickarea');\n                            clickareas.attr('id', function (d) {\n                                return data_layer.getElementId(d) + '_clickarea';\n                            }).attr('rx', function () {\n                                return data_layer.layout.bounding_box_padding;\n                            }).attr('ry', function () {\n                                return data_layer.layout.bounding_box_padding;\n                            });\n                            width = function (d) {\n                                return d.display_range.width;\n                            };\n                            height = function () {\n                                return data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing;\n                            };\n                            x = function (d) {\n                                return d.display_range.start;\n                            };\n                            y = function (d) {\n                                return (d.track - 1) * data_layer.getTrackHeight();\n                            };\n                            if (data_layer.canTransition()) {\n                                clickareas.transition().duration(data_layer.layout.transition.duration || 0).ease(data_layer.layout.transition.ease || 'cubic-in-out').attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                            } else {\n                                clickareas.attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                            }\n                            // Remove old clickareas as needed\n                            clickareas.exit().remove();\n                            // Apply default event emitters to clickareas\n                            clickareas.on('click', function (element_data) {\n                                element_data.parent.parent.emit('element_clicked', element_data, true);\n                            }.bind(this));\n                            // Apply mouse behaviors to clickareas\n                            data_layer.applyBehaviors(clickareas);\n                        });\n                        // Remove old elements as needed\n                        selection.exit().remove();\n                        // Update the legend axis if the number of ticks changed\n                        if (this.previous_tracks !== this.tracks) {\n                            this.updateSplitTrackAxis();\n                        }\n                        return this;\n                    };\n                    // Reimplement the positionTooltip() method to be interval-specific\n                    this.positionTooltip = function (id) {\n                        if (typeof id != 'string') {\n                            throw new Error('Unable to position tooltip: id is not a string');\n                        }\n                        if (!this.tooltips[id]) {\n                            throw new Error('Unable to position tooltip: id does not point to a valid tooltip');\n                        }\n                        var tooltip = this.tooltips[id];\n                        var arrow_width = 7;\n                        // as defined in the default stylesheet\n                        var stroke_width = 1;\n                        // as defined in the default stylesheet\n                        var page_origin = this.getPageOrigin();\n                        var tooltip_box = tooltip.selector.node().getBoundingClientRect();\n                        var interval_bbox = d3.select('#' + this.getElementStatusNodeId(tooltip.data)).node().getBBox();\n                        var data_layer_height = this.parent.layout.height - (this.parent.layout.margin.top + this.parent.layout.margin.bottom);\n                        var data_layer_width = this.parent.layout.width - (this.parent.layout.margin.left + this.parent.layout.margin.right);\n                        // Position horizontally: attempt to center on the portion of the interval that's visible,\n                        // pad to either side if bumping up against the edge of the data layer\n                        var interval_center_x = (tooltip.data.display_range.start + tooltip.data.display_range.end) / 2 - this.layout.bounding_box_padding / 2;\n                        var offset_right = Math.max(tooltip_box.width / 2 - interval_center_x, 0);\n                        var offset_left = Math.max(tooltip_box.width / 2 + interval_center_x - data_layer_width, 0);\n                        var left = page_origin.x + interval_center_x - tooltip_box.width / 2 - offset_left + offset_right;\n                        var arrow_left = tooltip_box.width / 2 - arrow_width / 2 + offset_left - offset_right;\n                        // Position vertically below the interval unless there's insufficient space\n                        var top, arrow_type, arrow_top;\n                        if (tooltip_box.height + stroke_width + arrow_width > data_layer_height - (interval_bbox.y + interval_bbox.height)) {\n                            top = page_origin.y + interval_bbox.y - (tooltip_box.height + stroke_width + arrow_width);\n                            arrow_type = 'down';\n                            arrow_top = tooltip_box.height - stroke_width;\n                        } else {\n                            top = page_origin.y + interval_bbox.y + interval_bbox.height + stroke_width + arrow_width;\n                            arrow_type = 'up';\n                            arrow_top = 0 - stroke_width - arrow_width;\n                        }\n                        // Apply positions to the main div\n                        tooltip.selector.style('left', left + 'px').style('top', top + 'px');\n                        // Create / update position on arrow connecting tooltip to data\n                        if (!tooltip.arrow) {\n                            tooltip.arrow = tooltip.selector.append('div').style('position', 'absolute');\n                        }\n                        tooltip.arrow.attr('class', 'lz-data_layer-tooltip-arrow_' + arrow_type).style('left', arrow_left + 'px').style('top', arrow_top + 'px');\n                    };\n                    // Redraw split track axis or hide it, and show/hide the legend, as determined\n                    // by current layout parameters and data\n                    this.updateSplitTrackAxis = function () {\n                        var legend_axis = this.layout.track_split_legend_to_y_axis ? 'y' + this.layout.track_split_legend_to_y_axis : false;\n                        if (this.layout.split_tracks) {\n                            var tracks = +this.tracks || 0;\n                            var track_height = +this.layout.track_height || 0;\n                            var track_spacing = 2 * (+this.layout.bounding_box_padding || 0) + (+this.layout.track_vertical_spacing || 0);\n                            var target_height = tracks * track_height + (tracks - 1) * track_spacing;\n                            this.parent.scaleHeightToData(target_height);\n                            if (legend_axis && this.parent.legend) {\n                                this.parent.legend.hide();\n                                this.parent.layout.axes[legend_axis] = {\n                                    render: true,\n                                    ticks: [],\n                                    range: {\n                                        start: target_height - this.layout.track_height / 2,\n                                        end: this.layout.track_height / 2\n                                    }\n                                };\n                                this.layout.legend.forEach(function (element) {\n                                    var key = element[this.layout.track_split_field];\n                                    var track = this.track_split_field_index[key];\n                                    if (track) {\n                                        if (this.layout.track_split_order === 'DESC') {\n                                            track = Math.abs(track - tracks - 1);\n                                        }\n                                        this.parent.layout.axes[legend_axis].ticks.push({\n                                            y: track,\n                                            text: element.label\n                                        });\n                                    }\n                                }.bind(this));\n                                this.layout.y_axis = {\n                                    axis: this.layout.track_split_legend_to_y_axis,\n                                    floor: 1,\n                                    ceiling: tracks\n                                };\n                                this.parent.render();\n                            }\n                            this.parent_plot.positionPanels();\n                        } else {\n                            if (legend_axis && this.parent.legend) {\n                                if (!this.layout.always_hide_legend) {\n                                    this.parent.legend.show();\n                                }\n                                this.parent.layout.axes[legend_axis] = { render: false };\n                                this.parent.render();\n                            }\n                        }\n                        return this;\n                    };\n                    // Method to not only toggle the split tracks boolean but also update\n                    // necessary display values to animate a complete merge/split\n                    this.toggleSplitTracks = function () {\n                        this.layout.split_tracks = !this.layout.split_tracks;\n                        if (this.parent.legend && !this.layout.always_hide_legend) {\n                            this.parent.layout.margin.bottom = 5 + (this.layout.split_tracks ? 0 : this.parent.legend.layout.height + 5);\n                        }\n                        this.render();\n                        this.updateSplitTrackAxis();\n                        return this;\n                    };\n                    return this;\n                });\n                'use strict';\n                /*********************\n * Line Data Layer\n * Implements a standard line plot, representing either a trace or a filled curve.\n * @class\n * @augments LocusZoom.DataLayer\n*/\n                LocusZoom.DataLayers.add('line', function (layout) {\n                    // Define a default layout for this DataLayer type and merge it with the passed argument\n                    /** @member {Object} */\n                    this.DefaultLayout = {\n                        style: {\n                            fill: 'none',\n                            'stroke-width': '2px'\n                        },\n                        interpolate: 'linear',\n                        x_axis: { field: 'x' },\n                        y_axis: {\n                            field: 'y',\n                            axis: 1\n                        },\n                        hitarea_width: 5\n                    };\n                    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n                    // Var for storing mouse events for use in tool tip positioning\n                    /** @member {String} */\n                    this.mouse_event = null;\n                    /**\n     * Var for storing the generated line function itself\n     * @member {d3.svg.line}\n     * */\n                    this.line = null;\n                    /**\n     * The timeout identifier returned by setTimeout\n     * @member {Number}\n     */\n                    this.tooltip_timeout = null;\n                    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n                    LocusZoom.DataLayer.apply(this, arguments);\n                    /**\n     * Helper function to get display and data objects representing\n     *   the x/y coordinates of the current mouse event with respect to the line in terms of the display\n     *   and the interpolated values of the x/y fields with respect to the line\n     * @returns {{display: {x: *, y: null}, data: {}, slope: null}}\n     */\n                    this.getMouseDisplayAndData = function () {\n                        var ret = {\n                            display: {\n                                x: d3.mouse(this.mouse_event)[0],\n                                y: null\n                            },\n                            data: {},\n                            slope: null\n                        };\n                        var x_field = this.layout.x_axis.field;\n                        var y_field = this.layout.y_axis.field;\n                        var x_scale = 'x_scale';\n                        var y_scale = 'y' + this.layout.y_axis.axis + '_scale';\n                        ret.data[x_field] = this.parent[x_scale].invert(ret.display.x);\n                        var bisect = d3.bisector(function (datum) {\n                            return +datum[x_field];\n                        }).left;\n                        var index = bisect(this.data, ret.data[x_field]) - 1;\n                        var startDatum = this.data[index];\n                        var endDatum = this.data[index + 1];\n                        var interpolate = d3.interpolateNumber(+startDatum[y_field], +endDatum[y_field]);\n                        var range = +endDatum[x_field] - +startDatum[x_field];\n                        ret.data[y_field] = interpolate(ret.data[x_field] % range / range);\n                        ret.display.y = this.parent[y_scale](ret.data[y_field]);\n                        if (this.layout.tooltip.x_precision) {\n                            ret.data[x_field] = ret.data[x_field].toPrecision(this.layout.tooltip.x_precision);\n                        }\n                        if (this.layout.tooltip.y_precision) {\n                            ret.data[y_field] = ret.data[y_field].toPrecision(this.layout.tooltip.y_precision);\n                        }\n                        ret.slope = (this.parent[y_scale](endDatum[y_field]) - this.parent[y_scale](startDatum[y_field])) / (this.parent[x_scale](endDatum[x_field]) - this.parent[x_scale](startDatum[x_field]));\n                        return ret;\n                    };\n                    /**\n     * Reimplement the positionTooltip() method to be line-specific\n     * @param {String} id Identify the tooltip to be positioned\n     */\n                    this.positionTooltip = function (id) {\n                        if (typeof id != 'string') {\n                            throw new Error('Unable to position tooltip: id is not a string');\n                        }\n                        if (!this.tooltips[id]) {\n                            throw new Error('Unable to position tooltip: id does not point to a valid tooltip');\n                        }\n                        var tooltip = this.tooltips[id];\n                        var tooltip_box = tooltip.selector.node().getBoundingClientRect();\n                        var arrow_width = 7;\n                        // as defined in the default stylesheet\n                        var border_radius = 6;\n                        // as defined in the default stylesheet\n                        var stroke_width = parseFloat(this.layout.style['stroke-width']) || 1;\n                        var page_origin = this.getPageOrigin();\n                        var data_layer_height = this.parent.layout.height - (this.parent.layout.margin.top + this.parent.layout.margin.bottom);\n                        var data_layer_width = this.parent.layout.width - (this.parent.layout.margin.left + this.parent.layout.margin.right);\n                        var top, left, arrow_top, arrow_left, arrow_type;\n                        // Determine x/y coordinates for display and data\n                        var dd = this.getMouseDisplayAndData();\n                        // If the absolute value of the slope of the line at this point is above 1 (including Infinity)\n                        // then position the tool tip left/right. Otherwise position top/bottom.\n                        if (Math.abs(dd.slope) > 1) {\n                            // Position horizontally on the left or the right depending on which side of the plot the point is on\n                            if (dd.display.x <= this.parent.layout.width / 2) {\n                                left = page_origin.x + dd.display.x + stroke_width + arrow_width + stroke_width;\n                                arrow_type = 'left';\n                                arrow_left = -1 * (arrow_width + stroke_width);\n                            } else {\n                                left = page_origin.x + dd.display.x - tooltip_box.width - stroke_width - arrow_width - stroke_width;\n                                arrow_type = 'right';\n                                arrow_left = tooltip_box.width - stroke_width;\n                            }\n                            // Position vertically centered unless we're at the top or bottom of the plot\n                            if (dd.display.y - tooltip_box.height / 2 <= 0) {\n                                // Too close to the top, push it down\n                                top = page_origin.y + dd.display.y - 1.5 * arrow_width - border_radius;\n                                arrow_top = border_radius;\n                            } else if (dd.display.y + tooltip_box.height / 2 >= data_layer_height) {\n                                // Too close to the bottom, pull it up\n                                top = page_origin.y + dd.display.y + arrow_width + border_radius - tooltip_box.height;\n                                arrow_top = tooltip_box.height - 2 * arrow_width - border_radius;\n                            } else {\n                                // vertically centered\n                                top = page_origin.y + dd.display.y - tooltip_box.height / 2;\n                                arrow_top = tooltip_box.height / 2 - arrow_width;\n                            }\n                        } else {\n                            // Position horizontally: attempt to center on the mouse's x coordinate\n                            // pad to either side if bumping up against the edge of the data layer\n                            var offset_right = Math.max(tooltip_box.width / 2 - dd.display.x, 0);\n                            var offset_left = Math.max(tooltip_box.width / 2 + dd.display.x - data_layer_width, 0);\n                            left = page_origin.x + dd.display.x - tooltip_box.width / 2 - offset_left + offset_right;\n                            var min_arrow_left = arrow_width / 2;\n                            var max_arrow_left = tooltip_box.width - 2.5 * arrow_width;\n                            arrow_left = tooltip_box.width / 2 - arrow_width + offset_left - offset_right;\n                            arrow_left = Math.min(Math.max(arrow_left, min_arrow_left), max_arrow_left);\n                            // Position vertically above the line unless there's insufficient space\n                            if (tooltip_box.height + stroke_width + arrow_width > dd.display.y) {\n                                top = page_origin.y + dd.display.y + stroke_width + arrow_width;\n                                arrow_type = 'up';\n                                arrow_top = 0 - stroke_width - arrow_width;\n                            } else {\n                                top = page_origin.y + dd.display.y - (tooltip_box.height + stroke_width + arrow_width);\n                                arrow_type = 'down';\n                                arrow_top = tooltip_box.height - stroke_width;\n                            }\n                        }\n                        // Apply positions to the main div\n                        tooltip.selector.style({\n                            left: left + 'px',\n                            top: top + 'px'\n                        });\n                        // Create / update position on arrow connecting tooltip to data\n                        if (!tooltip.arrow) {\n                            tooltip.arrow = tooltip.selector.append('div').style('position', 'absolute');\n                        }\n                        tooltip.arrow.attr('class', 'lz-data_layer-tooltip-arrow_' + arrow_type).style({\n                            'left': arrow_left + 'px',\n                            top: arrow_top + 'px'\n                        });\n                    };\n                    /**\n     * Implement the main render function\n     */\n                    this.render = function () {\n                        // Several vars needed to be in scope\n                        var data_layer = this;\n                        var panel = this.parent;\n                        var x_field = this.layout.x_axis.field;\n                        var y_field = this.layout.y_axis.field;\n                        var x_scale = 'x_scale';\n                        var y_scale = 'y' + this.layout.y_axis.axis + '_scale';\n                        // Join data to the line selection\n                        var selection = this.svg.group.selectAll('path.lz-data_layer-line').data([this.data]);\n                        // Create path element, apply class\n                        this.path = selection.enter().append('path').attr('class', 'lz-data_layer-line');\n                        // Generate the line\n                        if (this.layout.style.fill && this.layout.style.fill !== 'none') {\n                            // Filled curve: define the line as a filled boundary\n                            this.line = d3.svg.area().x(function (d) {\n                                return parseFloat(panel[x_scale](d[x_field]));\n                            }).y0(function (d) {\n                                return parseFloat(panel[y_scale](0));\n                            }).y1(function (d) {\n                                return parseFloat(panel[y_scale](d[y_field]));\n                            });\n                        } else {\n                            // Basic line\n                            this.line = d3.svg.line().x(function (d) {\n                                return parseFloat(panel[x_scale](d[x_field]));\n                            }).y(function (d) {\n                                return parseFloat(panel[y_scale](d[y_field]));\n                            }).interpolate(this.layout.interpolate);\n                        }\n                        // Apply line and style\n                        if (this.canTransition()) {\n                            selection.transition().duration(this.layout.transition.duration || 0).ease(this.layout.transition.ease || 'cubic-in-out').attr('d', this.line).style(this.layout.style);\n                        } else {\n                            selection.attr('d', this.line).style(this.layout.style);\n                        }\n                        // Apply tooltip, etc\n                        if (this.layout.tooltip) {\n                            // Generate an overlaying transparent \"hit area\" line for more intuitive mouse events\n                            var hitarea_width = parseFloat(this.layout.hitarea_width).toString() + 'px';\n                            var hitarea = this.svg.group.selectAll('path.lz-data_layer-line-hitarea').data([this.data]);\n                            hitarea.enter().append('path').attr('class', 'lz-data_layer-line-hitarea').style('stroke-width', hitarea_width);\n                            var hitarea_line = d3.svg.line().x(function (d) {\n                                return parseFloat(panel[x_scale](d[x_field]));\n                            }).y(function (d) {\n                                return parseFloat(panel[y_scale](d[y_field]));\n                            }).interpolate(this.layout.interpolate);\n                            hitarea.attr('d', hitarea_line).on('mouseover', function () {\n                                clearTimeout(data_layer.tooltip_timeout);\n                                data_layer.mouse_event = this;\n                                var dd = data_layer.getMouseDisplayAndData();\n                                data_layer.createTooltip(dd.data);\n                            }).on('mousemove', function () {\n                                clearTimeout(data_layer.tooltip_timeout);\n                                data_layer.mouse_event = this;\n                                var dd = data_layer.getMouseDisplayAndData();\n                                data_layer.updateTooltip(dd.data);\n                                data_layer.positionTooltip(data_layer.getElementId());\n                            }).on('mouseout', function () {\n                                data_layer.tooltip_timeout = setTimeout(function () {\n                                    data_layer.mouse_event = null;\n                                    data_layer.destroyTooltip(data_layer.getElementId());\n                                }, 300);\n                            });\n                            hitarea.exit().remove();\n                        }\n                        // Remove old elements as needed\n                        selection.exit().remove();\n                    };\n                    /**\n     * Redefine setElementStatus family of methods as line data layers will only ever have a single path element\n     * @param {String} status A member of `LocusZoom.DataLayer.Statuses.adjectives`\n     * @param {String|Object} element\n     * @param {Boolean} toggle\n     * @returns {LocusZoom.DataLayer}\n     */\n                    this.setElementStatus = function (status, element, toggle) {\n                        return this.setAllElementStatus(status, toggle);\n                    };\n                    this.setElementStatusByFilters = function (status, toggle) {\n                        return this.setAllElementStatus(status, toggle);\n                    };\n                    this.setAllElementStatus = function (status, toggle) {\n                        // Sanity check\n                        if (typeof status == 'undefined' || LocusZoom.DataLayer.Statuses.adjectives.indexOf(status) === -1) {\n                            throw new Error('Invalid status passed to DataLayer.setAllElementStatus()');\n                        }\n                        if (typeof this.state[this.state_id][status] == 'undefined') {\n                            return this;\n                        }\n                        if (typeof toggle == 'undefined') {\n                            toggle = true;\n                        }\n                        // Update global status flag\n                        this.global_statuses[status] = toggle;\n                        // Apply class to path based on global status flags\n                        var path_class = 'lz-data_layer-line';\n                        Object.keys(this.global_statuses).forEach(function (global_status) {\n                            if (this.global_statuses[global_status]) {\n                                path_class += ' lz-data_layer-line-' + global_status;\n                            }\n                        }.bind(this));\n                        this.path.attr('class', path_class);\n                        // Trigger layout changed event hook\n                        this.parent.emit('layout_changed', true);\n                        return this;\n                    };\n                    return this;\n                });\n                /***************************\n *  Orthogonal Line Data Layer\n *  Implements a horizontal or vertical line given an orientation and an offset in the layout\n *  Does not require a data source\n * @class\n * @augments LocusZoom.DataLayer\n*/\n                LocusZoom.DataLayers.add('orthogonal_line', function (layout) {\n                    // Define a default layout for this DataLayer type and merge it with the passed argument\n                    this.DefaultLayout = {\n                        style: {\n                            'stroke': '#D3D3D3',\n                            'stroke-width': '3px',\n                            'stroke-dasharray': '10px 10px'\n                        },\n                        orientation: 'horizontal',\n                        x_axis: {\n                            axis: 1,\n                            decoupled: true\n                        },\n                        y_axis: {\n                            axis: 1,\n                            decoupled: true\n                        },\n                        offset: 0\n                    };\n                    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n                    // Require that orientation be \"horizontal\" or \"vertical\" only\n                    if ([\n                            'horizontal',\n                            'vertical'\n                        ].indexOf(layout.orientation) === -1) {\n                        layout.orientation = 'horizontal';\n                    }\n                    // Vars for storing the data generated line\n                    /** @member {Array} */\n                    this.data = [];\n                    /** @member {d3.svg.line} */\n                    this.line = null;\n                    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n                    LocusZoom.DataLayer.apply(this, arguments);\n                    /**\n     * Implement the main render function\n     */\n                    this.render = function () {\n                        // Several vars needed to be in scope\n                        var panel = this.parent;\n                        var x_scale = 'x_scale';\n                        var y_scale = 'y' + this.layout.y_axis.axis + '_scale';\n                        var x_extent = 'x_extent';\n                        var y_extent = 'y' + this.layout.y_axis.axis + '_extent';\n                        var x_range = 'x_range';\n                        var y_range = 'y' + this.layout.y_axis.axis + '_range';\n                        // Generate data using extents depending on orientation\n                        if (this.layout.orientation === 'horizontal') {\n                            this.data = [\n                                {\n                                    x: panel[x_extent][0],\n                                    y: this.layout.offset\n                                },\n                                {\n                                    x: panel[x_extent][1],\n                                    y: this.layout.offset\n                                }\n                            ];\n                        } else {\n                            this.data = [\n                                {\n                                    x: this.layout.offset,\n                                    y: panel[y_extent][0]\n                                },\n                                {\n                                    x: this.layout.offset,\n                                    y: panel[y_extent][1]\n                                }\n                            ];\n                        }\n                        // Join data to the line selection\n                        var selection = this.svg.group.selectAll('path.lz-data_layer-line').data([this.data]);\n                        // Create path element, apply class\n                        this.path = selection.enter().append('path').attr('class', 'lz-data_layer-line');\n                        // Generate the line\n                        this.line = d3.svg.line().x(function (d, i) {\n                            var x = parseFloat(panel[x_scale](d['x']));\n                            return isNaN(x) ? panel[x_range][i] : x;\n                        }).y(function (d, i) {\n                            var y = parseFloat(panel[y_scale](d['y']));\n                            return isNaN(y) ? panel[y_range][i] : y;\n                        }).interpolate('linear');\n                        // Apply line and style\n                        if (this.canTransition()) {\n                            selection.transition().duration(this.layout.transition.duration || 0).ease(this.layout.transition.ease || 'cubic-in-out').attr('d', this.line).style(this.layout.style);\n                        } else {\n                            selection.attr('d', this.line).style(this.layout.style);\n                        }\n                        // Remove old elements as needed\n                        selection.exit().remove();\n                    };\n                    return this;\n                });\n                'use strict';\n                /**\n * Scatter Data Layer\n * Implements a standard scatter plot\n * @class LocusZoom.DataLayers.scatter\n */\n                LocusZoom.DataLayers.add('scatter', function (layout) {\n                    // Define a default layout for this DataLayer type and merge it with the passed argument\n                    this.DefaultLayout = {\n                        point_size: 40,\n                        point_shape: 'circle',\n                        tooltip_positioning: 'horizontal',\n                        color: '#888888',\n                        fill_opacity: 1,\n                        y_axis: { axis: 1 },\n                        id_field: 'id'\n                    };\n                    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n                    // Extra default for layout spacing\n                    // Not in default layout since that would make the label attribute always present\n                    if (layout.label && isNaN(layout.label.spacing)) {\n                        layout.label.spacing = 4;\n                    }\n                    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n                    LocusZoom.DataLayer.apply(this, arguments);\n                    // Reimplement the positionTooltip() method to be scatter-specific\n                    this.positionTooltip = function (id) {\n                        if (typeof id != 'string') {\n                            throw new Error('Unable to position tooltip: id is not a string');\n                        }\n                        if (!this.tooltips[id]) {\n                            throw new Error('Unable to position tooltip: id does not point to a valid tooltip');\n                        }\n                        var top, left, arrow_type, arrow_top, arrow_left;\n                        var tooltip = this.tooltips[id];\n                        var point_size = this.resolveScalableParameter(this.layout.point_size, tooltip.data);\n                        var offset = Math.sqrt(point_size / Math.PI);\n                        var arrow_width = 7;\n                        // as defined in the default stylesheet\n                        var stroke_width = 1;\n                        // as defined in the default stylesheet\n                        var border_radius = 6;\n                        // as defined in the default stylesheet\n                        var page_origin = this.getPageOrigin();\n                        var x_center = this.parent.x_scale(tooltip.data[this.layout.x_axis.field]);\n                        var y_scale = 'y' + this.layout.y_axis.axis + '_scale';\n                        var y_center = this.parent[y_scale](tooltip.data[this.layout.y_axis.field]);\n                        var tooltip_box = tooltip.selector.node().getBoundingClientRect();\n                        var data_layer_height = this.parent.layout.height - (this.parent.layout.margin.top + this.parent.layout.margin.bottom);\n                        var data_layer_width = this.parent.layout.width - (this.parent.layout.margin.left + this.parent.layout.margin.right);\n                        if (this.layout.tooltip_positioning === 'vertical') {\n                            // Position horizontally centered above the point\n                            var offset_right = Math.max(tooltip_box.width / 2 - x_center, 0);\n                            var offset_left = Math.max(tooltip_box.width / 2 + x_center - data_layer_width, 0);\n                            left = page_origin.x + x_center - tooltip_box.width / 2 - offset_left + offset_right;\n                            arrow_left = tooltip_box.width / 2 - arrow_width / 2 + offset_left - offset_right - offset;\n                            // Position vertically above the point unless there's insufficient space, then go below\n                            if (tooltip_box.height + stroke_width + arrow_width > data_layer_height - (y_center + offset)) {\n                                top = page_origin.y + y_center - (offset + tooltip_box.height + stroke_width + arrow_width);\n                                arrow_type = 'down';\n                                arrow_top = tooltip_box.height - stroke_width;\n                            } else {\n                                top = page_origin.y + y_center + offset + stroke_width + arrow_width;\n                                arrow_type = 'up';\n                                arrow_top = 0 - stroke_width - arrow_width;\n                            }\n                        } else {\n                            // Position horizontally on the left or the right depending on which side of the plot the point is on\n                            if (x_center <= this.parent.layout.width / 2) {\n                                left = page_origin.x + x_center + offset + arrow_width + stroke_width;\n                                arrow_type = 'left';\n                                arrow_left = -1 * (arrow_width + stroke_width);\n                            } else {\n                                left = page_origin.x + x_center - tooltip_box.width - offset - arrow_width - stroke_width;\n                                arrow_type = 'right';\n                                arrow_left = tooltip_box.width - stroke_width;\n                            }\n                            // Position vertically centered unless we're at the top or bottom of the plot\n                            data_layer_height = this.parent.layout.height - (this.parent.layout.margin.top + this.parent.layout.margin.bottom);\n                            if (y_center - tooltip_box.height / 2 <= 0) {\n                                // Too close to the top, push it down\n                                top = page_origin.y + y_center - 1.5 * arrow_width - border_radius;\n                                arrow_top = border_radius;\n                            } else if (y_center + tooltip_box.height / 2 >= data_layer_height) {\n                                // Too close to the bottom, pull it up\n                                top = page_origin.y + y_center + arrow_width + border_radius - tooltip_box.height;\n                                arrow_top = tooltip_box.height - 2 * arrow_width - border_radius;\n                            } else {\n                                // vertically centered\n                                top = page_origin.y + y_center - tooltip_box.height / 2;\n                                arrow_top = tooltip_box.height / 2 - arrow_width;\n                            }\n                        }\n                        // Apply positions to the main div\n                        tooltip.selector.style('left', left + 'px').style('top', top + 'px');\n                        // Create / update position on arrow connecting tooltip to data\n                        if (!tooltip.arrow) {\n                            tooltip.arrow = tooltip.selector.append('div').style('position', 'absolute');\n                        }\n                        tooltip.arrow.attr('class', 'lz-data_layer-tooltip-arrow_' + arrow_type).style('left', arrow_left + 'px').style('top', arrow_top + 'px');\n                    };\n                    // Function to flip labels from being anchored at the start of the text to the end\n                    // Both to keep labels from running outside the data layer and  also as a first\n                    // pass on recursive separation\n                    this.flip_labels = function () {\n                        var data_layer = this;\n                        var point_size = data_layer.resolveScalableParameter(data_layer.layout.point_size, {});\n                        var spacing = data_layer.layout.label.spacing;\n                        var handle_lines = Boolean(data_layer.layout.label.lines);\n                        var min_x = 2 * spacing;\n                        var max_x = data_layer.parent.layout.width - data_layer.parent.layout.margin.left - data_layer.parent.layout.margin.right - 2 * spacing;\n                        var flip = function (dn, dnl) {\n                            var dnx = +dn.attr('x');\n                            var text_swing = 2 * spacing + 2 * Math.sqrt(point_size);\n                            if (handle_lines) {\n                                var dnlx2 = +dnl.attr('x2');\n                                var line_swing = spacing + 2 * Math.sqrt(point_size);\n                            }\n                            if (dn.style('text-anchor') === 'start') {\n                                dn.style('text-anchor', 'end');\n                                dn.attr('x', dnx - text_swing);\n                                if (handle_lines) {\n                                    dnl.attr('x2', dnlx2 - line_swing);\n                                }\n                            } else {\n                                dn.style('text-anchor', 'start');\n                                dn.attr('x', dnx + text_swing);\n                                if (handle_lines) {\n                                    dnl.attr('x2', dnlx2 + line_swing);\n                                }\n                            }\n                        };\n                        // Flip any going over the right edge from the right side to the left side\n                        // (all labels start on the right side)\n                        data_layer.label_texts.each(function (d, i) {\n                            var a = this;\n                            var da = d3.select(a);\n                            var dax = +da.attr('x');\n                            var abound = da.node().getBoundingClientRect();\n                            if (dax + abound.width + spacing > max_x) {\n                                var dal = handle_lines ? d3.select(data_layer.label_lines[0][i]) : null;\n                                flip(da, dal);\n                            }\n                        });\n                        // Second pass to flip any others that haven't flipped yet if they collide with another label\n                        data_layer.label_texts.each(function (d, i) {\n                            var a = this;\n                            var da = d3.select(a);\n                            if (da.style('text-anchor') === 'end') {\n                                return;\n                            }\n                            var dax = +da.attr('x');\n                            var abound = da.node().getBoundingClientRect();\n                            var dal = handle_lines ? d3.select(data_layer.label_lines[0][i]) : null;\n                            data_layer.label_texts.each(function () {\n                                var b = this;\n                                var db = d3.select(b);\n                                var bbound = db.node().getBoundingClientRect();\n                                var collision = abound.left < bbound.left + bbound.width + 2 * spacing && abound.left + abound.width + 2 * spacing > bbound.left && abound.top < bbound.top + bbound.height + 2 * spacing && abound.height + abound.top + 2 * spacing > bbound.top;\n                                if (collision) {\n                                    flip(da, dal);\n                                    // Double check that this flip didn't push the label past min_x. If it did, immediately flip back.\n                                    dax = +da.attr('x');\n                                    if (dax - abound.width - spacing < min_x) {\n                                        flip(da, dal);\n                                    }\n                                }\n                                return;\n                            });\n                        });\n                    };\n                    // Recursive function to space labels apart immediately after initial render\n                    // Adapted from thudfactor's fiddle here: https://jsfiddle.net/thudfactor/HdwTH/\n                    // TODO: Make labels also aware of data elements\n                    this.separate_labels = function () {\n                        this.seperate_iterations++;\n                        var data_layer = this;\n                        var alpha = 0.5;\n                        if (!this.layout.label) {\n                            // Guard against layout changing in the midst of iterative rerender\n                            return;\n                        }\n                        var spacing = this.layout.label.spacing;\n                        var again = false;\n                        data_layer.label_texts.each(function () {\n                            var a = this;\n                            var da = d3.select(a);\n                            var y1 = da.attr('y');\n                            data_layer.label_texts.each(function () {\n                                var b = this;\n                                // a & b are the same element and don't collide.\n                                if (a === b) {\n                                    return;\n                                }\n                                var db = d3.select(b);\n                                // a & b are on opposite sides of the chart and\n                                // don't collide\n                                if (da.attr('text-anchor') !== db.attr('text-anchor')) {\n                                    return;\n                                }\n                                // Determine if the  bounding rects for the two text elements collide\n                                var abound = da.node().getBoundingClientRect();\n                                var bbound = db.node().getBoundingClientRect();\n                                var collision = abound.left < bbound.left + bbound.width + 2 * spacing && abound.left + abound.width + 2 * spacing > bbound.left && abound.top < bbound.top + bbound.height + 2 * spacing && abound.height + abound.top + 2 * spacing > bbound.top;\n                                if (!collision) {\n                                    return;\n                                }\n                                again = true;\n                                // If the labels collide, we'll push each\n                                // of the two labels up and down a little bit.\n                                var y2 = db.attr('y');\n                                var sign = abound.top < bbound.top ? 1 : -1;\n                                var adjust = sign * alpha;\n                                var new_a_y = +y1 - adjust;\n                                var new_b_y = +y2 + adjust;\n                                // Keep new values from extending outside the data layer\n                                var min_y = 2 * spacing;\n                                var max_y = data_layer.parent.layout.height - data_layer.parent.layout.margin.top - data_layer.parent.layout.margin.bottom - 2 * spacing;\n                                var delta;\n                                if (new_a_y - abound.height / 2 < min_y) {\n                                    delta = +y1 - new_a_y;\n                                    new_a_y = +y1;\n                                    new_b_y += delta;\n                                } else if (new_b_y - bbound.height / 2 < min_y) {\n                                    delta = +y2 - new_b_y;\n                                    new_b_y = +y2;\n                                    new_a_y += delta;\n                                }\n                                if (new_a_y + abound.height / 2 > max_y) {\n                                    delta = new_a_y - +y1;\n                                    new_a_y = +y1;\n                                    new_b_y -= delta;\n                                } else if (new_b_y + bbound.height / 2 > max_y) {\n                                    delta = new_b_y - +y2;\n                                    new_b_y = +y2;\n                                    new_a_y -= delta;\n                                }\n                                da.attr('y', new_a_y);\n                                db.attr('y', new_b_y);\n                            });\n                        });\n                        if (again) {\n                            // Adjust lines to follow the labels\n                            if (data_layer.layout.label.lines) {\n                                var label_elements = data_layer.label_texts[0];\n                                data_layer.label_lines.attr('y2', function (d, i) {\n                                    var label_line = d3.select(label_elements[i]);\n                                    return label_line.attr('y');\n                                });\n                            }\n                            // After ~150 iterations we're probably beyond diminising returns, so stop recursing\n                            if (this.seperate_iterations < 150) {\n                                setTimeout(function () {\n                                    this.separate_labels();\n                                }.bind(this), 1);\n                            }\n                        }\n                    };\n                    // Implement the main render function\n                    this.render = function () {\n                        var data_layer = this;\n                        var x_scale = 'x_scale';\n                        var y_scale = 'y' + this.layout.y_axis.axis + '_scale';\n                        if (this.layout.label) {\n                            // Apply filters to generate a filtered data set\n                            var filtered_data = this.data.filter(function (d) {\n                                if (!data_layer.layout.label.filters) {\n                                    return true;\n                                } else {\n                                    // Start by assuming a match, run through all filters to test if not a match on any one\n                                    var match = true;\n                                    data_layer.layout.label.filters.forEach(function (filter) {\n                                        var field_value = new LocusZoom.Data.Field(filter.field).resolve(d);\n                                        if ([\n                                                '!=',\n                                                '='\n                                            ].indexOf(filter.operator) === -1 && isNaN(field_value)) {\n                                            // If the filter can only be used with numbers, then the value must be numeric.\n                                            match = false;\n                                        } else {\n                                            switch (filter.operator) {\n                                            case '<':\n                                                if (!(field_value < filter.value)) {\n                                                    match = false;\n                                                }\n                                                break;\n                                            case '<=':\n                                                if (!(field_value <= filter.value)) {\n                                                    match = false;\n                                                }\n                                                break;\n                                            case '>':\n                                                if (!(field_value > filter.value)) {\n                                                    match = false;\n                                                }\n                                                break;\n                                            case '>=':\n                                                if (!(field_value >= filter.value)) {\n                                                    match = false;\n                                                }\n                                                break;\n                                            case '=':\n                                                if (!(field_value === filter.value)) {\n                                                    match = false;\n                                                }\n                                                break;\n                                            case '!=':\n                                                // Deliberately allow weak comparisons to test for \"anything with a value present\" (null or undefined)\n                                                // eslint-disable-next-line eqeqeq\n                                                if (field_value == filter.value) {\n                                                    match = false;\n                                                }\n                                                break;\n                                            default:\n                                                // If we got here the operator is not valid, so the filter should fail\n                                                match = false;\n                                                break;\n                                            }\n                                        }\n                                    });\n                                    return match;\n                                }\n                            });\n                            // Render label groups\n                            var self = this;\n                            this.label_groups = this.svg.group.selectAll('g.lz-data_layer-' + this.layout.type + '-label').data(filtered_data, function (d) {\n                                return d[self.layout.id_field] + '_label';\n                            });\n                            this.label_groups.enter().append('g').attr('class', 'lz-data_layer-' + this.layout.type + '-label');\n                            // Render label texts\n                            if (this.label_texts) {\n                                this.label_texts.remove();\n                            }\n                            this.label_texts = this.label_groups.append('text').attr('class', 'lz-data_layer-' + this.layout.type + '-label');\n                            this.label_texts.text(function (d) {\n                                return LocusZoom.parseFields(d, data_layer.layout.label.text || '');\n                            }).style(data_layer.layout.label.style || {}).attr({\n                                'x': function (d) {\n                                    var x = data_layer.parent[x_scale](d[data_layer.layout.x_axis.field]) + Math.sqrt(data_layer.resolveScalableParameter(data_layer.layout.point_size, d)) + data_layer.layout.label.spacing;\n                                    if (isNaN(x)) {\n                                        x = -1000;\n                                    }\n                                    return x;\n                                },\n                                'y': function (d) {\n                                    var y = data_layer.parent[y_scale](d[data_layer.layout.y_axis.field]);\n                                    if (isNaN(y)) {\n                                        y = -1000;\n                                    }\n                                    return y;\n                                },\n                                'text-anchor': function () {\n                                    return 'start';\n                                }\n                            });\n                            // Render label lines\n                            if (data_layer.layout.label.lines) {\n                                if (this.label_lines) {\n                                    this.label_lines.remove();\n                                }\n                                this.label_lines = this.label_groups.append('line').attr('class', 'lz-data_layer-' + this.layout.type + '-label');\n                                this.label_lines.style(data_layer.layout.label.lines.style || {}).attr({\n                                    'x1': function (d) {\n                                        var x = data_layer.parent[x_scale](d[data_layer.layout.x_axis.field]);\n                                        if (isNaN(x)) {\n                                            x = -1000;\n                                        }\n                                        return x;\n                                    },\n                                    'y1': function (d) {\n                                        var y = data_layer.parent[y_scale](d[data_layer.layout.y_axis.field]);\n                                        if (isNaN(y)) {\n                                            y = -1000;\n                                        }\n                                        return y;\n                                    },\n                                    'x2': function (d) {\n                                        var x = data_layer.parent[x_scale](d[data_layer.layout.x_axis.field]) + Math.sqrt(data_layer.resolveScalableParameter(data_layer.layout.point_size, d)) + data_layer.layout.label.spacing / 2;\n                                        if (isNaN(x)) {\n                                            x = -1000;\n                                        }\n                                        return x;\n                                    },\n                                    'y2': function (d) {\n                                        var y = data_layer.parent[y_scale](d[data_layer.layout.y_axis.field]);\n                                        if (isNaN(y)) {\n                                            y = -1000;\n                                        }\n                                        return y;\n                                    }\n                                });\n                            }\n                            // Remove labels when they're no longer in the filtered data set\n                            this.label_groups.exit().remove();\n                        } else {\n                            // If the layout definition has changed (& no longer specifies labels), strip any previously rendered\n                            if (this.label_groups) {\n                                this.label_groups.remove();\n                            }\n                            if (this.label_lines) {\n                                this.label_lines.remove();\n                            }\n                        }\n                        // Generate main scatter data elements\n                        var selection = this.svg.group.selectAll('path.lz-data_layer-' + this.layout.type).data(this.data, function (d) {\n                            return d[this.layout.id_field];\n                        }.bind(this));\n                        // Create elements, apply class, ID, and initial position\n                        var initial_y = isNaN(this.parent.layout.height) ? 0 : this.parent.layout.height;\n                        selection.enter().append('path').attr('class', 'lz-data_layer-' + this.layout.type).attr('id', function (d) {\n                            return this.getElementId(d);\n                        }.bind(this)).attr('transform', 'translate(0,' + initial_y + ')');\n                        // Generate new values (or functions for them) for position, color, size, and shape\n                        var transform = function (d) {\n                            var x = this.parent[x_scale](d[this.layout.x_axis.field]);\n                            var y = this.parent[y_scale](d[this.layout.y_axis.field]);\n                            if (isNaN(x)) {\n                                x = -1000;\n                            }\n                            if (isNaN(y)) {\n                                y = -1000;\n                            }\n                            return 'translate(' + x + ',' + y + ')';\n                        }.bind(this);\n                        var fill = function (d) {\n                            return this.resolveScalableParameter(this.layout.color, d);\n                        }.bind(this);\n                        var fill_opacity = function (d) {\n                            return this.resolveScalableParameter(this.layout.fill_opacity, d);\n                        }.bind(this);\n                        var shape = d3.svg.symbol().size(function (d) {\n                            return this.resolveScalableParameter(this.layout.point_size, d);\n                        }.bind(this)).type(function (d) {\n                            return this.resolveScalableParameter(this.layout.point_shape, d);\n                        }.bind(this));\n                        // Apply position and color, using a transition if necessary\n                        if (this.canTransition()) {\n                            selection.transition().duration(this.layout.transition.duration || 0).ease(this.layout.transition.ease || 'cubic-in-out').attr('transform', transform).attr('fill', fill).attr('fill-opacity', fill_opacity).attr('d', shape);\n                        } else {\n                            selection.attr('transform', transform).attr('fill', fill).attr('fill-opacity', fill_opacity).attr('d', shape);\n                        }\n                        // Remove old elements as needed\n                        selection.exit().remove();\n                        // Apply default event emitters to selection\n                        selection.on('click.event_emitter', function (element) {\n                            this.parent.emit('element_clicked', element, true);\n                        }.bind(this));\n                        // Apply mouse behaviors\n                        this.applyBehaviors(selection);\n                        // Apply method to keep labels from overlapping each other\n                        if (this.layout.label) {\n                            this.flip_labels();\n                            this.seperate_iterations = 0;\n                            this.separate_labels();\n                            // Apply default event emitters to selection\n                            this.label_texts.on('click.event_emitter', function (element) {\n                                this.parent.emit('element_clicked', element, true);\n                            }.bind(this));\n                            // Extend mouse behaviors to labels\n                            this.applyBehaviors(this.label_texts);\n                        }\n                    };\n                    // Method to set a passed element as the LD reference in the plot-level state\n                    this.makeLDReference = function (element) {\n                        var ref = null;\n                        if (typeof element == 'undefined') {\n                            throw new Error('makeLDReference requires one argument of any type');\n                        } else if (typeof element == 'object') {\n                            if (this.layout.id_field && typeof element[this.layout.id_field] != 'undefined') {\n                                ref = element[this.layout.id_field].toString();\n                            } else if (typeof element['id'] != 'undefined') {\n                                ref = element['id'].toString();\n                            } else {\n                                ref = element.toString();\n                            }\n                        } else {\n                            ref = element.toString();\n                        }\n                        this.parent_plot.applyState({ ldrefvar: ref });\n                    };\n                    return this;\n                });\n                /**\n * A scatter plot in which the x-axis represents categories, rather than individual positions.\n * For example, this can be used by PheWAS plots to show related groups. This plot allows the categories to be\n *   determined dynamically when data is first loaded.\n *\n * @class LocusZoom.DataLayers.category_scatter\n * @augments LocusZoom.DataLayers.scatter\n */\n                LocusZoom.DataLayers.extend('scatter', 'category_scatter', {\n                    /**\n     * This plot layer makes certain assumptions about the data passed in. Transform the raw array of records from\n     *   the datasource to prepare it for plotting, as follows:\n     * 1. The scatter plot assumes that all records are given in sequence (pre-grouped by `category_field`)\n     * 2. It assumes that all records have an x coordinate for individual plotting\n     * @private\n     */\n                    _prepareData: function () {\n                        var xField = this.layout.x_axis.field || 'x';\n                        // The (namespaced) field from `this.data` that will be used to assign datapoints to a given category & color\n                        var category_field = this.layout.x_axis.category_field;\n                        if (!category_field) {\n                            throw new Error('Layout for ' + this.layout.id + ' must specify category_field');\n                        }\n                        // Sort the data so that things in the same category are adjacent (case-insensitive by specified field)\n                        var sourceData = this.data.sort(function (a, b) {\n                            var ak = a[category_field];\n                            var bk = b[category_field];\n                            var av = ak.toString ? ak.toString().toLowerCase() : ak;\n                            var bv = bk.toString ? bk.toString().toLowerCase() : bk;\n                            return av === bv ? 0 : av < bv ? -1 : 1;\n                        });\n                        sourceData.forEach(function (d, i) {\n                            // Implementation detail: Scatter plot requires specifying an x-axis value, and most datasources do not\n                            //   specify plotting positions. If a point is missing this field, fill in a synthetic value.\n                            d[xField] = d[xField] || i;\n                        });\n                        return sourceData;\n                    },\n                    /**\n     * Identify the unique categories on the plot, and update the layout with an appropriate color scheme.\n     * Also identify the min and max x value associated with the category, which will be used to generate ticks\n     * @private\n     * @returns {Object.<String, Number[]>} Series of entries used to build category name ticks {category_name: [min_x, max_x]}\n     */\n                    _generateCategoryBounds: function () {\n                        // TODO: API may return null values in category_field; should we add placeholder category label?\n                        // The (namespaced) field from `this.data` that will be used to assign datapoints to a given category & color\n                        var category_field = this.layout.x_axis.category_field;\n                        var xField = this.layout.x_axis.field || 'x';\n                        var uniqueCategories = {};\n                        this.data.forEach(function (item) {\n                            var category = item[category_field];\n                            var x = item[xField];\n                            var bounds = uniqueCategories[category] || [\n                                x,\n                                x\n                            ];\n                            uniqueCategories[category] = [\n                                Math.min(bounds[0], x),\n                                Math.max(bounds[1], x)\n                            ];\n                        });\n                        var categoryNames = Object.keys(uniqueCategories);\n                        this._setDynamicColorScheme(categoryNames);\n                        return uniqueCategories;\n                    },\n                    /**\n     * This layer relies on defining its own category-based color scheme. Find the correct color config object to\n     *  be modified.\n     * @param [from_source]\n     * @returns {Object} A mutable reference to the layout configuration object\n     * @private\n     */\n                    _getColorScale: function (from_source) {\n                        from_source = from_source || this.layout;\n                        // If the layout does not use a supported coloring scheme, or is already complete, this method should do nothing\n                        // For legacy reasons, layouts can specify color as an object (only one way to set color), as opposed to the\n                        //  preferred mechanism of array (multiple coloring options)\n                        var color_params = from_source.color || [];\n                        // Object or scalar, no other options allowed\n                        if (Array.isArray(color_params)) {\n                            color_params = color_params.find(function (item) {\n                                return item.scale_function === 'categorical_bin';\n                            });\n                        }\n                        if (!color_params || color_params.scale_function !== 'categorical_bin') {\n                            throw new Error('This layer requires that color options be provided as a `categorical_bin`');\n                        }\n                        return color_params;\n                    },\n                    /**\n     * Automatically define a color scheme for the layer based on data returned from the server.\n     *   If part of the color scheme has been specified, it will fill in remaining missing information.\n     *\n     * There are three scenarios:\n     * 1. The layout does not specify either category names or (color) values. Dynamically build both based on\n     *    the data and update the layout.\n     * 2. The layout specifies colors, but not categories. Use that exact color information provided, and dynamically\n     *     determine what categories are present in the data. (cycle through the available colors, reusing if there\n     *     are a lot of categories)\n     * 3. The layout specifies exactly what colors and categories to use (and they match the data!). This is useful to\n     *    specify an explicit mapping between color scheme and category names, when you want to be sure that the\n     *    plot matches a standard color scheme.\n     *    (If the layout specifies categories that do not match the data, the user specified categories will be ignored)\n     *\n     * This method will only act if the layout defines a `categorical_bin` scale function for coloring. It may be\n     *   overridden in a subclass to suit other types of coloring methods.\n     *\n     * @param {String[]} categoryNames\n     * @private\n     */\n                    _setDynamicColorScheme: function (categoryNames) {\n                        var colorParams = this._getColorScale(this.layout).parameters;\n                        var baseParams = this._getColorScale(this._base_layout).parameters;\n                        if (baseParams.categories.length && baseParams.values.length) {\n                            // If there are preset category/color combos, make sure that they apply to the actual dataset\n                            var parameters_categories_hash = {};\n                            baseParams.categories.forEach(function (category) {\n                                parameters_categories_hash[category] = 1;\n                            });\n                            if (categoryNames.every(function (name) {\n                                    return parameters_categories_hash.hasOwnProperty(name);\n                                })) {\n                                // The layout doesn't have to specify categories in order, but make sure they are all there\n                                colorParams.categories = baseParams.categories;\n                            } else {\n                                colorParams.categories = categoryNames;\n                            }\n                        } else {\n                            colorParams.categories = categoryNames;\n                        }\n                        // Prefer user-specified colors if provided. Make sure that there are enough colors for all the categories.\n                        var colors;\n                        if (baseParams.values.length) {\n                            colors = baseParams.values;\n                        } else {\n                            var color_scale = categoryNames.length <= 10 ? d3.scale.category10 : d3.scale.category20;\n                            colors = color_scale().range();\n                        }\n                        while (colors.length < categoryNames.length) {\n                            colors = colors.concat(colors);\n                        }\n                        colors = colors.slice(0, categoryNames.length);\n                        // List of hex values, should be of same length as categories array\n                        colorParams.values = colors;\n                    },\n                    /**\n     *\n     * @param dimension\n     * @param {Object} [config] Parameters that customize how ticks are calculated (not style)\n     * @param {('left'|'center'|'right')} [config.position='left'] Align ticks with the center or edge of category\n     * @returns {Array}\n     */\n                    getTicks: function (dimension, config) {\n                        // Overrides parent method\n                        if ([\n                                'x',\n                                'y1',\n                                'y2'\n                            ].indexOf(dimension) === -1) {\n                            throw new Error('Invalid dimension identifier');\n                        }\n                        var position = config.position || 'left';\n                        if ([\n                                'left',\n                                'center',\n                                'right'\n                            ].indexOf(position) === -1) {\n                            throw new Error('Invalid tick position');\n                        }\n                        var categoryBounds = this._categories;\n                        if (!categoryBounds || !Object.keys(categoryBounds).length) {\n                            return [];\n                        }\n                        if (dimension === 'y') {\n                            return [];\n                        }\n                        if (dimension === 'x') {\n                            // If colors have been defined by this layer, use them to make tick colors match scatterplot point colors\n                            var colors = this._getColorScale(this.layout);\n                            var knownCategories = colors.parameters.categories || [];\n                            var knownColors = colors.parameters.values || [];\n                            return Object.keys(categoryBounds).map(function (category, index) {\n                                var bounds = categoryBounds[category];\n                                var xPos;\n                                switch (position) {\n                                case 'left':\n                                    xPos = bounds[0];\n                                    break;\n                                case 'center':\n                                    // Center tick under one or many elements as appropriate\n                                    var diff = bounds[1] - bounds[0];\n                                    xPos = bounds[0] + (diff !== 0 ? diff : bounds[0]) / 2;\n                                    break;\n                                case 'right':\n                                    xPos = bounds[1];\n                                    break;\n                                }\n                                return {\n                                    x: xPos,\n                                    text: category,\n                                    style: { 'fill': knownColors[knownCategories.indexOf(category)] || '#000000' }\n                                };\n                            });\n                        }\n                    },\n                    applyCustomDataMethods: function () {\n                        this.data = this._prepareData();\n                        /**\n         * Define category names and extents (boundaries) for plotting.  TODO: properties in constructor\n         * @member {Object.<String, Number[]>} Category names and extents, in the form {category_name: [min_x, max_x]}\n         */\n                        this._categories = this._generateCategoryBounds();\n                        return this;\n                    }\n                });\n                /* global LocusZoom */\n                'use strict';\n                /**\n *\n * LocusZoom has various singleton objects that are used for registering functions or classes.\n * These objects provide safe, standard methods to redefine or delete existing functions/classes\n * as well as define new custom functions/classes to be used in a plot.\n *\n * @namespace Singletons\n */\n                /*\n * The Collection of \"Known\" Data Sources. This registry is used internally by the `DataSources` class\n * @class\n * @static\n */\n                LocusZoom.KnownDataSources = function () {\n                    /** @lends LocusZoom.KnownDataSources */\n                    var obj = {};\n                    /* @member {function[]} */\n                    var sources = [];\n                    var findSourceByName = function (x) {\n                        for (var i = 0; i < sources.length; i++) {\n                            if (!sources[i].SOURCE_NAME) {\n                                throw new Error('KnownDataSources at position ' + i + ' does not have a \\'SOURCE_NAME\\' static property');\n                            }\n                            if (sources[i].SOURCE_NAME === x) {\n                                return sources[i];\n                            }\n                        }\n                        return null;\n                    };\n                    /**\n     * Identify the datasource associated with a given name\n     * @param {String} name\n     * @returns {function} The constructor for the data source; will usually extend `Data.Source`\n     */\n                    obj.get = function (name) {\n                        return findSourceByName(name);\n                    };\n                    /**\n     * Register a data source constructor so that it may be located by name\n     * @param {function} source A constructor function for a data source; will usually extend `Data.Source`,\n     *   and should have a `SOURCE_NAME` property\n     */\n                    obj.add = function (source) {\n                        if (!source.SOURCE_NAME) {\n                            console.warn('Data source added does not have a SOURCE_NAME');\n                        }\n                        sources.push(source);\n                    };\n                    /**\n     * Create a custom source type that extends the behavior of an existing source, and registers that\n     *  source by the provided name\n     * @param {String} parent_name The name of a previously registered data source type to use as a template\n     * @param {String} source_name The new name to use when registering this data source\n     * @param {Object} overrides An object of additional properties and methods to add/override behavior\n     * @returns {LocusZoom.Data.Source} The newly defined class for this source\n     */\n                    obj.extend = function (parent_name, source_name, overrides) {\n                        var parent = findSourceByName(parent_name);\n                        if (!parent) {\n                            throw new Error('Attempted to subclass an unknown or unregistered data source');\n                        }\n                        if (!source_name) {\n                            throw new Error('Must provide a name for the new data source');\n                        }\n                        if (typeof overrides !== 'object') {\n                            throw new Error('Must specify an object of properties and methods');\n                        }\n                        var child = LocusZoom.subclass(parent, overrides);\n                        child.SOURCE_NAME = source_name;\n                        sources.push(child);\n                        return child;\n                    };\n                    /** @deprecated */\n                    obj.push = function (source) {\n                        console.warn('Warning: KnownDataSources.push() is deprecated. Use .add() instead');\n                        obj.add(source);\n                    };\n                    /**\n     * List the names of all registered datasources\n     * @returns {String[]}\n     */\n                    obj.list = function () {\n                        return sources.map(function (x) {\n                            return x.SOURCE_NAME;\n                        });\n                    };\n                    /**\n     * Create a datasource instance\n     * @param {String} name The name of the desired datasource to instantiate (must be defined in the registry)\n     * @returns {LocusZoom.Data.Source}\n     */\n                    obj.create = function (name) {\n                        //create new object (pass additional parameters to constructor)\n                        var newObj = findSourceByName(name);\n                        if (newObj) {\n                            var params = arguments;\n                            params[0] = null;\n                            return new (Function.prototype.bind.apply(newObj, params))();\n                        } else {\n                            throw new Error('Unable to find data source for name: ' + name);\n                        }\n                    };\n                    /**\n     * Get the array of all registered constructors\n     *   Generally only used for unit tests internally\n     * @private\n     * @returns {function[]}\n     */\n                    obj.getAll = function () {\n                        return sources;\n                    };\n                    /**\n     * Register an entire collection of data sources\n     *   Generally only used for unit tests internally\n     * @private\n     * @param {function[]} x An array of datasource constructors\n     */\n                    obj.setAll = function (x) {\n                        sources = x;\n                    };\n                    /**\n     * Unregister all known data sources\n     *   Generally only used for unit tests internally\n     * @private\n     */\n                    obj.clear = function () {\n                        sources = [];\n                    };\n                    return obj;\n                }();\n                /**************************\n * Transformation Functions\n *\n * Singleton for formatting or transforming a single input, for instance turning raw p values into negative log10 form\n * Transformation functions are chainable with a pipe on a field name, like so: \"pvalue|neglog10\"\n *\n * NOTE: Because these functions are chainable the FUNCTION is returned by get(), not the result of that function.\n *\n * All transformation functions must accept an object of parameters and a value to process.\n * @class\n */\n                LocusZoom.TransformationFunctions = function () {\n                    /** @lends LocusZoom.TransformationFunctions */\n                    var obj = {};\n                    var transformations = {};\n                    var getTrans = function (name) {\n                        if (!name) {\n                            return null;\n                        }\n                        var fun = transformations[name];\n                        if (fun) {\n                            return fun;\n                        } else {\n                            throw new Error('transformation ' + name + ' not found');\n                        }\n                    };\n                    //a single transformation with any parameters\n                    //(parameters not currently supported)\n                    var parseTrans = function (name) {\n                        return getTrans(name);\n                    };\n                    //a \"raw\" transformation string with a leading pipe\n                    //and one or more transformations\n                    var parseTransString = function (x) {\n                        var funs = [];\n                        var re = /\\|([^|]+)/g;\n                        var result;\n                        while ((result = re.exec(x)) !== null) {\n                            funs.push(result[1]);\n                        }\n                        if (funs.length === 1) {\n                            return parseTrans(funs[0]);\n                        } else if (funs.length > 1) {\n                            return function (x) {\n                                var val = x;\n                                for (var i = 0; i < funs.length; i++) {\n                                    val = parseTrans(funs[i])(val);\n                                }\n                                return val;\n                            };\n                        }\n                        return null;\n                    };\n                    /**\n     * Retrieve a transformation function by name\n     * @param {String} name The name of the transformation function to retrieve. May optionally be prefixed with a\n     *   pipe (`|`) when chaining multiple transformation functions.\n     * @returns {function} The constructor for the transformation function\n     */\n                    obj.get = function (name) {\n                        if (name && name.substring(0, 1) === '|') {\n                            return parseTransString(name);\n                        } else {\n                            return parseTrans(name);\n                        }\n                    };\n                    /**\n     * Internal logic that registers a transformation function\n     * @protected\n     * @param {String} name\n     * @param {function} fn\n     */\n                    obj.set = function (name, fn) {\n                        if (name.substring(0, 1) === '|') {\n                            throw new Error('transformation name should not start with a pipe');\n                        } else {\n                            if (fn) {\n                                transformations[name] = fn;\n                            } else {\n                                delete transformations[name];\n                            }\n                        }\n                    };\n                    /**\n     * Register a transformation function\n     * @param {String} name\n     * @param {function} fn A transformation function (should accept one argument with the value)\n     */\n                    obj.add = function (name, fn) {\n                        if (transformations[name]) {\n                            throw new Error('transformation already exists with name: ' + name);\n                        } else {\n                            obj.set(name, fn);\n                        }\n                    };\n                    /**\n     * List the names of all registered transformation functions\n     * @returns {String[]}\n     */\n                    obj.list = function () {\n                        return Object.keys(transformations);\n                    };\n                    return obj;\n                }();\n                /**\n * Return the -log (base 10)\n * @function neglog10\n */\n                LocusZoom.TransformationFunctions.add('neglog10', function (x) {\n                    if (isNaN(x) || x <= 0) {\n                        return null;\n                    }\n                    return -Math.log(x) / Math.LN10;\n                });\n                /**\n * Convert a number from logarithm to scientific notation. Useful for, eg, a datasource that returns -log(p) by default\n * @function logtoscinotation\n */\n                LocusZoom.TransformationFunctions.add('logtoscinotation', function (x) {\n                    if (isNaN(x)) {\n                        return 'NaN';\n                    }\n                    if (x === 0) {\n                        return '1';\n                    }\n                    var exp = Math.ceil(x);\n                    var diff = exp - x;\n                    var base = Math.pow(10, diff);\n                    if (exp === 1) {\n                        return (base / 10).toFixed(4);\n                    } else if (exp === 2) {\n                        return (base / 100).toFixed(3);\n                    } else {\n                        return base.toFixed(2) + ' \\xD7 10^-' + exp;\n                    }\n                });\n                /**\n * Represent a number in scientific notation\n * @function scinotation\n * @param {Number} x\n * @returns {String}\n */\n                LocusZoom.TransformationFunctions.add('scinotation', function (x) {\n                    if (isNaN(x)) {\n                        return 'NaN';\n                    }\n                    if (x === 0) {\n                        return '0';\n                    }\n                    var abs = Math.abs(x);\n                    var log;\n                    if (abs > 1) {\n                        log = Math.ceil(Math.log(abs) / Math.LN10);\n                    } else {\n                        // 0...1\n                        log = Math.floor(Math.log(abs) / Math.LN10);\n                    }\n                    if (Math.abs(log) <= 3) {\n                        return x.toFixed(3);\n                    } else {\n                        return x.toExponential(2).replace('+', '').replace('e', ' \\xD7 10^');\n                    }\n                });\n                /**\n * URL-encode the provided text, eg for constructing hyperlinks\n * @function urlencode\n * @param {String} str\n */\n                LocusZoom.TransformationFunctions.add('urlencode', function (str) {\n                    return encodeURIComponent(str);\n                });\n                /**\n * HTML-escape user entered values for use in constructed HTML fragments\n *\n * For example, this filter can be used on tooltips with custom HTML display\n * @function htmlescape\n * @param {String} str HTML-escape the provided value\n */\n                LocusZoom.TransformationFunctions.add('htmlescape', function (str) {\n                    if (!str) {\n                        return '';\n                    }\n                    str = str + '';\n                    return str.replace(/['\"<>&`]/g, function (s) {\n                        switch (s) {\n                        case '\\'':\n                            return '&#039;';\n                        case '\"':\n                            return '&quot;';\n                        case '<':\n                            return '&lt;';\n                        case '>':\n                            return '&gt;';\n                        case '&':\n                            return '&amp;';\n                        case '`':\n                            return '&#x60;';\n                        }\n                    });\n                });\n                /**\n * Singleton for accessing/storing functions that will convert arbitrary data points to values in a given scale\n * Useful for anything that needs to scale discretely with data (e.g. color, point size, etc.)\n *\n * A Scale Function can be thought of as a modifier to a layout directive that adds extra logic to how a piece of data\n *   can be resolved to a value.\n *\n * All scale functions must accept an object of parameters and a value to process.\n * @class\n * @static\n */\n                LocusZoom.ScaleFunctions = function () {\n                    /** @lends LocusZoom.ScaleFunctions */\n                    var obj = {};\n                    var functions = {};\n                    /**\n     * Find a scale function and return it. If parameters and values are passed, calls the function directly; otherwise\n     *   returns a callable.\n     * @param {String} name\n     * @param {Object} [parameters] Configuration parameters specific to the specified scale function\n     * @param {*} [value] The value to operate on\n     * @returns {*}\n     */\n                    obj.get = function (name, parameters, value) {\n                        if (!name) {\n                            return null;\n                        } else if (functions[name]) {\n                            if (typeof parameters === 'undefined' && typeof value === 'undefined') {\n                                return functions[name];\n                            } else {\n                                return functions[name](parameters, value);\n                            }\n                        } else {\n                            throw new Error('scale function [' + name + '] not found');\n                        }\n                    };\n                    /**\n     * @protected\n     * @param {String} name The name of the function to set/unset\n     * @param {Function} [fn] The function to register. If blank, removes this function name from the registry.\n     */\n                    obj.set = function (name, fn) {\n                        if (fn) {\n                            functions[name] = fn;\n                        } else {\n                            delete functions[name];\n                        }\n                    };\n                    /**\n     * Add a new scale function to the registry\n     * @param {String} name The name of the scale function\n     * @param {function} fn A scale function that accepts two parameters: an object of configuration and a value\n     */\n                    obj.add = function (name, fn) {\n                        if (functions[name]) {\n                            throw new Error('scale function already exists with name: ' + name);\n                        } else {\n                            obj.set(name, fn);\n                        }\n                    };\n                    /**\n     * List the names of all registered scale functions\n     * @returns {String[]}\n     */\n                    obj.list = function () {\n                        return Object.keys(functions);\n                    };\n                    return obj;\n                }();\n                /**\n * Basic conditional function to evaluate the value of the input field and return based on equality.\n * @param {Object} parameters\n * @param {*} parameters.field_value The value against which to test the input value.\n * @param {*} parameters.then The value to return if the input value matches the field value\n * @param {*} parameters.else  The value to return if the input value does not match the field value. Optional. If not\n *   defined this scale function will return null (or value of null_value parameter, if defined) when input value fails\n *   to match field_value.\n * @param {*} input value\n */\n                LocusZoom.ScaleFunctions.add('if', function (parameters, input) {\n                    if (typeof input == 'undefined' || parameters.field_value !== input) {\n                        if (typeof parameters.else != 'undefined') {\n                            return parameters.else;\n                        } else {\n                            return null;\n                        }\n                    } else {\n                        return parameters.then;\n                    }\n                });\n                /**\n * Function to sort numerical values into bins based on numerical break points. Will only operate on numbers and\n *   return null (or value of null_value parameter, if defined) if provided a non-numeric input value. Parameters:\n * @function numerical_bin\n * @param {Object} parameters\n * @param {Number[]} parameters.breaks  Array of numerical break points against which to evaluate the input value.\n *   Must be of equal length to values parameter. If the input value is greater than or equal to break n and less than\n *   or equal to break n+1 (or break n+1 doesn't exist) then returned value is the nth entry in the values parameter.\n * @param {Array} parameters.values  Array of values to return given evaluations against break points. Must be of\n *   equal length to breaks parameter. Each entry n represents the value to return if the input value is greater than\n *   or equal to break n and less than or equal to break n+1 (or break n+1 doesn't exist).\n * @param {*} null_value\n * @param {*} input value\n * @returns\n */\n                LocusZoom.ScaleFunctions.add('numerical_bin', function (parameters, input) {\n                    var breaks = parameters.breaks || [];\n                    var values = parameters.values || [];\n                    if (typeof input == 'undefined' || input === null || isNaN(+input)) {\n                        return parameters.null_value ? parameters.null_value : null;\n                    }\n                    var threshold = breaks.reduce(function (prev, curr) {\n                        if (+input < prev || +input >= prev && +input < curr) {\n                            return prev;\n                        } else {\n                            return curr;\n                        }\n                    });\n                    return values[breaks.indexOf(threshold)];\n                });\n                /**\n * Function to sort values of any type into bins based on direct equality testing with a list of categories.\n *   Will return null if provided an input value that does not match to a listed category.\n * @function categorical_bin\n * @param {Object} parameters\n * @param {Array} parameters.categories  Array of values against which to evaluate the input value. Must be of equal\n *   length to values parameter. If the input value is equal to category n then returned value is the nth entry in the\n *   values parameter.\n * @param {Array} parameters.values  Array of values to return given evaluations against categories. Must be of equal\n *   length to categories parameter. Each entry n represents the value to return if the input value is equal to the nth\n *   value in the categories parameter.\n * @param {*} parameters.null_value  Value to return if the input value fails to match to any categories. Optional.\n */\n                LocusZoom.ScaleFunctions.add('categorical_bin', function (parameters, value) {\n                    if (typeof value == 'undefined' || parameters.categories.indexOf(value) === -1) {\n                        return parameters.null_value ? parameters.null_value : null;\n                    } else {\n                        return parameters.values[parameters.categories.indexOf(value)];\n                    }\n                });\n                /**\n * Function for continuous interpolation of numerical values along a gradient with arbitrarily many break points.\n * @function interpolate\n * @parameters {Object} parameters\n * @parameters {Number[]} parameters.breaks  Array of numerical break points against which to evaluate the input value.\n *   Must be of equal length to values parameter and contain at least two elements. Input value will be evaluated for\n *   relative position between two break points n and n+1 and the returned value will be interpolated at a relative\n *   position between values n and n+1.\n * @parameters {*[]} parameters.values  Array of values to interpolate and return given evaluations against break\n *   points. Must be of equal length to breaks parameter and contain at least two elements. Each entry n represents\n *   the value to return if the input value matches the nth entry in breaks exactly. Note that this scale function\n *   uses d3.interpolate to provide for effective interpolation of many different value types, including numbers,\n *   colors, shapes, etc.\n * @parameters {*} parameters.null_value\n */\n                LocusZoom.ScaleFunctions.add('interpolate', function (parameters, input) {\n                    var breaks = parameters.breaks || [];\n                    var values = parameters.values || [];\n                    var nullval = parameters.null_value ? parameters.null_value : null;\n                    if (breaks.length < 2 || breaks.length !== values.length) {\n                        return nullval;\n                    }\n                    if (typeof input == 'undefined' || input === null || isNaN(+input)) {\n                        return nullval;\n                    }\n                    if (+input <= parameters.breaks[0]) {\n                        return values[0];\n                    } else if (+input >= parameters.breaks[parameters.breaks.length - 1]) {\n                        return values[breaks.length - 1];\n                    } else {\n                        var upper_idx = null;\n                        breaks.forEach(function (brk, idx) {\n                            if (!idx) {\n                                return;\n                            }\n                            if (breaks[idx - 1] <= +input && breaks[idx] >= +input) {\n                                upper_idx = idx;\n                            }\n                        });\n                        if (upper_idx === null) {\n                            return nullval;\n                        }\n                        var normalized_input = (+input - breaks[upper_idx - 1]) / (breaks[upper_idx] - breaks[upper_idx - 1]);\n                        if (!isFinite(normalized_input)) {\n                            return nullval;\n                        }\n                        return d3.interpolate(values[upper_idx - 1], values[upper_idx])(normalized_input);\n                    }\n                });\n                /* global LocusZoom */\n                'use strict';\n                /**\n * A Dashboard is an HTML element used for presenting arbitrary user interface components. Dashboards are anchored\n *   to either the entire Plot or to individual Panels.\n *\n * Each dashboard is an HTML-based (read: not SVG) collection of components used to display information or provide\n *   user interface. Dashboards can exist on entire plots, where their visibility is permanent and vertically adjacent\n *   to the plot, or on individual panels, where their visibility is tied to a behavior (e.g. a mouseover) and is as\n *   an overlay.\n * @class\n */\n                LocusZoom.Dashboard = function (parent) {\n                    // parent must be a locuszoom plot or panel\n                    if (!(parent instanceof LocusZoom.Plot) && !(parent instanceof LocusZoom.Panel)) {\n                        throw new Error('Unable to create dashboard, parent must be a locuszoom plot or panel');\n                    }\n                    /** @member {LocusZoom.Plot|LocusZoom.Panel} */\n                    this.parent = parent;\n                    /** @member {String} */\n                    this.id = this.parent.getBaseId() + '.dashboard';\n                    /** @member {('plot'|'panel')} */\n                    this.type = this.parent instanceof LocusZoom.Plot ? 'plot' : 'panel';\n                    /** @member {LocusZoom.Plot} */\n                    this.parent_plot = this.type === 'plot' ? this.parent : this.parent.parent;\n                    /** @member {d3.selection} */\n                    this.selector = null;\n                    /** @member {LocusZoom.Dashboard.Component[]} */\n                    this.components = [];\n                    /**\n     * The timer identifier as returned by setTimeout\n     * @member {Number}\n     */\n                    this.hide_timeout = null;\n                    /**\n     * Whether to hide the dashboard. Can be overridden by a child component. Check via `shouldPersist`\n     * @protected\n     * @member {Boolean}\n     */\n                    this.persist = false;\n                    // TODO: Return value from constructor function?\n                    return this.initialize();\n                };\n                /**\n * Prepare the dashboard for first use: generate all component instances for this dashboard, based on the provided\n *   layout of the parent. Connects event listeners and shows/hides as appropriate.\n * @returns {LocusZoom.Dashboard}\n */\n                LocusZoom.Dashboard.prototype.initialize = function () {\n                    // Parse layout to generate component instances\n                    if (Array.isArray(this.parent.layout.dashboard.components)) {\n                        this.parent.layout.dashboard.components.forEach(function (layout) {\n                            try {\n                                var component = LocusZoom.Dashboard.Components.get(layout.type, layout, this);\n                                this.components.push(component);\n                            } catch (e) {\n                                console.warn(e);\n                            }\n                        }.bind(this));\n                    }\n                    // Add mouseover event handlers to show/hide panel dashboard\n                    if (this.type === 'panel') {\n                        d3.select(this.parent.parent.svg.node().parentNode).on('mouseover.' + this.id, function () {\n                            clearTimeout(this.hide_timeout);\n                            if (!this.selector || this.selector.style('visibility') === 'hidden') {\n                                this.show();\n                            }\n                        }.bind(this));\n                        d3.select(this.parent.parent.svg.node().parentNode).on('mouseout.' + this.id, function () {\n                            clearTimeout(this.hide_timeout);\n                            this.hide_timeout = setTimeout(function () {\n                                this.hide();\n                            }.bind(this), 300);\n                        }.bind(this));\n                    }\n                    return this;\n                };\n                /**\n * Whether to persist the dashboard. Returns true if at least one component should persist, or if the panel is engaged\n *   in an active drag event.\n * @returns {boolean}\n */\n                LocusZoom.Dashboard.prototype.shouldPersist = function () {\n                    if (this.persist) {\n                        return true;\n                    }\n                    var persist = false;\n                    // Persist if at least one component should also persist\n                    this.components.forEach(function (component) {\n                        persist = persist || component.shouldPersist();\n                    });\n                    // Persist if in a parent drag event\n                    persist = persist || (this.parent_plot.panel_boundaries.dragging || this.parent_plot.interaction.dragging);\n                    return !!persist;\n                };\n                /**\n * Make the dashboard appear. If it doesn't exist yet create it, including creating/positioning all components within,\n *   and make sure it is set to be visible.\n */\n                LocusZoom.Dashboard.prototype.show = function () {\n                    if (!this.selector) {\n                        switch (this.type) {\n                        case 'plot':\n                            this.selector = d3.select(this.parent.svg.node().parentNode).insert('div', ':first-child');\n                            break;\n                        case 'panel':\n                            this.selector = d3.select(this.parent.parent.svg.node().parentNode).insert('div', '.lz-data_layer-tooltip, .lz-dashboard-menu, .lz-curtain').classed('lz-panel-dashboard', true);\n                            break;\n                        }\n                        this.selector.classed('lz-dashboard', true).classed('lz-' + this.type + '-dashboard', true).attr('id', this.id);\n                    }\n                    this.components.forEach(function (component) {\n                        component.show();\n                    });\n                    this.selector.style({ visibility: 'visible' });\n                    return this.update();\n                };\n                /**\n * Update the dashboard and rerender all child components. This can be called whenever plot state changes.\n * @returns {LocusZoom.Dashboard}\n */\n                LocusZoom.Dashboard.prototype.update = function () {\n                    if (!this.selector) {\n                        return this;\n                    }\n                    this.components.forEach(function (component) {\n                        component.update();\n                    });\n                    return this.position();\n                };\n                /**\n * Position the dashboard (and child components) within the panel\n * @returns {LocusZoom.Dashboard}\n */\n                LocusZoom.Dashboard.prototype.position = function () {\n                    if (!this.selector) {\n                        return this;\n                    }\n                    // Position the dashboard itself (panel only)\n                    if (this.type === 'panel') {\n                        var page_origin = this.parent.getPageOrigin();\n                        var top = (page_origin.y + 3.5).toString() + 'px';\n                        var left = page_origin.x.toString() + 'px';\n                        var width = (this.parent.layout.width - 4).toString() + 'px';\n                        this.selector.style({\n                            position: 'absolute',\n                            top: top,\n                            left: left,\n                            width: width\n                        });\n                    }\n                    // Recursively position components\n                    this.components.forEach(function (component) {\n                        component.position();\n                    });\n                    return this;\n                };\n                /**\n * Hide the dashboard (make invisible but do not destroy). Will do nothing if `shouldPersist` returns true.\n *\n * @returns {LocusZoom.Dashboard}\n */\n                LocusZoom.Dashboard.prototype.hide = function () {\n                    if (!this.selector || this.shouldPersist()) {\n                        return this;\n                    }\n                    this.components.forEach(function (component) {\n                        component.hide();\n                    });\n                    this.selector.style({ visibility: 'hidden' });\n                    return this;\n                };\n                /**\n * Completely remove dashboard and all child components. (may be overridden by persistence settings)\n * @param {Boolean} [force=false] If true, will ignore persistence settings and always destroy the dashboard\n * @returns {LocusZoom.Dashboard}\n */\n                LocusZoom.Dashboard.prototype.destroy = function (force) {\n                    if (typeof force == 'undefined') {\n                        force = false;\n                    }\n                    if (!this.selector) {\n                        return this;\n                    }\n                    if (this.shouldPersist() && !force) {\n                        return this;\n                    }\n                    this.components.forEach(function (component) {\n                        component.destroy(true);\n                    });\n                    this.components = [];\n                    this.selector.remove();\n                    this.selector = null;\n                    return this;\n                };\n                /**\n *\n * A dashboard component is an empty div rendered on a dashboard that can display custom\n * html of user interface elements. LocusZoom.Dashboard.Components is a singleton used to\n * define and manage an extendable collection of dashboard components.\n * (e.g. by LocusZoom.Dashboard.Components.add())\n * @class\n * @param {Object} layout A JSON-serializable object of layout configuration parameters\n * @param {('left'|'right')} [layout.position='left']  Whether to float the component left or right.\n * @param {('start'|'middle'|'end')} [layout.group_position] Buttons can optionally be gathered into a visually\n *  distinctive group whose elements are closer together. If a button is identified as the start or end of a group,\n *  it will be drawn with rounded corners and an extra margin of spacing from any button not part of the group.\n *  For example, the region_nav_plot dashboard is a defined as a group.\n * @param {('gray'|'red'|'orange'|'yellow'|'green'|'blue'|'purple'} [layout.color='gray']  Color scheme for the\n *   component. Applies to buttons and menus.\n * @param {LocusZoom.Dashboard} parent The dashboard that contains this component\n*/\n                LocusZoom.Dashboard.Component = function (layout, parent) {\n                    /** @member {Object} */\n                    this.layout = layout || {};\n                    if (!this.layout.color) {\n                        this.layout.color = 'gray';\n                    }\n                    /** @member {LocusZoom.Dashboard|*} */\n                    this.parent = parent || null;\n                    /**\n     * Some dashboards are attached to a panel, rather than directly to a plot\n     * @member {LocusZoom.Panel|null}\n     */\n                    this.parent_panel = null;\n                    /** @member {LocusZoom.Plot} */\n                    this.parent_plot = null;\n                    /**\n     * This is a reference to either the panel or the plot, depending on what the dashboard is\n     *   tied to. Useful when absolutely positioning dashboard components relative to their SVG anchor.\n     * @member {LocusZoom.Plot|LocusZoom.Panel}\n     */\n                    this.parent_svg = null;\n                    if (this.parent instanceof LocusZoom.Dashboard) {\n                        // TODO: when is the immediate parent *not* a dashboard?\n                        if (this.parent.type === 'panel') {\n                            this.parent_panel = this.parent.parent;\n                            this.parent_plot = this.parent.parent.parent;\n                            this.parent_svg = this.parent_panel;\n                        } else {\n                            this.parent_plot = this.parent.parent;\n                            this.parent_svg = this.parent_plot;\n                        }\n                    }\n                    /** @member {d3.selection} */\n                    this.selector = null;\n                    /**\n     * If this is an interactive component, it will contain a button or menu instance that handles the interactivity.\n     *   There is a 1-to-1 relationship of dashboard component to button\n     * @member {null|LocusZoom.Dashboard.Component.Button}\n     */\n                    this.button = null;\n                    /**\n     * If any single component is marked persistent, it will bubble up to prevent automatic hide behavior on a\n     *   component's parent dashboard. Check via `shouldPersist`\n     * @protected\n     * @member {Boolean}\n     */\n                    this.persist = false;\n                    if (!this.layout.position) {\n                        this.layout.position = 'left';\n                    }\n                    // TODO: Return value in constructor\n                    return this;\n                };\n                /**\n * Perform all rendering of component, including toggling visibility to true. Will initialize and create SVG element\n *   if necessary, as well as updating with new data and performing layout actions.\n */\n                LocusZoom.Dashboard.Component.prototype.show = function () {\n                    if (!this.parent || !this.parent.selector) {\n                        return;\n                    }\n                    if (!this.selector) {\n                        var group_position = [\n                            'start',\n                            'middle',\n                            'end'\n                        ].indexOf(this.layout.group_position) !== -1 ? ' lz-dashboard-group-' + this.layout.group_position : '';\n                        this.selector = this.parent.selector.append('div').attr('class', 'lz-dashboard-' + this.layout.position + group_position);\n                        if (this.layout.style) {\n                            this.selector.style(this.layout.style);\n                        }\n                        if (typeof this.initialize == 'function') {\n                            this.initialize();\n                        }\n                    }\n                    if (this.button && this.button.status === 'highlighted') {\n                        this.button.menu.show();\n                    }\n                    this.selector.style({ visibility: 'visible' });\n                    this.update();\n                    return this.position();\n                };\n                /**\n * Update the dashboard component with any new data or plot state as appropriate. This method performs all\n *  necessary rendering steps.\n */\n                LocusZoom.Dashboard.Component.prototype.update = function () {\n                };\n                /**\n * Place the component correctly in the plot\n * @returns {LocusZoom.Dashboard.Component}\n */\n                LocusZoom.Dashboard.Component.prototype.position = function () {\n                    if (this.button) {\n                        this.button.menu.position();\n                    }\n                    return this;\n                };\n                /**\n * Determine whether the component should persist (will bubble up to parent dashboard)\n * @returns {boolean}\n */\n                LocusZoom.Dashboard.Component.prototype.shouldPersist = function () {\n                    if (this.persist) {\n                        return true;\n                    }\n                    if (this.button && this.button.persist) {\n                        return true;\n                    }\n                    return false;\n                };\n                /**\n * Toggle visibility to hidden, unless marked as persistent\n * @returns {LocusZoom.Dashboard.Component}\n */\n                LocusZoom.Dashboard.Component.prototype.hide = function () {\n                    if (!this.selector || this.shouldPersist()) {\n                        return this;\n                    }\n                    if (this.button) {\n                        this.button.menu.hide();\n                    }\n                    this.selector.style({ visibility: 'hidden' });\n                    return this;\n                };\n                /**\n * Completely remove component and button. (may be overridden by persistence settings)\n * @param {Boolean} [force=false] If true, will ignore persistence settings and always destroy the dashboard\n * @returns {LocusZoom.Dashboard}\n */\n                LocusZoom.Dashboard.Component.prototype.destroy = function (force) {\n                    if (typeof force == 'undefined') {\n                        force = false;\n                    }\n                    if (!this.selector) {\n                        return this;\n                    }\n                    if (this.shouldPersist() && !force) {\n                        return this;\n                    }\n                    if (this.button && this.button.menu) {\n                        this.button.menu.destroy();\n                    }\n                    this.selector.remove();\n                    this.selector = null;\n                    this.button = null;\n                    return this;\n                };\n                /**\n * Singleton registry of all known components\n * @class\n * @static\n */\n                LocusZoom.Dashboard.Components = function () {\n                    /** @lends LocusZoom.Dashboard.Components */\n                    var obj = {};\n                    var components = {};\n                    /**\n     * Create a new component instance by name\n     * @param {String} name The string identifier of the desired component\n     * @param {Object} layout The layout to use to create the component\n     * @param {LocusZoom.Dashboard} parent The containing dashboard to use when creating the component\n     * @returns {LocusZoom.Dashboard.Component}\n     */\n                    obj.get = function (name, layout, parent) {\n                        if (!name) {\n                            return null;\n                        } else if (components[name]) {\n                            if (typeof layout != 'object') {\n                                throw new Error('invalid layout argument for dashboard component [' + name + ']');\n                            } else {\n                                return new components[name](layout, parent);\n                            }\n                        } else {\n                            throw new Error('dashboard component [' + name + '] not found');\n                        }\n                    };\n                    /**\n     * Add a new component constructor to the registry and ensure that it extends the correct parent class\n     * @protected\n     * @param name\n     * @param component\n     */\n                    obj.set = function (name, component) {\n                        if (component) {\n                            if (typeof component != 'function') {\n                                throw new Error('unable to set dashboard component [' + name + '], argument provided is not a function');\n                            } else {\n                                components[name] = component;\n                                components[name].prototype = new LocusZoom.Dashboard.Component();\n                            }\n                        } else {\n                            delete components[name];\n                        }\n                    };\n                    /**\n     * Register a new component constructor by name\n     * @param {String} name\n     * @param {function} component The component constructor\n     */\n                    obj.add = function (name, component) {\n                        if (components[name]) {\n                            throw new Error('dashboard component already exists with name: ' + name);\n                        } else {\n                            obj.set(name, component);\n                        }\n                    };\n                    /**\n     * List the names of all registered components\n     * @returns {String[]}\n     */\n                    obj.list = function () {\n                        return Object.keys(components);\n                    };\n                    return obj;\n                }();\n                /**\n * Plots and panels may have a \"dashboard\" element suited for showing HTML components that may be interactive.\n *   When components need to incorporate a generic button, or additionally a button that generates a menu, this\n *   class provides much of the necessary framework.\n * @class\n * @param {LocusZoom.Dashboard.Component} parent\n */\n                LocusZoom.Dashboard.Component.Button = function (parent) {\n                    if (!(parent instanceof LocusZoom.Dashboard.Component)) {\n                        throw new Error('Unable to create dashboard component button, invalid parent');\n                    }\n                    /** @member {LocusZoom.Dashboard.Component} */\n                    this.parent = parent;\n                    /** @member {LocusZoom.Dashboard.Panel} */\n                    this.parent_panel = this.parent.parent_panel;\n                    /** @member {LocusZoom.Dashboard.Plot} */\n                    this.parent_plot = this.parent.parent_plot;\n                    /** @member {LocusZoom.Plot|LocusZoom.Panel} */\n                    this.parent_svg = this.parent.parent_svg;\n                    /** @member {LocusZoom.Dashboard|null|*} */\n                    this.parent_dashboard = this.parent.parent;\n                    /** @member {d3.selection} */\n                    this.selector = null;\n                    /**\n     * Tag to use for the button (default: a)\n     * @member {String}\n     */\n                    this.tag = 'a';\n                    /**\n     * TODO This method does not appear to be used anywhere\n     * @param {String} tag\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n                    this.setTag = function (tag) {\n                        if (typeof tag != 'undefined') {\n                            this.tag = tag.toString();\n                        }\n                        return this;\n                    };\n                    /**\n     * HTML for the button to show.\n     * @protected\n     * @member {String}\n     */\n                    this.html = '';\n                    /**\n     * Specify the HTML content of this button.\n     * WARNING: The string provided will be inserted into the document as raw markup; XSS mitigation is the\n     *   responsibility of each button implementation.\n     * @param {String} html\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n                    this.setHtml = function (html) {\n                        if (typeof html != 'undefined') {\n                            this.html = html.toString();\n                        }\n                        return this;\n                    };\n                    /**\n     * @deprecated since 0.5.6; use setHtml instead\n     */\n                    this.setText = this.setHtml;\n                    /**\n     * Mouseover title text for the button to show\n     * @protected\n     * @member {String}\n     */\n                    this.title = '';\n                    /**\n     * Set the mouseover title text for the button (if any)\n     * @param {String} title Simple text to display\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n                    this.setTitle = function (title) {\n                        if (typeof title != 'undefined') {\n                            this.title = title.toString();\n                        }\n                        return this;\n                    };\n                    /**\n     * Color of the button\n     * @member {String}\n     */\n                    this.color = 'gray';\n                    /**\n     * Set the color associated with this button\n     * @param {('gray'|'red'|'orange'|'yellow'|'green'|'blue'|'purple')} color Any selection not in the preset list\n     *   will be replaced with gray.\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n                    this.setColor = function (color) {\n                        if (typeof color != 'undefined') {\n                            if ([\n                                    'gray',\n                                    'red',\n                                    'orange',\n                                    'yellow',\n                                    'green',\n                                    'blue',\n                                    'purple'\n                                ].indexOf(color) !== -1) {\n                                this.color = color;\n                            } else {\n                                this.color = 'gray';\n                            }\n                        }\n                        return this;\n                    };\n                    /**\n     * Hash of arbitrary button styles to apply as {name: value} entries\n     * @protected\n     * @member {Object}\n     */\n                    this.style = {};\n                    /**\n     * Set a collection of custom styles to be used by the button\n     * @param {Object} style Hash of {name:value} entries\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n                    this.setStyle = function (style) {\n                        if (typeof style != 'undefined') {\n                            this.style = style;\n                        }\n                        return this;\n                    };\n                    //\n                    /**\n     * Method to generate a CSS class string\n     * @returns {string}\n     */\n                    this.getClass = function () {\n                        var group_position = [\n                            'start',\n                            'middle',\n                            'end'\n                        ].indexOf(this.parent.layout.group_position) !== -1 ? ' lz-dashboard-button-group-' + this.parent.layout.group_position : '';\n                        return 'lz-dashboard-button lz-dashboard-button-' + this.color + (this.status ? '-' + this.status : '') + group_position;\n                    };\n                    // Permanence\n                    /**\n     * Track internal state on whether to keep showing the button/ menu contents at the moment\n     * @protected\n     * @member {Boolean}\n     */\n                    this.persist = false;\n                    /**\n     * Configuration when defining a button: track whether this component should be allowed to keep open\n     *   menu/button contents in response to certain events\n     * @protected\n     * @member {Boolean}\n     */\n                    this.permanent = false;\n                    /**\n     * Allow code to change whether the button is allowed to be `permanent`\n     * @param {boolean} bool\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n                    this.setPermanent = function (bool) {\n                        if (typeof bool == 'undefined') {\n                            bool = true;\n                        } else {\n                            bool = Boolean(bool);\n                        }\n                        this.permanent = bool;\n                        if (this.permanent) {\n                            this.persist = true;\n                        }\n                        return this;\n                    };\n                    /**\n     * Determine whether the button/menu contents should persist in response to a specific event\n     * @returns {Boolean}\n     */\n                    this.shouldPersist = function () {\n                        return this.permanent || this.persist;\n                    };\n                    /**\n     * Button status (highlighted / disabled/ etc)\n     * @protected\n     * @member {String}\n     */\n                    this.status = '';\n                    /**\n     * Change button state\n     * @param {('highlighted'|'disabled'|'')} status\n     */\n                    this.setStatus = function (status) {\n                        if (typeof status != 'undefined' && [\n                                '',\n                                'highlighted',\n                                'disabled'\n                            ].indexOf(status) !== -1) {\n                            this.status = status;\n                        }\n                        return this.update();\n                    };\n                    /**\n     * Toggle whether the button is highlighted\n     * @param {boolean} bool If provided, explicitly set highlighted state\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n                    this.highlight = function (bool) {\n                        if (typeof bool == 'undefined') {\n                            bool = true;\n                        } else {\n                            bool = Boolean(bool);\n                        }\n                        if (bool) {\n                            return this.setStatus('highlighted');\n                        } else if (this.status === 'highlighted') {\n                            return this.setStatus('');\n                        }\n                        return this;\n                    };\n                    /**\n     * Toggle whether the button is disabled\n     * @param {boolean} bool If provided, explicitly set disabled state\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n                    this.disable = function (bool) {\n                        if (typeof bool == 'undefined') {\n                            bool = true;\n                        } else {\n                            bool = Boolean(bool);\n                        }\n                        if (bool) {\n                            return this.setStatus('disabled');\n                        } else if (this.status === 'disabled') {\n                            return this.setStatus('');\n                        }\n                        return this;\n                    };\n                    // Mouse events\n                    /** @member {function} */\n                    this.onmouseover = function () {\n                    };\n                    this.setOnMouseover = function (onmouseover) {\n                        if (typeof onmouseover == 'function') {\n                            this.onmouseover = onmouseover;\n                        } else {\n                            this.onmouseover = function () {\n                            };\n                        }\n                        return this;\n                    };\n                    /** @member {function} */\n                    this.onmouseout = function () {\n                    };\n                    this.setOnMouseout = function (onmouseout) {\n                        if (typeof onmouseout == 'function') {\n                            this.onmouseout = onmouseout;\n                        } else {\n                            this.onmouseout = function () {\n                            };\n                        }\n                        return this;\n                    };\n                    /** @member {function} */\n                    this.onclick = function () {\n                    };\n                    this.setOnclick = function (onclick) {\n                        if (typeof onclick == 'function') {\n                            this.onclick = onclick;\n                        } else {\n                            this.onclick = function () {\n                            };\n                        }\n                        return this;\n                    };\n                    // Primary behavior functions\n                    /**\n     * Show the button, including creating DOM elements if necessary for first render\n     */\n                    this.show = function () {\n                        if (!this.parent) {\n                            return;\n                        }\n                        if (!this.selector) {\n                            this.selector = this.parent.selector.append(this.tag).attr('class', this.getClass());\n                        }\n                        return this.update();\n                    };\n                    /**\n     * Hook for any actions or state cleanup to be performed before rerendering\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n                    this.preUpdate = function () {\n                        return this;\n                    };\n                    /**\n     * Update button state and contents, and fully rerender\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n                    this.update = function () {\n                        if (!this.selector) {\n                            return this;\n                        }\n                        this.preUpdate();\n                        this.selector.attr('class', this.getClass()).attr('title', this.title).style(this.style).on('mouseover', this.status === 'disabled' ? null : this.onmouseover).on('mouseout', this.status === 'disabled' ? null : this.onmouseout).on('click', this.status === 'disabled' ? null : this.onclick).html(this.html);\n                        this.menu.update();\n                        this.postUpdate();\n                        return this;\n                    };\n                    /**\n     * Hook for any behavior to be added/changed after the button has been re-rendered\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n                    this.postUpdate = function () {\n                        return this;\n                    };\n                    /**\n     * Hide the button by removing it from the DOM (may be overridden by current persistence setting)\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n                    this.hide = function () {\n                        if (this.selector && !this.shouldPersist()) {\n                            this.selector.remove();\n                            this.selector = null;\n                        }\n                        return this;\n                    };\n                    /**\n     * Button Menu Object\n     * The menu is an HTML overlay that can appear below a button. It can contain arbitrary HTML and\n     *   has logic to be automatically positioned and sized to behave more or less like a dropdown menu.\n     * @member {Object}\n     */\n                    this.menu = {\n                        outer_selector: null,\n                        inner_selector: null,\n                        scroll_position: 0,\n                        hidden: true,\n                        /**\n         * Show the button menu, including setting up any DOM elements needed for first rendering\n         */\n                        show: function () {\n                            if (!this.menu.outer_selector) {\n                                this.menu.outer_selector = d3.select(this.parent_plot.svg.node().parentNode).append('div').attr('class', 'lz-dashboard-menu lz-dashboard-menu-' + this.color).attr('id', this.parent_svg.getBaseId() + '.dashboard.menu');\n                                this.menu.inner_selector = this.menu.outer_selector.append('div').attr('class', 'lz-dashboard-menu-content');\n                                this.menu.inner_selector.on('scroll', function () {\n                                    this.menu.scroll_position = this.menu.inner_selector.node().scrollTop;\n                                }.bind(this));\n                            }\n                            this.menu.outer_selector.style({ visibility: 'visible' });\n                            this.menu.hidden = false;\n                            return this.menu.update();\n                        }.bind(this),\n                        /**\n         * Update the rendering of the menu\n         */\n                        update: function () {\n                            if (!this.menu.outer_selector) {\n                                return this.menu;\n                            }\n                            this.menu.populate();\n                            // This function is stubbed for all buttons by default and custom implemented in component definition\n                            if (this.menu.inner_selector) {\n                                this.menu.inner_selector.node().scrollTop = this.menu.scroll_position;\n                            }\n                            return this.menu.position();\n                        }.bind(this),\n                        position: function () {\n                            if (!this.menu.outer_selector) {\n                                return this.menu;\n                            }\n                            // Unset any explicitly defined outer selector height so that menus dynamically shrink if content is removed\n                            this.menu.outer_selector.style({ height: null });\n                            var padding = 3;\n                            var scrollbar_padding = 20;\n                            var menu_height_padding = 14;\n                            // 14: 2x 6px padding, 2x 1px border\n                            var page_origin = this.parent_svg.getPageOrigin();\n                            var page_scroll_top = document.documentElement.scrollTop || document.body.scrollTop;\n                            var container_offset = this.parent_plot.getContainerOffset();\n                            var dashboard_client_rect = this.parent_dashboard.selector.node().getBoundingClientRect();\n                            var button_client_rect = this.selector.node().getBoundingClientRect();\n                            var menu_client_rect = this.menu.outer_selector.node().getBoundingClientRect();\n                            var total_content_height = this.menu.inner_selector.node().scrollHeight;\n                            var top = 0;\n                            var left = 0;\n                            if (this.parent_dashboard.type === 'panel') {\n                                top = page_origin.y + dashboard_client_rect.height + 2 * padding;\n                                left = Math.max(page_origin.x + this.parent_svg.layout.width - menu_client_rect.width - padding, page_origin.x + padding);\n                            } else {\n                                top = button_client_rect.bottom + page_scroll_top + padding - container_offset.top;\n                                left = Math.max(button_client_rect.left + button_client_rect.width - menu_client_rect.width - container_offset.left, page_origin.x + padding);\n                            }\n                            var base_max_width = Math.max(this.parent_svg.layout.width - 2 * padding - scrollbar_padding, scrollbar_padding);\n                            var container_max_width = base_max_width;\n                            var content_max_width = base_max_width - 4 * padding;\n                            var base_max_height = Math.max(this.parent_svg.layout.height - 10 * padding - menu_height_padding, menu_height_padding);\n                            var height = Math.min(total_content_height, base_max_height);\n                            var max_height = base_max_height;\n                            this.menu.outer_selector.style({\n                                'top': top.toString() + 'px',\n                                'left': left.toString() + 'px',\n                                'max-width': container_max_width.toString() + 'px',\n                                'max-height': max_height.toString() + 'px',\n                                'height': height.toString() + 'px'\n                            });\n                            this.menu.inner_selector.style({ 'max-width': content_max_width.toString() + 'px' });\n                            this.menu.inner_selector.node().scrollTop = this.menu.scroll_position;\n                            return this.menu;\n                        }.bind(this),\n                        hide: function () {\n                            if (!this.menu.outer_selector) {\n                                return this.menu;\n                            }\n                            this.menu.outer_selector.style({ visibility: 'hidden' });\n                            this.menu.hidden = true;\n                            return this.menu;\n                        }.bind(this),\n                        destroy: function () {\n                            if (!this.menu.outer_selector) {\n                                return this.menu;\n                            }\n                            this.menu.inner_selector.remove();\n                            this.menu.outer_selector.remove();\n                            this.menu.inner_selector = null;\n                            this.menu.outer_selector = null;\n                            return this.menu;\n                        }.bind(this),\n                        /**\n         * Internal method definition\n         * By convention populate() does nothing and should be reimplemented with each dashboard button definition\n         *   Reimplement by way of Dashboard.Component.Button.menu.setPopulate to define the populate method and hook\n         *   up standard menu click-toggle behavior prototype.\n         * @protected\n         */\n                        populate: function () {\n                        }.bind(this),\n                        /**\n         * Define how the menu is populated with items, and set up click and display properties as appropriate\n         * @public\n         */\n                        setPopulate: function (menu_populate_function) {\n                            if (typeof menu_populate_function == 'function') {\n                                this.menu.populate = menu_populate_function;\n                                this.setOnclick(function () {\n                                    if (this.menu.hidden) {\n                                        this.menu.show();\n                                        this.highlight().update();\n                                        this.persist = true;\n                                    } else {\n                                        this.menu.hide();\n                                        this.highlight(false).update();\n                                        if (!this.permanent) {\n                                            this.persist = false;\n                                        }\n                                    }\n                                }.bind(this));\n                            } else {\n                                this.setOnclick();\n                            }\n                            return this;\n                        }.bind(this)\n                    };\n                };\n                /**\n * Renders arbitrary text with title formatting\n * @class LocusZoom.Dashboard.Components.title\n * @augments LocusZoom.Dashboard.Component\n * @param {object} layout\n * @param {string} layout.title Text to render\n */\n                LocusZoom.Dashboard.Components.add('title', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    this.show = function () {\n                        this.div_selector = this.parent.selector.append('div').attr('class', 'lz-dashboard-title lz-dashboard-' + this.layout.position);\n                        this.title_selector = this.div_selector.append('h3');\n                        return this.update();\n                    };\n                    this.update = function () {\n                        var title = layout.title.toString();\n                        if (this.layout.subtitle) {\n                            title += ' <small>' + this.layout.subtitle + '</small>';\n                        }\n                        this.title_selector.html(title);\n                        return this;\n                    };\n                });\n                /**\n * Renders text to display the current dimensions of the plot. Automatically updated as plot dimensions change\n * @class LocusZoom.Dashboard.Components.dimensions\n * @augments LocusZoom.Dashboard.Component\n */\n                LocusZoom.Dashboard.Components.add('dimensions', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    this.update = function () {\n                        var display_width = this.parent_plot.layout.width.toString().indexOf('.') === -1 ? this.parent_plot.layout.width : this.parent_plot.layout.width.toFixed(2);\n                        var display_height = this.parent_plot.layout.height.toString().indexOf('.') === -1 ? this.parent_plot.layout.height : this.parent_plot.layout.height.toFixed(2);\n                        this.selector.html(display_width + 'px \\xD7 ' + display_height + 'px');\n                        if (layout.class) {\n                            this.selector.attr('class', layout.class);\n                        }\n                        if (layout.style) {\n                            this.selector.style(layout.style);\n                        }\n                        return this;\n                    };\n                });\n                /**\n * Display the current scale of the genome region displayed in the plot, as defined by the difference between\n *  `state.end` and `state.start`.\n * @class LocusZoom.Dashboard.Components.region_scale\n * @augments LocusZoom.Dashboard.Component\n */\n                LocusZoom.Dashboard.Components.add('region_scale', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    this.update = function () {\n                        if (!isNaN(this.parent_plot.state.start) && !isNaN(this.parent_plot.state.end) && this.parent_plot.state.start !== null && this.parent_plot.state.end !== null) {\n                            this.selector.style('display', null);\n                            this.selector.html(LocusZoom.positionIntToString(this.parent_plot.state.end - this.parent_plot.state.start, null, true));\n                        } else {\n                            this.selector.style('display', 'none');\n                        }\n                        if (layout.class) {\n                            this.selector.attr('class', layout.class);\n                        }\n                        if (layout.style) {\n                            this.selector.style(layout.style);\n                        }\n                        return this;\n                    };\n                });\n                /**\n * Button to export current plot to an SVG image\n * @class LocusZoom.Dashboard.Components.download\n * @augments LocusZoom.Dashboard.Component\n */\n                LocusZoom.Dashboard.Components.add('download', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    this.update = function () {\n                        if (this.button) {\n                            return this;\n                        }\n                        this.button = new LocusZoom.Dashboard.Component.Button(this).setColor(layout.color).setHtml('Download Image').setTitle('Download image of the current plot as locuszoom.svg').setOnMouseover(function () {\n                            this.button.selector.classed('lz-dashboard-button-gray-disabled', true).html('Preparing Image');\n                            this.generateBase64SVG().then(function (url) {\n                                var old = this.button.selector.attr('href');\n                                if (old) {\n                                    URL.revokeObjectURL(old);\n                                }\n                                // Clean up old url instance to prevent memory leaks\n                                this.button.selector.attr('href', url).classed('lz-dashboard-button-gray-disabled', false).classed('lz-dashboard-button-gray-highlighted', true).html('Download Image');\n                            }.bind(this));\n                        }.bind(this)).setOnMouseout(function () {\n                            this.button.selector.classed('lz-dashboard-button-gray-highlighted', false);\n                        }.bind(this));\n                        this.button.show();\n                        this.button.selector.attr('href-lang', 'image/svg+xml').attr('download', 'locuszoom.svg');\n                        return this;\n                    };\n                    this.css_string = '';\n                    for (var stylesheet in Object.keys(document.styleSheets)) {\n                        if (document.styleSheets[stylesheet].href !== null && document.styleSheets[stylesheet].href.indexOf('locuszoom.css') !== -1) {\n                            // TODO: \"Download image\" button will render the image incorrectly if the stylesheet has been renamed or concatenated\n                            LocusZoom.createCORSPromise('GET', document.styleSheets[stylesheet].href).then(function (response) {\n                                this.css_string = response.replace(/[\\r\\n]/g, ' ').replace(/\\s+/g, ' ');\n                                if (this.css_string.indexOf('/* ! LocusZoom HTML Styles */')) {\n                                    this.css_string = this.css_string.substring(0, this.css_string.indexOf('/* ! LocusZoom HTML Styles */'));\n                                }\n                            }.bind(this));\n                            break;\n                        }\n                    }\n                    this.generateBase64SVG = function () {\n                        return new Promise(function (resolve, reject) {\n                            // Insert a hidden div, clone the node into that so we can modify it with d3\n                            var container = this.parent.selector.append('div').style('display', 'none').html(this.parent_plot.svg.node().outerHTML);\n                            // Remove unnecessary elements\n                            container.selectAll('g.lz-curtain').remove();\n                            container.selectAll('g.lz-mouse_guide').remove();\n                            // Convert units on axis tick dy attributes from ems to pixels\n                            container.selectAll('g.tick text').each(function () {\n                                var dy = +d3.select(this).attr('dy').substring(-2).slice(0, -2) * 10;\n                                d3.select(this).attr('dy', dy);\n                            });\n                            // Pull the svg into a string and add the contents of the locuszoom stylesheet\n                            // Don't add this with d3 because it will escape the CDATA declaration incorrectly\n                            var initial_html = d3.select(container.select('svg').node().parentNode).html();\n                            var style_def = '<style type=\"text/css\"><![CDATA[ ' + this.css_string + ' ]]></style>';\n                            var insert_at = initial_html.indexOf('>') + 1;\n                            initial_html = initial_html.slice(0, insert_at) + style_def + initial_html.slice(insert_at);\n                            // Delete the container node\n                            container.remove();\n                            // Create an object URL based on the rendered markup\n                            var content = new Blob([initial_html], { type: 'image/svg+xml' });\n                            resolve(URL.createObjectURL(content));\n                        }.bind(this));\n                    };\n                });\n                /**\n * Button to remove panel from plot.\n *   NOTE: Will only work on panel dashboards.\n * @class LocusZoom.Dashboard.Components.remove_panel\n * @augments LocusZoom.Dashboard.Component\n * @param {Boolean} [layout.suppress_confirm=false] If true, removes the panel without prompting user for confirmation\n */\n                LocusZoom.Dashboard.Components.add('remove_panel', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    this.update = function () {\n                        if (this.button) {\n                            return this;\n                        }\n                        this.button = new LocusZoom.Dashboard.Component.Button(this).setColor(layout.color).setHtml('\\xD7').setTitle('Remove panel').setOnclick(function () {\n                            if (!layout.suppress_confirm && !confirm('Are you sure you want to remove this panel? This cannot be undone!')) {\n                                return false;\n                            }\n                            var panel = this.parent_panel;\n                            panel.dashboard.hide(true);\n                            d3.select(panel.parent.svg.node().parentNode).on('mouseover.' + panel.getBaseId() + '.dashboard', null);\n                            d3.select(panel.parent.svg.node().parentNode).on('mouseout.' + panel.getBaseId() + '.dashboard', null);\n                            return panel.parent.removePanel(panel.id);\n                        }.bind(this));\n                        this.button.show();\n                        return this;\n                    };\n                });\n                /**\n * Button to move panel up relative to other panels (in terms of y-index on the page)\n *   NOTE: Will only work on panel dashboards.\n * @class LocusZoom.Dashboard.Components.move_panel_up\n * @augments LocusZoom.Dashboard.Component\n */\n                LocusZoom.Dashboard.Components.add('move_panel_up', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    this.update = function () {\n                        if (this.button) {\n                            var is_at_top = this.parent_panel.layout.y_index === 0;\n                            this.button.disable(is_at_top);\n                            return this;\n                        }\n                        this.button = new LocusZoom.Dashboard.Component.Button(this).setColor(layout.color).setHtml('\\u25B4').setTitle('Move panel up').setOnclick(function () {\n                            this.parent_panel.moveUp();\n                            this.update();\n                        }.bind(this));\n                        this.button.show();\n                        return this.update();\n                    };\n                });\n                /**\n * Button to move panel down relative to other panels (in terms of y-index on the page)\n *   NOTE: Will only work on panel dashboards.\n * @class LocusZoom.Dashboard.Components.move_panel_down\n * @augments LocusZoom.Dashboard.Component\n */\n                LocusZoom.Dashboard.Components.add('move_panel_down', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    this.update = function () {\n                        if (this.button) {\n                            var is_at_bottom = this.parent_panel.layout.y_index === this.parent_plot.panel_ids_by_y_index.length - 1;\n                            this.button.disable(is_at_bottom);\n                            return this;\n                        }\n                        this.button = new LocusZoom.Dashboard.Component.Button(this).setColor(layout.color).setHtml('\\u25BE').setTitle('Move panel down').setOnclick(function () {\n                            this.parent_panel.moveDown();\n                            this.update();\n                        }.bind(this));\n                        this.button.show();\n                        return this.update();\n                    };\n                });\n                /**\n * Button to shift plot region forwards or back by a `step` increment provided in the layout\n * @class LocusZoom.Dashboard.Components.shift_region\n * @augments LocusZoom.Dashboard.Component\n * @param {object} layout\n * @param {number} [layout.step=50000] The stepsize to change the region by\n * @param {string} [layout.button_html]\n * @param {string} [layout.button_title]\n */\n                LocusZoom.Dashboard.Components.add('shift_region', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    if (isNaN(this.parent_plot.state.start) || isNaN(this.parent_plot.state.end)) {\n                        this.update = function () {\n                        };\n                        console.warn('Unable to add shift_region dashboard component: plot state does not have region bounds');\n                        return;\n                    }\n                    if (isNaN(layout.step) || layout.step === 0) {\n                        layout.step = 50000;\n                    }\n                    if (typeof layout.button_html !== 'string') {\n                        layout.button_html = layout.step > 0 ? '>' : '<';\n                    }\n                    if (typeof layout.button_title !== 'string') {\n                        layout.button_title = 'Shift region by ' + (layout.step > 0 ? '+' : '-') + LocusZoom.positionIntToString(Math.abs(layout.step), null, true);\n                    }\n                    this.update = function () {\n                        if (this.button) {\n                            return this;\n                        }\n                        this.button = new LocusZoom.Dashboard.Component.Button(this).setColor(layout.color).setHtml(layout.button_html).setTitle(layout.button_title).setOnclick(function () {\n                            this.parent_plot.applyState({\n                                start: Math.max(this.parent_plot.state.start + layout.step, 1),\n                                end: this.parent_plot.state.end + layout.step\n                            });\n                        }.bind(this));\n                        this.button.show();\n                        return this;\n                    };\n                });\n                /**\n * Zoom in or out on the plot, centered on the middle of the plot region, by the specified amount\n * @class LocusZoom.Dashboard.Components.zoom_region\n * @augments LocusZoom.Dashboard.Component\n * @param {object} layout\n * @param {number} [layout.step=0.2] The amount to zoom in by (where 1 indicates 100%)\n */\n                LocusZoom.Dashboard.Components.add('zoom_region', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    if (isNaN(this.parent_plot.state.start) || isNaN(this.parent_plot.state.end)) {\n                        this.update = function () {\n                        };\n                        console.warn('Unable to add zoom_region dashboard component: plot state does not have region bounds');\n                        return;\n                    }\n                    if (isNaN(layout.step) || layout.step === 0) {\n                        layout.step = 0.2;\n                    }\n                    if (typeof layout.button_html != 'string') {\n                        layout.button_html = layout.step > 0 ? 'z\\u2013' : 'z+';\n                    }\n                    if (typeof layout.button_title != 'string') {\n                        layout.button_title = 'Zoom region ' + (layout.step > 0 ? 'out' : 'in') + ' by ' + (Math.abs(layout.step) * 100).toFixed(1) + '%';\n                    }\n                    this.update = function () {\n                        if (this.button) {\n                            var can_zoom = true;\n                            var current_region_scale = this.parent_plot.state.end - this.parent_plot.state.start;\n                            if (layout.step > 0 && !isNaN(this.parent_plot.layout.max_region_scale) && current_region_scale >= this.parent_plot.layout.max_region_scale) {\n                                can_zoom = false;\n                            }\n                            if (layout.step < 0 && !isNaN(this.parent_plot.layout.min_region_scale) && current_region_scale <= this.parent_plot.layout.min_region_scale) {\n                                can_zoom = false;\n                            }\n                            this.button.disable(!can_zoom);\n                            return this;\n                        }\n                        this.button = new LocusZoom.Dashboard.Component.Button(this).setColor(layout.color).setHtml(layout.button_html).setTitle(layout.button_title).setOnclick(function () {\n                            var current_region_scale = this.parent_plot.state.end - this.parent_plot.state.start;\n                            var zoom_factor = 1 + layout.step;\n                            var new_region_scale = current_region_scale * zoom_factor;\n                            if (!isNaN(this.parent_plot.layout.max_region_scale)) {\n                                new_region_scale = Math.min(new_region_scale, this.parent_plot.layout.max_region_scale);\n                            }\n                            if (!isNaN(this.parent_plot.layout.min_region_scale)) {\n                                new_region_scale = Math.max(new_region_scale, this.parent_plot.layout.min_region_scale);\n                            }\n                            var delta = Math.floor((new_region_scale - current_region_scale) / 2);\n                            this.parent_plot.applyState({\n                                start: Math.max(this.parent_plot.state.start - delta, 1),\n                                end: this.parent_plot.state.end + delta\n                            });\n                        }.bind(this));\n                        this.button.show();\n                        return this;\n                    };\n                });\n                /**\n * Renders button with arbitrary text that, when clicked, shows a dropdown containing arbitrary HTML\n *  NOTE: Trusts content exactly as given. XSS prevention is the responsibility of the implementer.\n * @class LocusZoom.Dashboard.Components.menu\n * @augments LocusZoom.Dashboard.Component\n * @param {object} layout\n * @param {string} layout.button_html The HTML to render inside the button\n * @param {string} layout.button_title Text to display as a tooltip when hovering over the button\n * @param {string} layout.menu_html The HTML content of the dropdown menu\n */\n                LocusZoom.Dashboard.Components.add('menu', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    this.update = function () {\n                        if (this.button) {\n                            return this;\n                        }\n                        this.button = new LocusZoom.Dashboard.Component.Button(this).setColor(layout.color).setHtml(layout.button_html).setTitle(layout.button_title);\n                        this.button.menu.setPopulate(function () {\n                            this.button.menu.inner_selector.html(layout.menu_html);\n                        }.bind(this));\n                        this.button.show();\n                        return this;\n                    };\n                });\n                /**\n * Special button/menu to allow model building by tracking individual covariants. Will track a list of covariate\n *   objects and store them in the special `model.covariates` field of plot `state`.\n * @class LocusZoom.Dashboard.Components.covariates_model\n * @augments LocusZoom.Dashboard.Component\n * @param {object} layout\n * @param {string} layout.button_html The HTML to render inside the button\n * @param {string} layout.button_title Text to display as a tooltip when hovering over the button\n */\n                LocusZoom.Dashboard.Components.add('covariates_model', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    this.initialize = function () {\n                        // Initialize state.model.covariates\n                        this.parent_plot.state.model = this.parent_plot.state.model || {};\n                        this.parent_plot.state.model.covariates = this.parent_plot.state.model.covariates || [];\n                        // Create an object at the plot level for easy access to interface methods in custom client-side JS\n                        /**\n         * When a covariates model dashboard element is present, create (one) object at the plot level that exposes\n         *   component data and state for custom interactions with other plot elements.\n         * @class LocusZoom.Plot.CovariatesModel\n         */\n                        this.parent_plot.CovariatesModel = {\n                            /** @member {LocusZoom.Dashboard.Component.Button} */\n                            button: this,\n                            /**\n             * Add an element to the model and show a representation of it in the dashboard component menu. If the\n             *   element is already part of the model, do nothing (to avoid adding duplicates).\n             * When plot state is changed, this will automatically trigger requests for new data accordingly.\n             * @param {string|object} element_reference Can be any value that can be put through JSON.stringify()\n             *   to create a serialized representation of itself.\n             */\n                            add: function (element_reference) {\n                                var element = JSON.parse(JSON.stringify(element_reference));\n                                if (typeof element_reference == 'object' && typeof element.html != 'string') {\n                                    element.html = typeof element_reference.toHTML == 'function' ? element_reference.toHTML() : element_reference.toString();\n                                }\n                                // Check if the element is already in the model covariates array and return if it is.\n                                for (var i = 0; i < this.state.model.covariates.length; i++) {\n                                    if (JSON.stringify(this.state.model.covariates[i]) === JSON.stringify(element)) {\n                                        return this;\n                                    }\n                                }\n                                this.state.model.covariates.push(element);\n                                this.applyState();\n                                this.CovariatesModel.updateComponent();\n                                return this;\n                            }.bind(this.parent_plot),\n                            /**\n             * Remove an element from `state.model.covariates` (and from the dashboard component menu's\n             *  representation of the state model). When plot state is changed, this will automatically trigger\n             *  requests for new data accordingly.\n             * @param {number} idx Array index of the element, in the `state.model.covariates array`.\n             */\n                            removeByIdx: function (idx) {\n                                if (typeof this.state.model.covariates[idx] == 'undefined') {\n                                    throw new Error('Unable to remove model covariate, invalid index: ' + idx.toString());\n                                }\n                                this.state.model.covariates.splice(idx, 1);\n                                this.applyState();\n                                this.CovariatesModel.updateComponent();\n                                return this;\n                            }.bind(this.parent_plot),\n                            /**\n             * Empty the `state.model.covariates` array (and dashboard component menu representation thereof) of all\n             *  elements. When plot state is changed, this will automatically trigger requests for new data accordingly\n             */\n                            removeAll: function () {\n                                this.state.model.covariates = [];\n                                this.applyState();\n                                this.CovariatesModel.updateComponent();\n                                return this;\n                            }.bind(this.parent_plot),\n                            /**\n             * Manually trigger the update methods on the dashboard component's button and menu elements to force\n             *   display of most up-to-date content. Can be used to force the dashboard to reflect changes made, eg if\n             *   modifying `state.model.covariates` directly instead of via `plot.CovariatesModel`\n             */\n                            updateComponent: function () {\n                                this.button.update();\n                                this.button.menu.update();\n                            }.bind(this)\n                        };\n                    }.bind(this);\n                    this.update = function () {\n                        if (this.button) {\n                            return this;\n                        }\n                        this.button = new LocusZoom.Dashboard.Component.Button(this).setColor(layout.color).setHtml(layout.button_html).setTitle(layout.button_title).setOnclick(function () {\n                            this.button.menu.populate();\n                        }.bind(this));\n                        this.button.menu.setPopulate(function () {\n                            var selector = this.button.menu.inner_selector;\n                            selector.html('');\n                            // General model HTML representation\n                            if (typeof this.parent_plot.state.model.html != 'undefined') {\n                                selector.append('div').html(this.parent_plot.state.model.html);\n                            }\n                            // Model covariates table\n                            if (!this.parent_plot.state.model.covariates.length) {\n                                selector.append('i').html('no covariates in model');\n                            } else {\n                                selector.append('h5').html('Model Covariates (' + this.parent_plot.state.model.covariates.length + ')');\n                                var table = selector.append('table');\n                                this.parent_plot.state.model.covariates.forEach(function (covariate, idx) {\n                                    var html = typeof covariate == 'object' && typeof covariate.html == 'string' ? covariate.html : covariate.toString();\n                                    var row = table.append('tr');\n                                    row.append('td').append('button').attr('class', 'lz-dashboard-button lz-dashboard-button-' + this.layout.color).style({ 'margin-left': '0em' }).on('click', function () {\n                                        this.parent_plot.CovariatesModel.removeByIdx(idx);\n                                    }.bind(this)).html('\\xD7');\n                                    row.append('td').html(html);\n                                }.bind(this));\n                                selector.append('button').attr('class', 'lz-dashboard-button lz-dashboard-button-' + this.layout.color).style({ 'margin-left': '4px' }).html('\\xD7 Remove All Covariates').on('click', function () {\n                                    this.parent_plot.CovariatesModel.removeAll();\n                                }.bind(this));\n                            }\n                        }.bind(this));\n                        this.button.preUpdate = function () {\n                            var html = 'Model';\n                            if (this.parent_plot.state.model.covariates.length) {\n                                var cov = this.parent_plot.state.model.covariates.length > 1 ? 'covariates' : 'covariate';\n                                html += ' (' + this.parent_plot.state.model.covariates.length + ' ' + cov + ')';\n                            }\n                            this.button.setHtml(html).disable(false);\n                        }.bind(this);\n                        this.button.show();\n                        return this;\n                    };\n                });\n                /**\n * Button to toggle split tracks\n * @class LocusZoom.Dashboard.Components.toggle_split_tracks\n * @augments LocusZoom.Dashboard.Component\n */\n                LocusZoom.Dashboard.Components.add('toggle_split_tracks', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    if (!layout.data_layer_id) {\n                        layout.data_layer_id = 'intervals';\n                    }\n                    if (!this.parent_panel.data_layers[layout.data_layer_id]) {\n                        throw new Error('Dashboard toggle split tracks component missing valid data layer ID');\n                    }\n                    this.update = function () {\n                        var data_layer = this.parent_panel.data_layers[layout.data_layer_id];\n                        var html = data_layer.layout.split_tracks ? 'Merge Tracks' : 'Split Tracks';\n                        if (this.button) {\n                            this.button.setHtml(html);\n                            this.button.show();\n                            this.parent.position();\n                            return this;\n                        } else {\n                            this.button = new LocusZoom.Dashboard.Component.Button(this).setColor(layout.color).setHtml(html).setTitle('Toggle whether tracks are split apart or merged together').setOnclick(function () {\n                                data_layer.toggleSplitTracks();\n                                if (this.scale_timeout) {\n                                    clearTimeout(this.scale_timeout);\n                                }\n                                var timeout = data_layer.layout.transition ? +data_layer.layout.transition.duration || 0 : 0;\n                                this.scale_timeout = setTimeout(function () {\n                                    this.parent_panel.scaleHeightToData();\n                                    this.parent_plot.positionPanels();\n                                }.bind(this), timeout);\n                                this.update();\n                            }.bind(this));\n                            return this.update();\n                        }\n                    };\n                });\n                /**\n * Button to resize panel height to fit available data (eg when showing a list of tracks)\n * @class LocusZoom.Dashboard.Components.resize_to_data\n * @augments LocusZoom.Dashboard.Component\n */\n                LocusZoom.Dashboard.Components.add('resize_to_data', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    this.update = function () {\n                        if (this.button) {\n                            return this;\n                        }\n                        this.button = new LocusZoom.Dashboard.Component.Button(this).setColor(layout.color).setHtml('Resize to Data').setTitle('Automatically resize this panel to fit the data its currently showing').setOnclick(function () {\n                            this.parent_panel.scaleHeightToData();\n                            this.update();\n                        }.bind(this));\n                        this.button.show();\n                        return this;\n                    };\n                });\n                /**\n * Button to toggle legend\n * @class LocusZoom.Dashboard.Components.toggle_legend\n * @augments LocusZoom.Dashboard.Component\n */\n                LocusZoom.Dashboard.Components.add('toggle_legend', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    this.update = function () {\n                        var html = this.parent_panel.legend.layout.hidden ? 'Show Legend' : 'Hide Legend';\n                        if (this.button) {\n                            this.button.setHtml(html).show();\n                            this.parent.position();\n                            return this;\n                        }\n                        this.button = new LocusZoom.Dashboard.Component.Button(this).setColor(layout.color).setTitle('Show or hide the legend for this panel').setOnclick(function () {\n                            this.parent_panel.legend.layout.hidden = !this.parent_panel.legend.layout.hidden;\n                            this.parent_panel.legend.render();\n                            this.update();\n                        }.bind(this));\n                        return this.update();\n                    };\n                });\n                /**\n * Menu for manipulating multiple data layers in a single panel: show/hide, change order, etc.\n * @class LocusZoom.Dashboard.Components.data_layers\n * @augments LocusZoom.Dashboard.Component\n */\n                LocusZoom.Dashboard.Components.add('data_layers', function (layout) {\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    this.update = function () {\n                        if (typeof layout.button_html != 'string') {\n                            layout.button_html = 'Data Layers';\n                        }\n                        if (typeof layout.button_title != 'string') {\n                            layout.button_title = 'Manipulate Data Layers (sort, dim, show/hide, etc.)';\n                        }\n                        if (this.button) {\n                            return this;\n                        }\n                        this.button = new LocusZoom.Dashboard.Component.Button(this).setColor(layout.color).setHtml(layout.button_html).setTitle(layout.button_title).setOnclick(function () {\n                            this.button.menu.populate();\n                        }.bind(this));\n                        this.button.menu.setPopulate(function () {\n                            this.button.menu.inner_selector.html('');\n                            var table = this.button.menu.inner_selector.append('table');\n                            this.parent_panel.data_layer_ids_by_z_index.slice().reverse().forEach(function (id, idx) {\n                                var data_layer = this.parent_panel.data_layers[id];\n                                var name = typeof data_layer.layout.name != 'string' ? data_layer.id : data_layer.layout.name;\n                                var row = table.append('tr');\n                                // Layer name\n                                row.append('td').html(name);\n                                // Status toggle buttons\n                                layout.statuses.forEach(function (status_adj) {\n                                    var status_idx = LocusZoom.DataLayer.Statuses.adjectives.indexOf(status_adj);\n                                    var status_verb = LocusZoom.DataLayer.Statuses.verbs[status_idx];\n                                    var html, onclick, highlight;\n                                    if (data_layer.global_statuses[status_adj]) {\n                                        html = LocusZoom.DataLayer.Statuses.menu_antiverbs[status_idx];\n                                        onclick = 'un' + status_verb + 'AllElements';\n                                        highlight = '-highlighted';\n                                    } else {\n                                        html = LocusZoom.DataLayer.Statuses.verbs[status_idx];\n                                        onclick = status_verb + 'AllElements';\n                                        highlight = '';\n                                    }\n                                    row.append('td').append('a').attr('class', 'lz-dashboard-button lz-dashboard-button-' + this.layout.color + highlight).style({ 'margin-left': '0em' }).on('click', function () {\n                                        data_layer[onclick]();\n                                        this.button.menu.populate();\n                                    }.bind(this)).html(html);\n                                }.bind(this));\n                                // Sort layer buttons\n                                var at_top = idx === 0;\n                                var at_bottom = idx === this.parent_panel.data_layer_ids_by_z_index.length - 1;\n                                var td = row.append('td');\n                                td.append('a').attr('class', 'lz-dashboard-button lz-dashboard-button-group-start lz-dashboard-button-' + this.layout.color + (at_bottom ? '-disabled' : '')).style({ 'margin-left': '0em' }).on('click', function () {\n                                    data_layer.moveDown();\n                                    this.button.menu.populate();\n                                }.bind(this)).html('\\u25BE').attr('title', 'Move layer down (further back)');\n                                td.append('a').attr('class', 'lz-dashboard-button lz-dashboard-button-group-middle lz-dashboard-button-' + this.layout.color + (at_top ? '-disabled' : '')).style({ 'margin-left': '0em' }).on('click', function () {\n                                    data_layer.moveUp();\n                                    this.button.menu.populate();\n                                }.bind(this)).html('\\u25B4').attr('title', 'Move layer up (further front)');\n                                td.append('a').attr('class', 'lz-dashboard-button lz-dashboard-button-group-end lz-dashboard-button-red').style({ 'margin-left': '0em' }).on('click', function () {\n                                    if (confirm('Are you sure you want to remove the ' + name + ' layer? This cannot be undone!')) {\n                                        data_layer.parent.removeDataLayer(id);\n                                    }\n                                    return this.button.menu.populate();\n                                }.bind(this)).html('\\xD7').attr('title', 'Remove layer');\n                            }.bind(this));\n                            return this;\n                        }.bind(this));\n                        this.button.show();\n                        return this;\n                    };\n                });\n                /**\n * Dropdown menu allowing the user to choose between different display options for a single specific data layer\n *  within a panel.\n *\n * This allows controlling how points on a datalayer can be displayed- any display options supported via the layout for the target datalayer. This includes point\n *  size/shape, coloring, etc.\n *\n * This button intentionally limits display options it can control to those available on common plot types.\n *   Although the list of options it sets can be overridden (to control very special custom plot types), this\n *   capability should be used sparingly if at all.\n *\n * @class LocusZoom.Dashboard.Components.display_options\n * @augments LocusZoom.Dashboard.Component\n * @param {object} layout\n * @param {String} [layout.button_html=\"Display options...\"] Text to display on the toolbar button\n * @param {String} [layout.button_title=\"Control how plot items are displayed\"] Hover text for the toolbar button\n * @param {string} layout.layer_name Specify the datalayer that this button should affect\n * @param {string} [layout.default_config_display_name] Store the default configuration for this datalayer\n *  configuration, and show a button to revert to the \"default\" (listing the human-readable display name provided)\n * @param {Array} [layout.fields_whitelist='see code'] The list of presentation fields that this button can control.\n *  This can be overridden if this button needs to be used on a custom layer type with special options.\n * @typedef {{display_name: string, display: Object}} DisplayOptionsButtonConfigField\n * @param {DisplayOptionsButtonConfigField[]} layout.options Specify a label and set of layout directives associated\n *  with this `display` option. Display field should include all changes to datalayer presentation options.\n */\n                LocusZoom.Dashboard.Components.add('display_options', function (layout) {\n                    if (typeof layout.button_html != 'string') {\n                        layout.button_html = 'Display options...';\n                    }\n                    if (typeof layout.button_title != 'string') {\n                        layout.button_title = 'Control how plot items are displayed';\n                    }\n                    // Call parent constructor\n                    LocusZoom.Dashboard.Component.apply(this, arguments);\n                    // List of layout fields that this button is allowed to control. This ensures that we don't override any other\n                    //  information (like plot height etc) while changing point rendering\n                    var allowed_fields = layout.fields_whitelist || [\n                        'color',\n                        'fill_opacity',\n                        'label',\n                        'legend',\n                        'point_shape',\n                        'point_size',\n                        'tooltip',\n                        'tooltip_positioning'\n                    ];\n                    var dataLayer = this.parent_panel.data_layers[layout.layer_name];\n                    if (!dataLayer) {\n                        throw new Error('Display options could not locate the specified layer_name: \\'' + layout.layer_name + '\\'');\n                    }\n                    var dataLayerLayout = dataLayer.layout;\n                    // Store default configuration for the layer as a clean deep copy, so we may revert later\n                    var defaultConfig = {};\n                    allowed_fields.forEach(function (name) {\n                        var configSlot = dataLayerLayout[name];\n                        if (configSlot !== undefined) {\n                            defaultConfig[name] = JSON.parse(JSON.stringify(configSlot));\n                        }\n                    });\n                    /**\n     * Which item in the menu is currently selected. (track for rerendering menu)\n     * @member {String}\n     * @private\n     */\n                    this._selected_item = 'default';\n                    // Define the button + menu that provides the real functionality for this dashboard component\n                    var self = this;\n                    this.button = new LocusZoom.Dashboard.Component.Button(self).setColor(layout.color).setHtml(layout.button_html).setTitle(layout.button_title).setOnclick(function () {\n                        self.button.menu.populate();\n                    });\n                    this.button.menu.setPopulate(function () {\n                        // Multiple copies of this button might be used on a single LZ page; append unique IDs where needed\n                        var uniqueID = Math.floor(Math.random() * 10000).toString();\n                        self.button.menu.inner_selector.html('');\n                        var table = self.button.menu.inner_selector.append('table');\n                        var menuLayout = self.layout;\n                        var renderRow = function (display_name, display_options, row_id) {\n                            // Helper method\n                            var row = table.append('tr');\n                            var radioId = '' + uniqueID + row_id;\n                            row.append('td').append('input').attr({\n                                id: radioId,\n                                type: 'radio',\n                                name: 'display-option-' + uniqueID,\n                                value: row_id\n                            }).style('margin', 0)    // Override css libraries (eg skeleton) that style form inputs\n.property('checked', row_id === self._selected_item).on('click', function () {\n                                // If an option is not specified in these display options, use the original defaults\n                                allowed_fields.forEach(function (field_name) {\n                                    dataLayer.layout[field_name] = display_options[field_name] || defaultConfig[field_name];\n                                });\n                                self._selected_item = row_id;\n                                self.parent_panel.render();\n                                var legend = self.parent_panel.legend;\n                                if (legend) {\n                                    legend.render();\n                                }\n                            });\n                            row.append('td').append('label').style('font-weight', 'normal').attr('for', radioId).text(display_name);\n                        };\n                        // Render the \"display options\" menu: default and special custom options\n                        var defaultName = menuLayout.default_config_display_name || 'Default style';\n                        renderRow(defaultName, defaultConfig, 'default');\n                        menuLayout.options.forEach(function (item, index) {\n                            renderRow(item.display_name, item.display, index);\n                        });\n                        return self;\n                    });\n                    this.update = function () {\n                        this.button.show();\n                        return this;\n                    };\n                });\n                /* global LocusZoom */\n                'use strict';\n                /**\n * An SVG object used to display contextual information about a panel.\n * Panel layouts determine basic features of a legend - its position in the panel, orientation, title, etc.\n * Layouts of child data layers of the panel determine the actual content of the legend.\n *\n * @class\n * @param {LocusZoom.Panel} parent\n*/\n                LocusZoom.Legend = function (parent) {\n                    if (!(parent instanceof LocusZoom.Panel)) {\n                        throw new Error('Unable to create legend, parent must be a locuszoom panel');\n                    }\n                    /** @member {LocusZoom.Panel} */\n                    this.parent = parent;\n                    /** @member {String} */\n                    this.id = this.parent.getBaseId() + '.legend';\n                    this.parent.layout.legend = LocusZoom.Layouts.merge(this.parent.layout.legend || {}, LocusZoom.Legend.DefaultLayout);\n                    /** @member {Object} */\n                    this.layout = this.parent.layout.legend;\n                    /** @member {d3.selection} */\n                    this.selector = null;\n                    /** @member {d3.selection} */\n                    this.background_rect = null;\n                    /** @member {d3.selection[]} */\n                    this.elements = [];\n                    /**\n     * SVG selector for the group containing all elements in the legend\n     * @protected\n     * @member {d3.selection|null}\n     */\n                    this.elements_group = null;\n                    /**\n     * TODO: Not sure if this property is used; the external-facing methods are setting `layout.hidden` instead. Tentatively mark deprecated.\n     * @deprecated\n     * @protected\n     * @member {Boolean}\n     */\n                    this.hidden = false;\n                    // TODO Revisit constructor return value; see https://stackoverflow.com/a/3350364/1422268\n                    return this.render();\n                };\n                /**\n * The default layout used by legends (used internally)\n * @protected\n * @member {Object}\n */\n                LocusZoom.Legend.DefaultLayout = {\n                    orientation: 'vertical',\n                    origin: {\n                        x: 0,\n                        y: 0\n                    },\n                    width: 10,\n                    height: 10,\n                    padding: 5,\n                    label_size: 12,\n                    hidden: false\n                };\n                /**\n * Render the legend in the parent panel\n */\n                LocusZoom.Legend.prototype.render = function () {\n                    // Get a legend group selector if not yet defined\n                    if (!this.selector) {\n                        this.selector = this.parent.svg.group.append('g').attr('id', this.parent.getBaseId() + '.legend').attr('class', 'lz-legend');\n                    }\n                    // Get a legend background rect selector if not yet defined\n                    if (!this.background_rect) {\n                        this.background_rect = this.selector.append('rect').attr('width', 100).attr('height', 100).attr('class', 'lz-legend-background');\n                    }\n                    // Get a legend elements group selector if not yet defined\n                    if (!this.elements_group) {\n                        this.elements_group = this.selector.append('g');\n                    }\n                    // Remove all elements from the document and re-render from scratch\n                    this.elements.forEach(function (element) {\n                        element.remove();\n                    });\n                    this.elements = [];\n                    // Gather all elements from data layers in order (top to bottom) and render them\n                    var padding = +this.layout.padding || 1;\n                    var x = padding;\n                    var y = padding;\n                    var line_height = 0;\n                    this.parent.data_layer_ids_by_z_index.slice().reverse().forEach(function (id) {\n                        if (Array.isArray(this.parent.data_layers[id].layout.legend)) {\n                            this.parent.data_layers[id].layout.legend.forEach(function (element) {\n                                var selector = this.elements_group.append('g').attr('transform', 'translate(' + x + ',' + y + ')');\n                                var label_size = +element.label_size || +this.layout.label_size || 12;\n                                var label_x = 0;\n                                var label_y = label_size / 2 + padding / 2;\n                                line_height = Math.max(line_height, label_size + padding);\n                                // Draw the legend element symbol (line, rect, shape, etc)\n                                if (element.shape === 'line') {\n                                    // Line symbol\n                                    var length = +element.length || 16;\n                                    var path_y = label_size / 4 + padding / 2;\n                                    selector.append('path').attr('class', element.class || '').attr('d', 'M0,' + path_y + 'L' + length + ',' + path_y).style(element.style || {});\n                                    label_x = length + padding;\n                                } else if (element.shape === 'rect') {\n                                    // Rect symbol\n                                    var width = +element.width || 16;\n                                    var height = +element.height || width;\n                                    selector.append('rect').attr('class', element.class || '').attr('width', width).attr('height', height).attr('fill', element.color || {}).style(element.style || {});\n                                    label_x = width + padding;\n                                    line_height = Math.max(line_height, height + padding);\n                                } else if (d3.svg.symbolTypes.indexOf(element.shape) !== -1) {\n                                    // Shape symbol (circle, diamond, etc.)\n                                    var size = +element.size || 40;\n                                    var radius = Math.ceil(Math.sqrt(size / Math.PI));\n                                    selector.append('path').attr('class', element.class || '').attr('d', d3.svg.symbol().size(size).type(element.shape)).attr('transform', 'translate(' + radius + ',' + (radius + padding / 2) + ')').attr('fill', element.color || {}).style(element.style || {});\n                                    label_x = 2 * radius + padding;\n                                    label_y = Math.max(2 * radius + padding / 2, label_y);\n                                    line_height = Math.max(line_height, 2 * radius + padding);\n                                }\n                                // Draw the legend element label\n                                selector.append('text').attr('text-anchor', 'left').attr('class', 'lz-label').attr('x', label_x).attr('y', label_y).style({ 'font-size': label_size }).text(element.label);\n                                // Position the legend element group based on legend layout orientation\n                                var bcr = selector.node().getBoundingClientRect();\n                                if (this.layout.orientation === 'vertical') {\n                                    y += bcr.height + padding;\n                                    line_height = 0;\n                                } else {\n                                    // Ensure this element does not exceed the panel width\n                                    // (E.g. drop to the next line if it does, but only if it's not the only element on this line)\n                                    var right_x = this.layout.origin.x + x + bcr.width;\n                                    if (x > padding && right_x > this.parent.layout.width) {\n                                        y += line_height;\n                                        x = padding;\n                                        selector.attr('transform', 'translate(' + x + ',' + y + ')');\n                                    }\n                                    x += bcr.width + 3 * padding;\n                                }\n                                // Store the element\n                                this.elements.push(selector);\n                            }.bind(this));\n                        }\n                    }.bind(this));\n                    // Scale the background rect to the elements in the legend\n                    var bcr = this.elements_group.node().getBoundingClientRect();\n                    this.layout.width = bcr.width + 2 * this.layout.padding;\n                    this.layout.height = bcr.height + 2 * this.layout.padding;\n                    this.background_rect.attr('width', this.layout.width).attr('height', this.layout.height);\n                    // Set the visibility on the legend from the \"hidden\" flag\n                    // TODO: `show()` and `hide()` call a full rerender; might be able to make this more lightweight?\n                    this.selector.style({ visibility: this.layout.hidden ? 'hidden' : 'visible' });\n                    // TODO: Annotate return type and make consistent\n                    return this.position();\n                };\n                /**\n * Place the legend in position relative to the panel, as specified in the layout configuration\n * @returns {LocusZoom.Legend | null}\n * TODO: should this always be chainable?\n */\n                LocusZoom.Legend.prototype.position = function () {\n                    if (!this.selector) {\n                        return this;\n                    }\n                    var bcr = this.selector.node().getBoundingClientRect();\n                    if (!isNaN(+this.layout.pad_from_bottom)) {\n                        this.layout.origin.y = this.parent.layout.height - bcr.height - +this.layout.pad_from_bottom;\n                    }\n                    if (!isNaN(+this.layout.pad_from_right)) {\n                        this.layout.origin.x = this.parent.layout.width - bcr.width - +this.layout.pad_from_right;\n                    }\n                    this.selector.attr('transform', 'translate(' + this.layout.origin.x + ',' + this.layout.origin.y + ')');\n                };\n                /**\n * Hide the legend (triggers a re-render)\n * @public\n */\n                LocusZoom.Legend.prototype.hide = function () {\n                    this.layout.hidden = true;\n                    this.render();\n                };\n                /**\n * Show the legend (triggers a re-render)\n * @public\n */\n                LocusZoom.Legend.prototype.show = function () {\n                    this.layout.hidden = false;\n                    this.render();\n                };\n                /* global LocusZoom */\n                'use strict';\n                function validateBuildSource(class_name, build, source) {\n                    // Build OR Source, not both\n                    if (build && source || !(build || source)) {\n                        throw new Error(class_name + ' must provide a parameter specifying either \"build\" or \"source\". It should not specify both.');\n                    }\n                    // If the build isn't recognized, our APIs can't transparently select a source to match\n                    if (build && [\n                            'GRCh37',\n                            'GRCh38'\n                        ].indexOf(build) === -1) {\n                        throw new Error(class_name + ' must specify a valid genome build number');\n                    }\n                }\n                /**\n * LocusZoom functionality used for data parsing and retrieval\n * @namespace\n * @public\n */\n                LocusZoom.Data = LocusZoom.Data || {};\n                /**\n * Create and coordinate an ensemble of (namespaced) data source instances\n * @public\n * @class\n */\n                LocusZoom.DataSources = function () {\n                    /** @member {Object.<string, LocusZoom.Data.Source>} */\n                    this.sources = {};\n                };\n                /** @deprecated */\n                LocusZoom.DataSources.prototype.addSource = function (ns, x) {\n                    console.warn('Warning: .addSource() is deprecated. Use .add() instead');\n                    return this.add(ns, x);\n                };\n                /**\n * Add a (namespaced) datasource to the plot\n * @public\n * @param {String} ns A namespace used for fields from this data source\n * @param {LocusZoom.Data.Source|Array|null} x An instantiated datasource, or an array of arguments that can be used to\n *   create a known datasource type.\n */\n                LocusZoom.DataSources.prototype.add = function (ns, x) {\n                    // FIXME: Some existing sites create sources with arbitrary names. This leads to subtle breakage\n                    //    of namespaced fields in layouts. To avoid breaking existing usages outright, issue a deprecation warning.\n                    if (ns.match(/[^A-Za-z0-9_]/)) {\n                        console.warn('Deprecation warning: source name \\'' + ns + '\\' should contain only alphanumeric characters or underscores. Use of other characters may break layouts, and will be disallowed in the future.');\n                    }\n                    return this.set(ns, x);\n                };\n                /** @protected */\n                LocusZoom.DataSources.prototype.set = function (ns, x) {\n                    if (Array.isArray(x)) {\n                        // If passed array of source name and options, make the source\n                        var dsobj = LocusZoom.KnownDataSources.create.apply(null, x);\n                        // Each datasource in the chain should be aware of its assigned namespace\n                        dsobj.source_id = ns;\n                        this.sources[ns] = dsobj;\n                    } else {\n                        // If passed the already-created source object\n                        if (x !== null) {\n                            x.source_id = ns;\n                            this.sources[ns] = x;\n                        } else {\n                            delete this.sources[ns];\n                        }\n                    }\n                    return this;\n                };\n                /** @deprecated */\n                LocusZoom.DataSources.prototype.getSource = function (ns) {\n                    console.warn('Warning: .getSource() is deprecated. Use .get() instead');\n                    return this.get(ns);\n                };\n                /**\n * Return the datasource associated with a given namespace\n * @public\n * @param {String} ns Namespace\n * @returns {LocusZoom.Data.Source}\n */\n                LocusZoom.DataSources.prototype.get = function (ns) {\n                    return this.sources[ns];\n                };\n                /** @deprecated */\n                LocusZoom.DataSources.prototype.removeSource = function (ns) {\n                    console.warn('Warning: .removeSource() is deprecated. Use .remove() instead');\n                    return this.remove(ns);\n                };\n                /**\n * Remove the datasource associated with a given namespace\n * @public\n * @param {String} ns Namespace\n */\n                LocusZoom.DataSources.prototype.remove = function (ns) {\n                    return this.set(ns, null);\n                };\n                /**\n * Populate a list of datasources specified as a JSON object\n * @public\n * @param {String|Object} x An object or JSON representation containing {ns: configArray} entries\n * @returns {LocusZoom.DataSources}\n */\n                LocusZoom.DataSources.prototype.fromJSON = function (x) {\n                    if (typeof x === 'string') {\n                        x = JSON.parse(x);\n                    }\n                    var ds = this;\n                    Object.keys(x).forEach(function (ns) {\n                        ds.set(ns, x[ns]);\n                    });\n                    return ds;\n                };\n                /**\n * Return the names of all currently recognized datasources\n * @public\n * @returns {Array}\n */\n                LocusZoom.DataSources.prototype.keys = function () {\n                    return Object.keys(this.sources);\n                };\n                /**\n * Datasources can be instantiated from a JSON object instead of code. This represents existing sources in that format.\n *   For example, this can be helpful when sharing plots, or to share settings with others when debugging\n * @public\n */\n                LocusZoom.DataSources.prototype.toJSON = function () {\n                    return this.sources;\n                };\n                /**\n * Represents an addressable unit of data from a namespaced datasource, subject to specified value transformations.\n *\n * When used by a data layer, fields will automatically be re-fetched from the appropriate data source whenever the\n *   state of a plot fetches, eg pan or zoom operations that would affect what data is displayed.\n *\n * @public\n * @class\n * @param {String} field A string representing the namespace of the datasource, the name of the desired field to fetch\n *   from that datasource, and arbitrarily many transformations to apply to the value. The namespace and\n *   transformation(s) are optional and information is delimited according to the general syntax\n *   `[namespace:]name[|transformation][|transformation]`. For example, `association:pvalue|neglog10`\n */\n                LocusZoom.Data.Field = function (field) {\n                    var parts = /^(?:([^:]+):)?([^:|]*)(\\|.+)*$/.exec(field);\n                    /** @member {String} */\n                    this.full_name = field;\n                    /** @member {String} */\n                    this.namespace = parts[1] || null;\n                    /** @member {String} */\n                    this.name = parts[2] || null;\n                    /** @member {Array} */\n                    this.transformations = [];\n                    if (typeof parts[3] == 'string' && parts[3].length > 1) {\n                        this.transformations = parts[3].substring(1).split('|');\n                        this.transformations.forEach(function (transform, i) {\n                            this.transformations[i] = LocusZoom.TransformationFunctions.get(transform);\n                        }.bind(this));\n                    }\n                    this.applyTransformations = function (val) {\n                        this.transformations.forEach(function (transform) {\n                            val = transform(val);\n                        });\n                        return val;\n                    };\n                    // Resolve the field for a given data element.\n                    // First look for a full match with transformations already applied by the data requester.\n                    // Otherwise prefer a namespace match and fall back to just a name match, applying transformations on the fly.\n                    this.resolve = function (d) {\n                        if (typeof d[this.full_name] == 'undefined') {\n                            var val = null;\n                            if (typeof d[this.namespace + ':' + this.name] != 'undefined') {\n                                val = d[this.namespace + ':' + this.name];\n                            } else if (typeof d[this.name] != 'undefined') {\n                                val = d[this.name];\n                            }\n                            d[this.full_name] = this.applyTransformations(val);\n                        }\n                        return d[this.full_name];\n                    };\n                };\n                /**\n * The Requester manages fetching of data across multiple data sources. It is used internally by LocusZoom data layers.\n *   It passes state information and ensures that data is formatted in the manner expected by the plot.\n *\n * It is also responsible for constructing a \"chain\" of dependent requests, by requesting each datasource\n *   sequentially in the order specified in the datalayer `fields` array. Data sources are only chained within a\n *   data layer, and only if that layer requests more than one kind of data source.\n * @param {LocusZoom.DataSources} sources An object of {ns: LocusZoom.Data.Source} instances\n * @class\n */\n                LocusZoom.Data.Requester = function (sources) {\n                    function split_requests(fields) {\n                        // Given a fields array, return an object specifying what datasource names the data layer should make requests\n                        //  to, and how to handle the returned data\n                        var requests = {};\n                        // Regular expression finds namespace:field|trans\n                        var re = /^(?:([^:]+):)?([^:|]*)(\\|.+)*$/;\n                        fields.forEach(function (raw) {\n                            var parts = re.exec(raw);\n                            var ns = parts[1] || 'base';\n                            var field = parts[2];\n                            var trans = LocusZoom.TransformationFunctions.get(parts[3]);\n                            if (typeof requests[ns] == 'undefined') {\n                                requests[ns] = {\n                                    outnames: [],\n                                    fields: [],\n                                    trans: []\n                                };\n                            }\n                            requests[ns].outnames.push(raw);\n                            requests[ns].fields.push(field);\n                            requests[ns].trans.push(trans);\n                        });\n                        return requests;\n                    }\n                    /**\n     * Fetch data, and create a chain that only connects two data sources if they depend on each other\n     * @param {Object} state The current \"state\" of the plot, such as chromosome and start/end positions\n     * @param {String[]} fields The list of data fields specified in the `layout` for a specific data layer\n     * @returns {Promise}\n     */\n                    this.getData = function (state, fields) {\n                        var requests = split_requests(fields);\n                        // Create an array of functions that, when called, will trigger the request to the specified datasource\n                        var request_handles = Object.keys(requests).map(function (key) {\n                            if (!sources.get(key)) {\n                                throw new Error('Datasource for namespace ' + key + ' not found');\n                            }\n                            return sources.get(key).getData(state, requests[key].fields, requests[key].outnames, requests[key].trans);\n                        });\n                        //assume the fields are requested in dependent order\n                        //TODO: better manage dependencies\n                        var ret = Promise.resolve({\n                            header: {},\n                            body: [],\n                            discrete: {}\n                        });\n                        for (var i = 0; i < request_handles.length; i++) {\n                            // If a single datalayer uses multiple sources, perform the next request when the previous one completes\n                            ret = ret.then(request_handles[i]);\n                        }\n                        return ret;\n                    };\n                };\n                /**\n * Base class for LocusZoom data sources\n * This can be extended with .extend() to create custom data sources\n * @class\n * @public\n */\n                LocusZoom.Data.Source = function () {\n                    /**\n     * Whether this source should enable caching\n     * @member {Boolean}\n     */\n                    this.enableCache = true;\n                    /**\n     * Whether this data source type is dependent on previous requests- for example, the LD source cannot annotate\n     *  association data if no data was found for that region.\n     * @member {boolean}\n     */\n                    this.dependentSource = false;\n                };\n                /**\n * A default constructor that can be used when creating new data sources\n * @param {String|Object} init Basic configuration- either a url, or a config object\n * @param {String} [init.url] The datasource URL\n * @param {String} [init.params] Initial config params for the datasource\n */\n                LocusZoom.Data.Source.prototype.parseInit = function (init) {\n                    if (typeof init === 'string') {\n                        /** @member {String} */\n                        this.url = init;\n                        /** @member {String} */\n                        this.params = {};\n                    } else {\n                        this.url = init.url;\n                        this.params = init.params || {};\n                    }\n                    if (!this.url) {\n                        throw new Error('Source not initialized with required URL');\n                    }\n                };\n                /**\n * A unique identifier that indicates whether cached data is valid for this request\n * @protected\n * @param state\n * @param chain\n * @param fields\n * @returns {String|undefined}\n */\n                LocusZoom.Data.Source.prototype.getCacheKey = function (state, chain, fields) {\n                    return this.getURL && this.getURL(state, chain, fields);\n                };\n                /**\n * Stub: build the URL for any requests made by this source.\n */\n                LocusZoom.Data.Source.prototype.getURL = function (state, chain, fields) {\n                    return this.url;\n                };\n                /**\n * Perform a network request to fetch data for this source\n * @protected\n * @param {Object} state The state of the parent plot\n * @param chain\n * @param fields\n * @returns {Promise}\n */\n                LocusZoom.Data.Source.prototype.fetchRequest = function (state, chain, fields) {\n                    var url = this.getURL(state, chain, fields);\n                    return LocusZoom.createCORSPromise('GET', url);\n                };\n                /**\n * Gets the data for just this source, typically via a network request (caching where possible)\n * @protected\n */\n                LocusZoom.Data.Source.prototype.getRequest = function (state, chain, fields) {\n                    var req;\n                    var cacheKey = this.getCacheKey(state, chain, fields);\n                    if (this.enableCache && typeof cacheKey !== 'undefined' && cacheKey === this._cachedKey) {\n                        req = Promise.resolve(this._cachedResponse);    // Resolve to the value of the current promise\n                    } else {\n                        req = this.fetchRequest(state, chain, fields);\n                        if (this.enableCache) {\n                            this._cachedKey = cacheKey;\n                            this._cachedResponse = req;\n                        }\n                    }\n                    return req;\n                };\n                /**\n * Fetch the data from the specified data source, and apply transformations requested by an external consumer.\n * This is the public-facing datasource method that will most commonly be called by external code.\n *\n * @public\n * @param {Object} state The current \"state\" of the plot, such as chromosome and start/end positions\n * @param {String[]} fields Array of field names that the plot has requested from this data source. (without the \"namespace\" prefix)\n * @param {String[]} outnames  Array describing how the output data should refer to this field. This represents the\n *     originally requested field name, including the namespace. This must be an array with the same length as `fields`\n * @param {Function[]} trans The collection of transformation functions to be run on selected fields.\n *     This must be an array with the same length as `fields`\n * @returns {function} A callable operation that can be used as part of the data chain\n */\n                LocusZoom.Data.Source.prototype.getData = function (state, fields, outnames, trans) {\n                    if (this.preGetData) {\n                        var pre = this.preGetData(state, fields, outnames, trans);\n                        if (this.pre) {\n                            state = pre.state || state;\n                            fields = pre.fields || fields;\n                            outnames = pre.outnames || outnames;\n                            trans = pre.trans || trans;\n                        }\n                    }\n                    var self = this;\n                    return function (chain) {\n                        if (self.dependentSource && chain && chain.body && !chain.body.length) {\n                            // A \"dependent\" source should not attempt to fire a request if there is no data for it to act on.\n                            // Therefore, it should simply return the previous data chain.\n                            return Promise.resolve(chain);\n                        }\n                        return self.getRequest(state, chain, fields).then(function (resp) {\n                            return self.parseResponse(resp, chain, fields, outnames, trans);\n                        });\n                    };\n                };\n                /**\n * Ensure the server response is in a canonical form, an array of one object per record. [ {field: oneval} ].\n * If the server response contains columns, reformats the response from {column1: [], column2: []} to the above.\n *\n * Does not apply namespacing, transformations, or field extraction.\n *\n * May be overridden by data sources that inherently return more complex payloads, or that exist to annotate other\n *  sources (eg, if the payload provides extra data rather than a series of records).\n *\n * @param {Object[]|Object} data The original parsed server response\n * @protected\n */\n                LocusZoom.Data.Source.prototype.normalizeResponse = function (data) {\n                    if (Array.isArray(data)) {\n                        // Already in the desired form\n                        return data;\n                    }\n                    // Otherwise, assume the server response is an object representing columns of data.\n                    // Each array should have the same length (verify), and a given array index corresponds to a single row.\n                    var keys = Object.keys(data);\n                    var N = data[keys[0]].length;\n                    var sameLength = keys.every(function (key) {\n                        var item = data[key];\n                        return item.length === N;\n                    });\n                    if (!sameLength) {\n                        throw new Error(this.constructor.SOURCE_NAME + ' expects a response in which all arrays of data are the same length');\n                    }\n                    // Go down the rows, and create an object for each record\n                    var records = [];\n                    var fields = Object.keys(data);\n                    for (var i = 0; i < N; i++) {\n                        var record = {};\n                        for (var j = 0; j < fields.length; j++) {\n                            record[fields[j]] = data[fields[j]][i];\n                        }\n                        records.push(record);\n                    }\n                    return records;\n                };\n                /** @deprecated */\n                LocusZoom.Data.Source.prototype.prepareData = function (records) {\n                    console.warn('Warning: .prepareData() is deprecated. Use .annotateData() instead');\n                    return this.annotateData(records);\n                };\n                /**\n * Hook to post-process the data returned by this source with new, additional behavior.\n *   (eg cleaning up API values or performing complex calculations on the returned data)\n *\n * @param {Object[]} records The parsed data from the source (eg standardized api response)\n * @param {Object} chain The data chain object. For example, chain.headers may provide useful annotation metadata\n * @returns {Object[]|Promise} The modified set of records\n */\n                LocusZoom.Data.Source.prototype.annotateData = function (records, chain) {\n                    // Default behavior: no transformations\n                    return records;\n                };\n                /**\n * Clean up the server records for use by datalayers: extract only certain fields, with the specified names.\n *   Apply per-field transformations as appropriate.\n *\n * This hook can be overridden, eg to create a source that always returns all records and ignores the \"fields\" array.\n *  This is particularly common for sources at the end of a chain- many \"dependent\" sources do not allow\n *  cherry-picking individual fields, in which case by **convention** the fields array specifies \"last_source_name:all\"\n *\n * @param {Object[]} data One record object per element\n * @param {String[]} fields The names of fields to extract (as named in the source data). Eg \"afield\"\n * @param {String[]} outnames How to represent the source fields in the output. Eg \"namespace:afield|atransform\"\n * @param {function[]} trans An array of transformation functions (if any). One function per data element, or null.\n * @protected\n */\n                LocusZoom.Data.Source.prototype.extractFields = function (data, fields, outnames, trans) {\n                    //intended for an array of objects\n                    //  [ {\"id\":1, \"val\":5}, {\"id\":2, \"val\":10}]\n                    // Since a number of sources exist that do not obey this format, we will provide a convenient pass-through\n                    if (!Array.isArray(data)) {\n                        return data;\n                    }\n                    if (!data.length) {\n                        // Sometimes there are regions that just don't have data- this should not trigger a missing field error message!\n                        return data;\n                    }\n                    var fieldFound = [];\n                    for (var k = 0; k < fields.length; k++) {\n                        fieldFound[k] = 0;\n                    }\n                    var records = data.map(function (item) {\n                        var output_record = {};\n                        for (var j = 0; j < fields.length; j++) {\n                            var val = item[fields[j]];\n                            if (typeof val != 'undefined') {\n                                fieldFound[j] = 1;\n                            }\n                            if (trans && trans[j]) {\n                                val = trans[j](val);\n                            }\n                            output_record[outnames[j]] = val;\n                        }\n                        return output_record;\n                    });\n                    fieldFound.forEach(function (v, i) {\n                        if (!v) {\n                            throw new Error('field ' + fields[i] + ' not found in response for ' + outnames[i]);\n                        }\n                    });\n                    return records;\n                };\n                /**\n * Combine records from this source with others in the chain to yield final chain body.\n *   Handles merging this data with other sources (if applicable).\n *\n * @param {Object[]} data The data That would be returned from this source alone\n * @param {Object} chain The data chain built up during previous requests\n * @param {String[]} fields\n * @param {String[]} outnames\n * @return {Promise|Object[]} The new chain body\n * @protected\n */\n                LocusZoom.Data.Source.prototype.combineChainBody = function (data, chain, fields, outnames, trans) {\n                    return data;\n                };\n                /**\n * Coordinates the work of parsing a response and returning records. This is broken into 4 steps, which may be\n *  overridden separately for fine-grained control. Each step can return either raw data or a promise.\n *\n * @public\n * @param {String|Object} resp The raw data associated with the response\n * @param {Object} chain The combined parsed response data from this and all other requests made in the chain\n * @param {String[]} fields Array of requested field names (as they would appear in the response payload)\n * @param {String[]} outnames  Array of field names as they will be represented in the data returned by this source,\n *  including the namespace. This must be an array with the same length as `fields`\n * @param {Function[]} trans The collection of transformation functions to be run on selected fields.\n *     This must be an array with the same length as `fields`\n * @returns {Promise|{header: ({}|*), discrete: {}, body: []}} A promise that resolves to an object containing\n *   request metadata (headers), the consolidated data for plotting (body), and the individual responses that would be\n *   returned by each source in the chain in isolation (discrete)\n */\n                LocusZoom.Data.Source.prototype.parseResponse = function (resp, chain, fields, outnames, trans) {\n                    var source_id = this.source_id || this.constructor.SOURCE_NAME;\n                    if (!chain.discrete) {\n                        chain.discrete = {};\n                    }\n                    if (!resp) {\n                        // FIXME: Hack. Certain browser issues (such as mixed content warnings) are reported as a successful promise\n                        //  resolution, even though the request was aborted. This is difficult to reliably detect, and is most likely\n                        // to occur for annotation sources (such as from ExAC). If empty response is received, skip parsing and log.\n                        // FIXME: Throw an error after pending, eg https://github.com/konradjk/exac_browser/issues/345\n                        console.error('No usable response was returned for source: \\'' + source_id + '\\'. Parsing will be skipped.');\n                        return Promise.resolve(chain);\n                    }\n                    var json = typeof resp == 'string' ? JSON.parse(resp) : resp;\n                    var self = this;\n                    // Perform the 4 steps of parsing the payload and return a combined chain object\n                    return Promise.resolve(self.normalizeResponse(json.data || json)).then(function (standardized) {\n                        // Perform calculations on the data from just this source\n                        return Promise.resolve(self.annotateData(standardized, chain));\n                    }).then(function (data) {\n                        return Promise.resolve(self.extractFields(data, fields, outnames, trans));\n                    }).then(function (one_source_body) {\n                        // Store a copy of the data that would be returned by parsing this source in isolation (and taking the\n                        //   fields array into account). This is useful when we want to re-use the source output in many ways.\n                        chain.discrete[source_id] = one_source_body;\n                        return Promise.resolve(self.combineChainBody(one_source_body, chain, fields, outnames, trans));\n                    }).then(function (new_body) {\n                        return {\n                            header: chain.header || {},\n                            discrete: chain.discrete,\n                            body: new_body\n                        };\n                    });\n                };\n                /** @deprecated */\n                LocusZoom.Data.Source.prototype.parseArraysToObjects = function (data, fields, outnames, trans) {\n                    console.warn('Warning: .parseArraysToObjects() is no longer used. A stub is provided for legacy use');\n                    var standard = this.normalizeResponse(data);\n                    return this.extractFields(standard, fields, outnames, trans);\n                };\n                /** @deprecated */\n                LocusZoom.Data.Source.prototype.parseObjectsToObjects = function (data, fields, outnames, trans) {\n                    console.warn('Warning: .parseObjectsToObjects() is deprecated. Use .extractFields() instead');\n                    return this.extractFields(data, fields, outnames, trans);\n                };\n                /** @deprecated */\n                LocusZoom.Data.Source.prototype.parseData = function (data, fields, outnames, trans) {\n                    console.warn('Warning: .parseData() is no longer used. A stub is provided for legacy use');\n                    var standard = this.normalizeResponse(data);\n                    return this.extractFields(standard, fields, outnames, trans);\n                };\n                /**\n * Method to define new custom datasources based on a provided constructor. (does not allow registering any additional methods)\n * @public\n * @param {Function} constructorFun Constructor function that is used to create the specified class\n * @param {String} [uniqueName] The name by which the class should be listed in `KnownDataSources`\n * @param {String|Function} [base=LocusZoomData.Source] The name or constructor of a base class to use\n * @returns {*|Function}\n */\n                LocusZoom.Data.Source.extend = function (constructorFun, uniqueName, base) {\n                    if (base) {\n                        if (Array.isArray(base)) {\n                            base = LocusZoom.KnownDataSources.create.apply(null, base);\n                        } else if (typeof base === 'string') {\n                            base = LocusZoom.KnownDataSources.get(base).prototype;\n                        } else if (typeof base === 'function') {\n                            base = base.prototype;\n                        }\n                    } else {\n                        base = new LocusZoom.Data.Source();\n                    }\n                    constructorFun = constructorFun || function () {\n                    };\n                    constructorFun.prototype = base;\n                    constructorFun.prototype.constructor = constructorFun;\n                    if (uniqueName) {\n                        /** @member {String} LocusZoom.Data.Source.SOURCENAME */\n                        constructorFun.SOURCE_NAME = uniqueName;\n                        LocusZoom.KnownDataSources.add(constructorFun);\n                    }\n                    return constructorFun;\n                };\n                /**\n * Datasources can be instantiated from a JSON object instead of code. This represents an existing source in that data format.\n *   For example, this can be helpful when sharing plots, or to share settings with others when debugging\n *\n * Custom sources with their own parameters may need to re-implement this method\n *\n * @public\n * @returns {Object}\n */\n                LocusZoom.Data.Source.prototype.toJSON = function () {\n                    return [\n                        Object.getPrototypeOf(this).constructor.SOURCE_NAME,\n                        {\n                            url: this.url,\n                            params: this.params\n                        }\n                    ];\n                };\n                /**\n * Data Source for Association Data, as fetched from the LocusZoom API server (or compatible)\n * @class\n * @public\n * @augments LocusZoom.Data.Source\n */\n                LocusZoom.Data.AssociationSource = LocusZoom.Data.Source.extend(function (init) {\n                    this.parseInit(init);\n                }, 'AssociationLZ');\n                LocusZoom.Data.AssociationSource.prototype.preGetData = function (state, fields, outnames, trans) {\n                    var id_field = this.params.id_field || 'id';\n                    [\n                        id_field,\n                        'position'\n                    ].forEach(function (x) {\n                        if (fields.indexOf(x) === -1) {\n                            fields.unshift(x);\n                            outnames.unshift(x);\n                            trans.unshift(null);\n                        }\n                    });\n                    return {\n                        fields: fields,\n                        outnames: outnames,\n                        trans: trans\n                    };\n                };\n                LocusZoom.Data.AssociationSource.prototype.getURL = function (state, chain, fields) {\n                    var analysis = chain.header.analysis || this.params.source || this.params.analysis;\n                    // Old usages called this param \"analysis\"\n                    if (typeof analysis == 'undefined') {\n                        throw new Error('Association source must specify an analysis ID to plot');\n                    }\n                    return this.url + 'results/?filter=analysis in ' + analysis + ' and chromosome in  \\'' + state.chr + '\\'' + ' and position ge ' + state.start + ' and position le ' + state.end;\n                };\n                LocusZoom.Data.AssociationSource.prototype.normalizeResponse = function (data) {\n                    // Some association sources do not sort their data in a predictable order, which makes it hard to reliably\n                    //  align with other sources (such as LD). For performance reasons, sorting is an opt-in argument.\n                    // TODO: Consider more fine grained sorting control in the future\n                    data = LocusZoom.Data.Source.prototype.normalizeResponse.call(this, data);\n                    if (this.params && this.params.sort && data.length && data[0]['position']) {\n                        data.sort(function (a, b) {\n                            return a['position'] - b['position'];\n                        });\n                    }\n                    return data;\n                };\n                /**\n * Data Source for LD Data, as fetched from the LocusZoom API server (or compatible)\n * This source is designed to connect its results to association data, and therefore depends on association data having\n *  been loaded by a previous request in the data chain.\n *\n *  This source is deprecated in favor of a new, standalone LD server. For new usages, see LDLZ2.\n *\n * @class\n * @deprecated\n * @public\n * @augments LocusZoom.Data.Source\n */\n                LocusZoom.Data.LDSource = LocusZoom.Data.Source.extend(function (init) {\n                    this.parseInit(init);\n                    this.dependentSource = true;\n                }, 'LDLZ');\n                LocusZoom.Data.LDSource.prototype.preGetData = function (state, fields) {\n                    if (fields.length > 1) {\n                        if (fields.length !== 2 || fields.indexOf('isrefvar') === -1) {\n                            throw new Error('LD does not know how to get all fields: ' + fields.join(', '));\n                        }\n                    }\n                };\n                LocusZoom.Data.LDSource.prototype.findMergeFields = function (chain) {\n                    // Find the fields (as provided by a previous step in the chain) that are needed to combine with LD data\n                    // Since LD information may be shared across multiple assoc sources with different namespaces,\n                    //   we use regex to find columns to join on, rather than requiring exact matches\n                    var exactMatch = function (arr) {\n                        return function () {\n                            var regexes = arguments;\n                            for (var i = 0; i < regexes.length; i++) {\n                                var regex = regexes[i];\n                                var m = arr.filter(function (x) {\n                                    return x.match(regex);\n                                });\n                                if (m.length) {\n                                    return m[0];\n                                }\n                            }\n                            return null;\n                        };\n                    };\n                    var dataFields = {\n                        id: this.params.id_field,\n                        position: this.params.position_field,\n                        pvalue: this.params.pvalue_field,\n                        _names_: null\n                    };\n                    if (chain && chain.body && chain.body.length > 0) {\n                        var names = Object.keys(chain.body[0]);\n                        var nameMatch = exactMatch(names);\n                        dataFields.id = dataFields.id || nameMatch(/\\bvariant\\b/) || nameMatch(/\\bid\\b/);\n                        dataFields.position = dataFields.position || nameMatch(/\\bposition\\b/i, /\\bpos\\b/i);\n                        dataFields.pvalue = dataFields.pvalue || nameMatch(/\\bpvalue\\b/i, /\\blog_pvalue\\b/i);\n                        dataFields._names_ = names;\n                    }\n                    return dataFields;\n                };\n                LocusZoom.Data.LDSource.prototype.findRequestedFields = function (fields, outnames) {\n                    // Assumption: all usages of this source will only ever ask for \"isrefvar\" or \"state\". This maps to output names.\n                    var obj = {};\n                    for (var i = 0; i < fields.length; i++) {\n                        if (fields[i] === 'isrefvar') {\n                            obj.isrefvarin = fields[i];\n                            obj.isrefvarout = outnames && outnames[i];\n                        } else {\n                            obj.ldin = fields[i];\n                            obj.ldout = outnames && outnames[i];\n                        }\n                    }\n                    return obj;\n                };\n                LocusZoom.Data.LDSource.prototype.normalizeResponse = function (data) {\n                    return data;\n                };\n                LocusZoom.Data.LDSource.prototype.getRefvar = function (state, chain, fields) {\n                    var findExtremeValue = function (records, pval_field) {\n                        // Finds the most significant hit (smallest pvalue, or largest -log10p). Will try to auto-detect the appropriate comparison.\n                        pval_field = pval_field || 'log_pvalue';\n                        // The official LZ API returns log_pvalue\n                        var is_log = /log/.test(pval_field);\n                        var cmp;\n                        if (is_log) {\n                            cmp = function (a, b) {\n                                return a > b;\n                            };\n                        } else {\n                            cmp = function (a, b) {\n                                return a < b;\n                            };\n                        }\n                        var extremeVal = records[0][pval_field], extremeIdx = 0;\n                        for (var i = 1; i < records.length; i++) {\n                            if (cmp(records[i][pval_field], extremeVal)) {\n                                extremeVal = records[i][pval_field];\n                                extremeIdx = i;\n                            }\n                        }\n                        return extremeIdx;\n                    };\n                    var reqFields = this.findRequestedFields(fields);\n                    var refVar = reqFields.ldin;\n                    if (refVar === 'state') {\n                        refVar = state.ldrefvar || chain.header.ldrefvar || 'best';\n                    }\n                    if (refVar === 'best') {\n                        if (!chain.body) {\n                            throw new Error('No association data found to find best pvalue');\n                        }\n                        var keys = this.findMergeFields(chain);\n                        if (!keys.pvalue || !keys.id) {\n                            var columns = '';\n                            if (!keys.id) {\n                                columns += (columns.length ? ', ' : '') + 'id';\n                            }\n                            if (!keys.pvalue) {\n                                columns += (columns.length ? ', ' : '') + 'pvalue';\n                            }\n                            throw new Error('Unable to find necessary column(s) for merge: ' + columns + ' (available: ' + keys._names_ + ')');\n                        }\n                        refVar = chain.body[findExtremeValue(chain.body, keys.pvalue)][keys.id];\n                    }\n                    return refVar;\n                };\n                LocusZoom.Data.LDSource.prototype.getURL = function (state, chain, fields) {\n                    var refSource = state.ldrefsource || chain.header.ldrefsource || 1;\n                    var refVar = this.getRefvar(state, chain, fields);\n                    chain.header.ldrefvar = refVar;\n                    return this.url + 'results/?filter=reference eq ' + refSource + ' and chromosome2 eq \\'' + state.chr + '\\'' + ' and position2 ge ' + state.start + ' and position2 le ' + state.end + ' and variant1 eq \\'' + refVar + '\\'' + '&fields=chr,pos,rsquare';\n                };\n                LocusZoom.Data.LDSource.prototype.combineChainBody = function (data, chain, fields, outnames, trans) {\n                    var keys = this.findMergeFields(chain);\n                    var reqFields = this.findRequestedFields(fields, outnames);\n                    if (!keys.position) {\n                        throw new Error('Unable to find position field for merge: ' + keys._names_);\n                    }\n                    var leftJoin = function (left, right, lfield, rfield) {\n                        var i = 0, j = 0;\n                        while (i < left.length && j < right.position2.length) {\n                            if (left[i][keys.position] === right.position2[j]) {\n                                left[i][lfield] = right[rfield][j];\n                                i++;\n                                j++;\n                            } else if (left[i][keys.position] < right.position2[j]) {\n                                i++;\n                            } else {\n                                j++;\n                            }\n                        }\n                    };\n                    var tagRefVariant = function (data, refvar, idfield, outrefname, outldname) {\n                        for (var i = 0; i < data.length; i++) {\n                            if (data[i][idfield] && data[i][idfield] === refvar) {\n                                data[i][outrefname] = 1;\n                                data[i][outldname] = 1;    // For label/filter purposes, implicitly mark the ref var as LD=1 to itself\n                            } else {\n                                data[i][outrefname] = 0;\n                            }\n                        }\n                    };\n                    // LD servers vary slightly. Some report corr as \"rsquare\", others as \"correlation\"\n                    var corrField = data.rsquare ? 'rsquare' : 'correlation';\n                    leftJoin(chain.body, data, reqFields.ldout, corrField);\n                    if (reqFields.isrefvarin && chain.header.ldrefvar) {\n                        tagRefVariant(chain.body, chain.header.ldrefvar, keys.id, reqFields.isrefvarout, reqFields.ldout);\n                    }\n                    return chain.body;\n                };\n                /**\n * Fetch LD directly from the standalone Portal LD server\n *\n * @class\n * @public\n * @augments LocusZoom.Data.LDSource\n */\n                LocusZoom.Data.LDSource2 = LocusZoom.KnownDataSources.extend('LDLZ', 'LDLZ2', {\n                    getURL: function (state, chain, fields) {\n                        // Accept the following params in this.params:\n                        // - method (r, rsquare, cov)\n                        // - source (aka panel)\n                        // - population (ALL, AFR, EUR, etc)\n                        // - build\n                        // The LD source/pop can be overridden from plot.state for dynamic layouts\n                        var build = state.genome_build || this.params.build || 'GRCh37';\n                        var source = state.ld_source || this.params.source || '1000G';\n                        var population = state.ld_pop || this.params.population || 'ALL';\n                        // LDServer panels will always have an ALL\n                        var method = this.params.method || 'rsquare';\n                        validateBuildSource(this.constructor.SOURCE_NAME, build, null);\n                        // LD doesn't need to validate `source` option\n                        var refVar = this.getRefvar(state, chain, fields);\n                        chain.header.ldrefvar = refVar;\n                        return [\n                            this.url,\n                            'genome_builds/',\n                            build,\n                            '/references/',\n                            source,\n                            '/populations/',\n                            population,\n                            '/variants',\n                            '?correlation=',\n                            method,\n                            '&variant=',\n                            encodeURIComponent(refVar),\n                            '&chrom=',\n                            encodeURIComponent(state.chr),\n                            '&start=',\n                            encodeURIComponent(state.start),\n                            '&stop=',\n                            encodeURIComponent(state.end)\n                        ].join('');\n                    },\n                    fetchRequest: function (state, chain, fields) {\n                        // The API is paginated, but we need all of the data to render a plot. Depaginate and combine where appropriate.\n                        var url = this.getURL(state, chain, fields);\n                        var combined = { data: {} };\n                        var chainRequests = function (url) {\n                            return LocusZoom.createCORSPromise('GET', url).then(function (payload) {\n                                payload = JSON.parse(payload);\n                                Object.keys(payload.data).forEach(function (key) {\n                                    combined.data[key] = (combined.data[key] || []).concat(payload.data[key]);\n                                });\n                                if (payload.next) {\n                                    return chainRequests(payload.next);\n                                }\n                                return combined;\n                            });\n                        };\n                        return chainRequests(url);\n                    }\n                });\n                /**\n * Data source for GWAS catalogs of known variants\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n * @param {Object|String} init Configuration (URL or object)\n * @param {Object} [init.params] Optional configuration parameters\n * @param {Number} [init.params.source=2] The ID of the chosen catalog. Defaults to EBI GWAS catalog, GRCh37\n * @param {('strict'|'loose')} [init.params.match_type='strict'] Whether to match on exact variant, or just position.\n */\n                LocusZoom.Data.GwasCatalog = LocusZoom.Data.Source.extend(function (init) {\n                    this.parseInit(init);\n                    this.dependentSource = true;\n                }, 'GwasCatalogLZ');\n                LocusZoom.Data.GwasCatalog.prototype.getURL = function (state, chain, fields) {\n                    // This is intended to be aligned with another source- we will assume they are always ordered by position, asc\n                    //  (regardless of the actual match field)\n                    var build_option = state.genome_build || this.params.build;\n                    validateBuildSource(this.constructor.SOURCE_NAME, build_option, null);\n                    // Source can override build- not mutually exclusive\n                    // Most of our annotations will respect genome build before any other option.\n                    //   But there can be more than one GWAS catalog for the same build, so an explicit config option will always take\n                    //   precedence.\n                    var default_source = build_option === 'GRCh38' ? 1 : 2;\n                    // EBI GWAS catalog\n                    var source = this.params.source || default_source;\n                    return this.url + '?format=objects&sort=pos&filter=id eq ' + source + ' and chrom eq \\'' + state.chr + '\\'' + ' and pos ge ' + state.start + ' and pos le ' + state.end;\n                };\n                LocusZoom.Data.GwasCatalog.prototype.findMergeFields = function (records) {\n                    // Data from previous sources is already namespaced. Find the alignment field by matching.\n                    var knownFields = Object.keys(records);\n                    // Note: All API endoints involved only give results for 1 chromosome at a time; match is implied\n                    var posMatch = knownFields.find(function (item) {\n                        return item.match(/\\b(position|pos)\\b/i);\n                    });\n                    if (!posMatch) {\n                        throw new Error('Could not find data to align with GWAS catalog results');\n                    }\n                    return { 'pos': posMatch };\n                };\n                // Skip the \"individual field extraction\" step; extraction will be handled when building chain body instead\n                LocusZoom.Data.GwasCatalog.prototype.extractFields = function (data, fields, outnames, trans) {\n                    return data;\n                };\n                LocusZoom.Data.GwasCatalog.prototype.combineChainBody = function (data, chain, fields, outnames, trans) {\n                    if (!data.length) {\n                        return chain.body;\n                    }\n                    var decider = 'log_pvalue';\n                    //  TODO: Better reuse options in the future\n                    var decider_out = outnames[fields.indexOf(decider)];\n                    function leftJoin(left, right, fields, outnames, trans) {\n                        // Add `fields` from `right` to `left`\n                        // Add a synthetic, un-namespaced field to all matching records\n                        var n_matches = left['n_catalog_matches'] || 0;\n                        left['n_catalog_matches'] = n_matches + 1;\n                        if (decider && left[decider_out] && left[decider_out] > right[decider]) {\n                            // There may be more than one GWAS catalog entry for the same SNP. This source is intended for a 1:1\n                            //  annotation scenario, so for now it only joins the catalog entry that has the best -log10 pvalue\n                            return;\n                        }\n                        for (var j = 0; j < fields.length; j++) {\n                            var fn = fields[j];\n                            var outn = outnames[j];\n                            var val = right[fn];\n                            if (trans && trans[j]) {\n                                val = trans[j](val);\n                            }\n                            left[outn] = val;\n                        }\n                    }\n                    var chainNames = this.findMergeFields(chain.body[0]);\n                    var catNames = this.findMergeFields(data[0]);\n                    var i = 0, j = 0;\n                    while (i < chain.body.length && j < data.length) {\n                        var left = chain.body[i];\n                        var right = data[j];\n                        if (left[chainNames.pos] === right[catNames.pos]) {\n                            // There may be multiple catalog entries for each matching SNP; evaluate match one at a time\n                            leftJoin(left, right, fields, outnames, trans);\n                            j += 1;\n                        } else if (left[chainNames.pos] < right[catNames.pos]) {\n                            i += 1;\n                        } else {\n                            j += 1;\n                        }\n                    }\n                    return chain.body;\n                };\n                /**\n * Data Source for Gene Data, as fetched from the LocusZoom API server (or compatible)\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n */\n                LocusZoom.Data.GeneSource = LocusZoom.Data.Source.extend(function (init) {\n                    this.parseInit(init);\n                }, 'GeneLZ');\n                LocusZoom.Data.GeneSource.prototype.getURL = function (state, chain, fields) {\n                    var build = state.genome_build || this.params.build;\n                    var source = this.params.source;\n                    validateBuildSource(this.constructor.SOURCE_NAME, build, source);\n                    if (build) {\n                        // If build specified, choose a known Portal API dataset IDs (build 37/38)\n                        source = build === 'GRCh38' ? 1 : 3;\n                    }\n                    return this.url + '?filter=source in ' + source + ' and chrom eq \\'' + state.chr + '\\'' + ' and start le ' + state.end + ' and end ge ' + state.start;\n                };\n                // Genes have a very complex internal data format. Bypass any record parsing, and provide the data layer with the\n                // exact information returned by the API. (ignoring the fields array in the layout)\n                LocusZoom.Data.GeneSource.prototype.normalizeResponse = function (data) {\n                    return data;\n                };\n                LocusZoom.Data.GeneSource.prototype.extractFields = function (data, fields, outnames, trans) {\n                    return data;\n                };\n                /**\n * Data Source for Gene Constraint Data, as fetched from the LocusZoom API server (or compatible)\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n*/\n                LocusZoom.Data.GeneConstraintSource = LocusZoom.Data.Source.extend(function (init) {\n                    this.parseInit(init);\n                }, 'GeneConstraintLZ');\n                LocusZoom.Data.GeneConstraintSource.prototype.getURL = function () {\n                    return this.url;\n                };\n                LocusZoom.Data.GeneConstraintSource.prototype.normalizeResponse = function (data) {\n                    return data;\n                };\n                LocusZoom.Data.GeneConstraintSource.prototype.getCacheKey = function (state, chain, fields) {\n                    return this.url + JSON.stringify(state);\n                };\n                LocusZoom.Data.GeneConstraintSource.prototype.fetchRequest = function (state, chain, fields) {\n                    var geneids = [];\n                    chain.body.forEach(function (gene) {\n                        var gene_id = gene.gene_id;\n                        if (gene_id.indexOf('.')) {\n                            gene_id = gene_id.substr(0, gene_id.indexOf('.'));\n                        }\n                        geneids.push(gene_id);\n                    });\n                    var url = this.getURL(state, chain, fields);\n                    var body = 'geneids=' + encodeURIComponent(JSON.stringify(geneids));\n                    var headers = { 'Content-Type': 'application/x-www-form-urlencoded' };\n                    return LocusZoom.createCORSPromise('POST', url, body, headers);\n                };\n                LocusZoom.Data.GeneConstraintSource.prototype.combineChainBody = function (data, chain, fields, outnames, trans) {\n                    if (!data) {\n                        return chain;\n                    }\n                    var constraint_fields = [\n                        'bp',\n                        'exp_lof',\n                        'exp_mis',\n                        'exp_syn',\n                        'lof_z',\n                        'mis_z',\n                        'mu_lof',\n                        'mu_mis',\n                        'mu_syn',\n                        'n_exons',\n                        'n_lof',\n                        'n_mis',\n                        'n_syn',\n                        'pLI',\n                        'syn_z'\n                    ];\n                    chain.body.forEach(function (gene, i) {\n                        var gene_id = gene.gene_id;\n                        if (gene_id.indexOf('.')) {\n                            gene_id = gene_id.substr(0, gene_id.indexOf('.'));\n                        }\n                        constraint_fields.forEach(function (field) {\n                            // Do not overwrite any fields defined in the original gene source\n                            if (typeof chain.body[i][field] != 'undefined') {\n                                return;\n                            }\n                            if (data[gene_id]) {\n                                var val = data[gene_id][field];\n                                if (typeof val == 'number' && val.toString().indexOf('.') !== -1) {\n                                    val = parseFloat(val.toFixed(2));\n                                }\n                                chain.body[i][field] = val;\n                            } else {\n                                // If the gene did not come back in the response then set the same field with a null values\n                                chain.body[i][field] = null;\n                            }\n                        });\n                    });\n                    return chain.body;\n                };\n                /**\n * Data Source for Recombination Rate Data, as fetched from the LocusZoom API server (or compatible)\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n */\n                LocusZoom.Data.RecombinationRateSource = LocusZoom.Data.Source.extend(function (init) {\n                    this.parseInit(init);\n                }, 'RecombLZ');\n                LocusZoom.Data.RecombinationRateSource.prototype.getURL = function (state, chain, fields) {\n                    var build = state.genome_build || this.params.build;\n                    var source = this.params.source;\n                    validateBuildSource(this.constructor.SOURCE_NAME, build, source);\n                    if (build) {\n                        // If build specified, choose a known Portal API dataset IDs (build 37/38)\n                        source = build === 'GRCh38' ? 16 : 15;\n                    }\n                    return this.url + '?filter=id in ' + source + ' and chromosome eq \\'' + state.chr + '\\'' + ' and position le ' + state.end + ' and position ge ' + state.start;\n                };\n                /**\n * Data Source for Interval Annotation Data (e.g. BED Tracks), as fetched from the LocusZoom API server (or compatible)\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n */\n                LocusZoom.Data.IntervalSource = LocusZoom.Data.Source.extend(function (init) {\n                    this.parseInit(init);\n                }, 'IntervalLZ');\n                LocusZoom.Data.IntervalSource.prototype.getURL = function (state, chain, fields) {\n                    var source = chain.header.bedtracksource || this.params.source;\n                    return this.url + '?filter=id in ' + source + ' and chromosome eq \\'' + state.chr + '\\'' + ' and start le ' + state.end + ' and end ge ' + state.start;\n                };\n                /**\n * Data Source for static blobs of JSON Data. This does not perform additional parsing, and therefore it is the\n * responsibility of the user to pass information in a format that can be read and understood by the chosen plot.\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n */\n                LocusZoom.Data.StaticSource = LocusZoom.Data.Source.extend(function (data) {\n                    /** @member {Object} */\n                    this._data = data;\n                }, 'StaticJSON');\n                LocusZoom.Data.StaticSource.prototype.getRequest = function (state, chain, fields) {\n                    return Promise.resolve(this._data);\n                };\n                LocusZoom.Data.StaticSource.prototype.toJSON = function () {\n                    return [\n                        Object.getPrototypeOf(this).constructor.SOURCE_NAME,\n                        this._data\n                    ];\n                };\n                /**\n * Data source for PheWAS data\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n * @param {String[]} init.params.build This datasource expects to be provided the name of the genome build that will\n *   be used to provide pheWAS results for this position. Note positions may not translate between builds.\n */\n                LocusZoom.Data.PheWASSource = LocusZoom.Data.Source.extend(function (init) {\n                    this.parseInit(init);\n                }, 'PheWASLZ');\n                LocusZoom.Data.PheWASSource.prototype.getURL = function (state, chain, fields) {\n                    var build = (state.genome_build ? [state.genome_build] : null) || this.params.build;\n                    if (!build || !Array.isArray(build) || !build.length) {\n                        throw new Error([\n                            'Data source',\n                            this.constructor.SOURCE_NAME,\n                            'requires that you specify array of one or more desired genome build names'\n                        ].join(' '));\n                    }\n                    var url = [\n                        this.url,\n                        '?filter=variant eq \\'',\n                        encodeURIComponent(state.variant),\n                        '\\'&format=objects&',\n                        build.map(function (item) {\n                            return 'build=' + encodeURIComponent(item);\n                        }).join('&')\n                    ];\n                    return url.join('');\n                };\n                /**\n * Base class for \"connectors\"- this is meant to be subclassed, rather than used directly.\n *\n * A connector is a source that makes no server requests and caches no data of its own. Instead, it decides how to\n *  combine data from other sources in the chain. Connectors are useful when we want to request (or calculate) some\n *  useful piece of information once, but apply it to many different kinds of record types.\n *\n * Typically, a subclass will implement the field merging logic in `combineChainBody`.\n *\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n * @param {Object} init Configuration for this source\n * @param {Object} init.sources Specify how the hard-coded logic should find the data it relies on in the chain,\n *  as {internal_name: chain_source_id} pairs. This allows writing a reusable connector that does not need to make\n *  assumptions about what namespaces a source is using.\n * @type {*|Function}\n */\n                LocusZoom.Data.ConnectorSource = LocusZoom.Data.Source.extend(function (init) {\n                    if (!init || !init.sources) {\n                        throw new Error('Connectors must specify the data they require as init.sources = {internal_name: chain_source_id}} pairs');\n                    }\n                    /**\n     * Tells the connector how to find the data it relies on\n     *\n     * For example, a connector that applies burden test information to the genes layer might specify:\n     *  {gene_ns: \"gene\", aggregation_ns: \"aggregation\"}\n     *\n     * @member {Object}\n     */\n                    this._source_name_mapping = init.sources;\n                    // Validate that this source has been told how to find the required information\n                    var specified_ids = Object.keys(init.sources);\n                    var self = this;\n                    this.REQUIRED_SOURCES.forEach(function (k) {\n                        if (specified_ids.indexOf(k) === -1) {\n                            throw new Error('Configuration for ' + self.constructor.SOURCE_NAME + ' must specify a source ID corresponding to ' + k);\n                        }\n                    });\n                    this.parseInit(init);\n                }, 'ConnectorSource');\n                /** @property {String[]} Specifies the sources that must be provided in the original config object */\n                LocusZoom.Data.ConnectorSource.prototype.REQUIRED_SOURCES = [];\n                LocusZoom.Data.ConnectorSource.prototype.parseInit = function (init) {\n                };\n                // Stub\n                LocusZoom.Data.ConnectorSource.prototype.getRequest = function (state, chain, fields) {\n                    // Connectors do not request their own data by definition, but they *do* depend on other sources having been loaded\n                    //  first. This method performs basic validation, and preserves the accumulated body from the chain so far.\n                    var self = this;\n                    Object.keys(this._source_name_mapping).forEach(function (ns) {\n                        var chain_source_id = self._source_name_mapping[ns];\n                        if (chain.discrete && !chain.discrete[chain_source_id]) {\n                            throw new Error(self.constructor.SOURCE_NAME + ' cannot be used before loading required data for: ' + chain_source_id);\n                        }\n                    });\n                    return Promise.resolve(chain.body || []);\n                };\n                LocusZoom.Data.ConnectorSource.prototype.parseResponse = function (data, chain, fields, outnames, trans) {\n                    // A connector source does not update chain.discrete, but it may use it. It bypasses data formatting\n                    //  and field selection (both are assumed to have been done already, by the previous sources this draws from)\n                    // Because of how the chain works, connectors are not very good at applying new transformations or namespacing.\n                    // Typically connectors are called with `connector_name:all` in the fields array.\n                    return Promise.resolve(this.combineChainBody(data, chain, fields, outnames, trans)).then(function (new_body) {\n                        return {\n                            header: chain.header || {},\n                            discrete: chain.discrete || {},\n                            body: new_body\n                        };\n                    });\n                };\n                LocusZoom.Data.ConnectorSource.prototype.combineChainBody = function (records, chain) {\n                    // Stub method: specifies how to combine the data\n                    throw new Error('This method must be implemented in a subclass');\n                };\n                /* global LocusZoom */\n                'use strict';\n                /**\n * An independent LocusZoom object that renders a unique set of data and subpanels.\n * Many such LocusZoom objects can exist simultaneously on a single page, each having its own layout.\n *\n * This creates a new plot instance, but does not immediately render it. For practical use, it may be more convenient\n * to use the `LocusZoom.populate` helper method.\n *\n * @class\n * @param {String} id The ID of the plot. Often corresponds to the ID of the container element on the page\n *   where the plot is rendered..\n * @param {LocusZoom.DataSources} datasource Ensemble of data providers used by the plot\n * @param {Object} layout A JSON-serializable object of layout configuration parameters\n*/\n                LocusZoom.Plot = function (id, datasource, layout) {\n                    /** @member Boolean} */\n                    this.initialized = false;\n                    // TODO: This makes sense for all other locuszoom elements to have; determine whether this is interface boilerplate or something that can be removed\n                    this.parent_plot = this;\n                    /** @member {String} */\n                    this.id = id;\n                    /** @member {Element} */\n                    this.container = null;\n                    /**\n     * Selector for a node that will contain the plot. (set externally by populate methods)\n     * @member {d3.selection}\n     */\n                    this.svg = null;\n                    /** @member {Object.<String, Number>} */\n                    this.panels = {};\n                    /**\n     * TODO: This is currently used by external classes that manipulate the parent and may indicate room for a helper method in the api to coordinate boilerplate\n     * @protected\n     * @member {String[]}\n     */\n                    this.panel_ids_by_y_index = [];\n                    /**\n     * Notify each child panel of the plot of changes in panel ordering/ arrangement\n     */\n                    this.applyPanelYIndexesToPanelLayouts = function () {\n                        this.panel_ids_by_y_index.forEach(function (pid, idx) {\n                            this.panels[pid].layout.y_index = idx;\n                        }.bind(this));\n                    };\n                    /**\n     * Get the qualified ID pathname for the plot\n     * @returns {String}\n     */\n                    this.getBaseId = function () {\n                        return this.id;\n                    };\n                    /**\n     * Track update operations (reMap) performed on all child panels, and notify the parent plot when complete\n     * TODO: Reconsider whether we need to be tracking this as global state outside of context of specific operations\n     * @protected\n     * @member {Promise[]}\n     */\n                    this.remap_promises = [];\n                    if (typeof layout == 'undefined') {\n                        /**\n         * The layout is a serializable object used to describe the composition of the Plot\n         *   If no layout was passed, use the Standard Association Layout\n         *   Otherwise merge whatever was passed with the Default Layout\n         *   TODO: Review description; we *always* merge with default layout?\n         * @member {Object}\n         */\n                        this.layout = LocusZoom.Layouts.merge({}, LocusZoom.Layouts.get('plot', 'standard_association'));\n                    } else {\n                        this.layout = layout;\n                    }\n                    LocusZoom.Layouts.merge(this.layout, LocusZoom.Plot.DefaultLayout);\n                    /**\n     * Values in the layout object may change during rendering etc. Retain a copy of the original plot state\n     * @member {Object}\n     */\n                    this._base_layout = JSON.parse(JSON.stringify(this.layout));\n                    /**\n     * Create a shortcut to the state in the layout on the Plot. Tracking in the layout allows the plot to be created\n     *   with initial state/setup.\n     *\n     * Tracks state of the plot, eg start and end position\n     * @member {Object}\n     */\n                    this.state = this.layout.state;\n                    /** @member {LocusZoom.Data.Requester} */\n                    this.lzd = new LocusZoom.Data.Requester(datasource);\n                    /**\n     * Window.onresize listener (responsive layouts only)\n     * TODO: .on appears to return a selection, not a listener? Check logic here\n     * https://github.com/d3/d3-selection/blob/00b904b9bcec4dfaf154ae0bbc777b1fc1d7bc08/test/selection/on-test.js#L11\n     * @deprecated\n     * @member {d3.selection}\n     */\n                    this.window_onresize = null;\n                    /**\n     * Known event hooks that the panel can respond to\n     * @protected\n     * @member {Object}\n     */\n                    this.event_hooks = {\n                        'layout_changed': [],\n                        'data_requested': [],\n                        'data_rendered': [],\n                        'element_clicked': [],\n                        // Select or unselect\n                        'element_selection': [],\n                        // Element becomes active (only)\n                        'match_requested': [],\n                        // A data layer is attempting to highlight matching points (internal use only)\n                        'panel_removed': [],\n                        'state_changed': []    // Only triggered when a state change causes rerender\n                    };\n                    /**\n     * @callback eventCallback\n     * @param {object} eventData A description of the event\n     * @param {String|null} eventData.sourceID The unique identifier (eg plot or parent name) of the element that\n     *  triggered the event. Will be automatically filled in if not explicitly provided.\n     * @param {Object|null} eventData.context Any additional information to be passed to the callback, eg the data\n     *   associated with a clicked plot element\n     */\n                    /**\n     * There are several events that a LocusZoom plot can \"emit\" when appropriate, and LocusZoom supports registering\n     *   \"hooks\" for these events which are essentially custom functions intended to fire at certain times.\n     *\n     * The following plot-level events are currently supported:\n     *   - `layout_changed` - context: plot - Any aspect of the plot's layout (including dimensions or state) has changed.\n     *   - `data_requested` - context: plot - A request for new data from any data source used in the plot has been made.\n     *   - `data_rendered` - context: plot - Data from a request has been received and rendered in the plot.\n     *   - `element_clicked` - context: plot - A data element in any of the plot's data layers has been clicked.\n     *   - `element_selection` - context: plot - Triggered when an element changes \"selection\" status, and identifies\n     *        whether the element is being selected or deselected.\n     *\n     * To register a hook for any of these events use `plot.on('event_name', function() {})`.\n     *\n     * There can be arbitrarily many functions registered to the same event. They will be executed in the order they\n     *   were registered. The this context bound to each event hook function is dependent on the type of event, as\n     *   denoted above. For example, when data_requested is emitted the context for this in the event hook will be the\n     *   plot itself, but when element_clicked is emitted the context for this in the event hook will be the element\n     *   that was clicked.\n     *\n     * @param {String} event The name of an event (as defined in `event_hooks`)\n     * @param {eventCallback} hook\n     * @returns {function} The registered event listener\n     */\n                    this.on = function (event, hook) {\n                        if (typeof 'event' != 'string' || !Array.isArray(this.event_hooks[event])) {\n                            throw new Error('Unable to register event hook, invalid event: ' + event.toString());\n                        }\n                        if (typeof hook != 'function') {\n                            throw new Error('Unable to register event hook, invalid hook function passed');\n                        }\n                        this.event_hooks[event].push(hook);\n                        return hook;\n                    };\n                    /**\n     * Remove one or more previously defined event listeners\n     * @param {String} event The name of an event (as defined in `event_hooks`)\n     * @param {eventCallback} [hook] The callback to deregister\n     * @returns {LocusZoom.Plot}\n     */\n                    this.off = function (event, hook) {\n                        var theseHooks = this.event_hooks[event];\n                        if (typeof 'event' != 'string' || !Array.isArray(theseHooks)) {\n                            throw new Error('Unable to remove event hook, invalid event: ' + event.toString());\n                        }\n                        if (hook === undefined) {\n                            // Deregistering all hooks for this event may break basic functionality, and should only be used during\n                            //  cleanup operations (eg to prevent memory leaks)\n                            this.event_hooks[event] = [];\n                        } else {\n                            var hookMatch = theseHooks.indexOf(hook);\n                            if (hookMatch !== -1) {\n                                theseHooks.splice(hookMatch, 1);\n                            } else {\n                                throw new Error('The specified event listener is not registered and therefore cannot be removed');\n                            }\n                        }\n                        return this;\n                    };\n                    /**\n     * Handle running of event hooks when an event is emitted\n     * @param {string} event A known event name\n     * @param {*} eventData Data or event description that will be passed to the event listener\n     * @returns {LocusZoom.Plot}\n     */\n                    this.emit = function (event, eventData) {\n                        // TODO: there are small differences between the emit implementation between plots and panels. In the future,\n                        //  DRY this code via mixins, and make sure to keep the interfaces compatible when refactoring.\n                        if (typeof 'event' != 'string' || !Array.isArray(this.event_hooks[event])) {\n                            throw new Error('LocusZoom attempted to throw an invalid event: ' + event.toString());\n                        }\n                        var sourceID = this.getBaseId();\n                        var self = this;\n                        this.event_hooks[event].forEach(function (hookToRun) {\n                            var eventContext;\n                            if (eventData && eventData.sourceID) {\n                                // If we detect that an event originated elsewhere (via bubbling or externally), preserve the context\n                                //  when re-emitting the event to plot-level listeners\n                                eventContext = eventData;\n                            } else {\n                                eventContext = {\n                                    sourceID: sourceID,\n                                    data: eventData || null\n                                };\n                            }\n                            // By default, any handlers fired here (either directly, or bubbled) will see the plot as the\n                            //  value of `this`. If a bound function is registered as a handler, the previously bound `this` will\n                            //  override anything provided to `call` below.\n                            hookToRun.call(self, eventContext);\n                        });\n                        return this;\n                    };\n                    /**\n     * Get an object with the x and y coordinates of the plot's origin in terms of the entire page\n     * Necessary for positioning any HTML elements over the plot\n     * @returns {{x: Number, y: Number, width: Number, height: Number}}\n     */\n                    this.getPageOrigin = function () {\n                        var bounding_client_rect = this.svg.node().getBoundingClientRect();\n                        var x_offset = document.documentElement.scrollLeft || document.body.scrollLeft;\n                        var y_offset = document.documentElement.scrollTop || document.body.scrollTop;\n                        var container = this.svg.node();\n                        while (container.parentNode !== null) {\n                            container = container.parentNode;\n                            if (container !== document && d3.select(container).style('position') !== 'static') {\n                                x_offset = -1 * container.getBoundingClientRect().left;\n                                y_offset = -1 * container.getBoundingClientRect().top;\n                                break;\n                            }\n                        }\n                        return {\n                            x: x_offset + bounding_client_rect.left,\n                            y: y_offset + bounding_client_rect.top,\n                            width: bounding_client_rect.width,\n                            height: bounding_client_rect.height\n                        };\n                    };\n                    /**\n     * Get the top and left offset values for the plot's container element (the div that was populated)\n     * @returns {{top: number, left: number}}\n     */\n                    this.getContainerOffset = function () {\n                        var offset = {\n                            top: 0,\n                            left: 0\n                        };\n                        var container = this.container.offsetParent || null;\n                        while (container !== null) {\n                            offset.top += container.offsetTop;\n                            offset.left += container.offsetLeft;\n                            container = container.offsetParent || null;\n                        }\n                        return offset;\n                    };\n                    //\n                    /**\n     * Event information describing interaction (e.g. panning and zooming) is stored on the plot\n     * TODO: Add/ document details of interaction structure as we expand\n     * @member {{panel_id: String, linked_panel_ids: Array, x_linked: *, dragging: *, zooming: *}}\n     * @returns {LocusZoom.Plot}\n     */\n                    this.interaction = {};\n                    /**\n     * Track whether the target panel can respond to mouse interaction events\n     * @param {String} panel_id\n     * @returns {boolean}\n     */\n                    this.canInteract = function (panel_id) {\n                        panel_id = panel_id || null;\n                        if (panel_id) {\n                            return (typeof this.interaction.panel_id == 'undefined' || this.interaction.panel_id === panel_id) && !this.loading_data;\n                        } else {\n                            return !(this.interaction.dragging || this.interaction.zooming || this.loading_data);\n                        }\n                    };\n                    // Initialize the layout\n                    this.initializeLayout();\n                    return this;\n                };\n                /**\n * Default/ expected configuration parameters for basic plotting; most plots will override\n *\n * @protected\n * @static\n * @type {Object}\n */\n                LocusZoom.Plot.DefaultLayout = {\n                    state: {},\n                    width: 1,\n                    height: 1,\n                    min_width: 1,\n                    min_height: 1,\n                    responsive_resize: false,\n                    // Allowed values: false, \"width_only\", \"both\" (synonym for true)\n                    aspect_ratio: 1,\n                    panels: [],\n                    dashboard: { components: [] },\n                    panel_boundaries: true,\n                    mouse_guide: true\n                };\n                /**\n * Helper method to sum the proportional dimensions of panels, a value that's checked often as panels are added/removed\n * @param {('Height'|'Width')} dimension\n * @returns {number}\n */\n                LocusZoom.Plot.prototype.sumProportional = function (dimension) {\n                    if (dimension !== 'height' && dimension !== 'width') {\n                        throw new Error('Bad dimension value passed to LocusZoom.Plot.prototype.sumProportional');\n                    }\n                    var total = 0;\n                    for (var id in this.panels) {\n                        // Ensure every panel contributing to the sum has a non-zero proportional dimension\n                        if (!this.panels[id].layout['proportional_' + dimension]) {\n                            this.panels[id].layout['proportional_' + dimension] = 1 / Object.keys(this.panels).length;\n                        }\n                        total += this.panels[id].layout['proportional_' + dimension];\n                    }\n                    return total;\n                };\n                /**\n * Resize the plot to fit the bounding container\n * @returns {LocusZoom.Plot}\n */\n                LocusZoom.Plot.prototype.rescaleSVG = function () {\n                    var clientRect = this.svg.node().getBoundingClientRect();\n                    this.setDimensions(clientRect.width, clientRect.height);\n                    return this;\n                };\n                /**\n * Prepare the plot for first use by performing parameter validation, setting up panels, and calculating dimensions\n * @returns {LocusZoom.Plot}\n */\n                LocusZoom.Plot.prototype.initializeLayout = function () {\n                    // Sanity check layout values\n                    if (isNaN(this.layout.width) || this.layout.width <= 0) {\n                        throw new Error('Plot layout parameter `width` must be a positive number');\n                    }\n                    if (isNaN(this.layout.height) || this.layout.height <= 0) {\n                        throw new Error('Plot layout parameter `width` must be a positive number');\n                    }\n                    if (isNaN(this.layout.aspect_ratio) || this.layout.aspect_ratio <= 0) {\n                        throw new Error('Plot layout parameter `aspect_ratio` must be a positive number');\n                    }\n                    if (this.layout.responsive_resize === true) {\n                        // Backwards compatible support\n                        console.warn('LocusZoom \"responsive_resize\" specifies a deprecated value. The new value should be \"both\". Please update your layout.');\n                        this.layout.responsive_resize = 'both';\n                    }\n                    var RESIZE_MODES = [\n                        false,\n                        'both',\n                        'width_only'\n                    ];\n                    if (RESIZE_MODES.indexOf(this.layout.responsive_resize) === -1) {\n                        throw new Error('LocusZoom option \"responsive_resize\" should specify one of the following modes: ' + RESIZE_MODES.join(', '));\n                    }\n                    // If this is a responsive layout then set a namespaced/unique onresize event listener on the window\n                    if (this.layout.responsive_resize) {\n                        this.window_onresize = d3.select(window).on('resize.lz-' + this.id, function () {\n                            this.rescaleSVG();\n                        }.bind(this));\n                        // Forcing one additional setDimensions() call after the page is loaded clears up\n                        // any disagreements between the initial layout and the loaded responsive container's size\n                        d3.select(window).on('load.lz-' + this.id, function () {\n                            this.setDimensions();\n                        }.bind(this));\n                    }\n                    // Add panels\n                    this.layout.panels.forEach(function (panel_layout) {\n                        this.addPanel(panel_layout);\n                    }.bind(this));\n                    return this;\n                };\n                /**\n * Set the dimensions for a plot, and ensure that panels are sized and positioned correctly.\n *\n * If dimensions are provided, resizes each panel proportionally to match the new plot dimensions. Otherwise,\n *   calculates the appropriate plot dimensions based on all panels.\n * @param {Number} [width] If provided and larger than minimum size, set plot to this width\n * @param {Number} [height] If provided and larger than minimum size, set plot to this height\n * @returns {LocusZoom.Plot}\n */\n                LocusZoom.Plot.prototype.setDimensions = function (width, height) {\n                    var id;\n                    // Update minimum allowable width and height by aggregating minimums from panels, then apply minimums to containing element.\n                    var min_width = parseFloat(this.layout.min_width) || 0;\n                    var min_height = parseFloat(this.layout.min_height) || 0;\n                    for (id in this.panels) {\n                        min_width = Math.max(min_width, this.panels[id].layout.min_width);\n                        if (parseFloat(this.panels[id].layout.min_height) > 0 && parseFloat(this.panels[id].layout.proportional_height) > 0) {\n                            min_height = Math.max(min_height, this.panels[id].layout.min_height / this.panels[id].layout.proportional_height);\n                        }\n                    }\n                    this.layout.min_width = Math.max(min_width, 1);\n                    this.layout.min_height = Math.max(min_height, 1);\n                    d3.select(this.svg.node().parentNode).style({\n                        'min-width': this.layout.min_width + 'px',\n                        'min-height': this.layout.min_height + 'px'\n                    });\n                    // If width and height arguments were passed then adjust them against plot minimums if necessary.\n                    // Then resize the plot and proportionally resize panels to fit inside the new plot dimensions.\n                    if (!isNaN(width) && width >= 0 && !isNaN(height) && height >= 0) {\n                        this.layout.width = Math.max(Math.round(+width), this.layout.min_width);\n                        this.layout.height = Math.max(Math.round(+height), this.layout.min_height);\n                        this.layout.aspect_ratio = this.layout.width / this.layout.height;\n                        // Override discrete values if resizing responsively\n                        if (this.layout.responsive_resize) {\n                            // All resize modes will affect width\n                            if (this.svg) {\n                                this.layout.width = Math.max(this.svg.node().parentNode.getBoundingClientRect().width, this.layout.min_width);\n                            }\n                            if (this.layout.responsive_resize === 'both') {\n                                // Then also change the height\n                                this.layout.height = this.layout.width / this.layout.aspect_ratio;\n                                if (this.layout.height < this.layout.min_height) {\n                                    this.layout.height = this.layout.min_height;\n                                    this.layout.width = this.layout.height * this.layout.aspect_ratio;\n                                }\n                            }\n                        }\n                        // Resize/reposition panels to fit, update proportional origins if necessary\n                        var y_offset = 0;\n                        this.panel_ids_by_y_index.forEach(function (panel_id) {\n                            var panel_width = this.layout.width;\n                            var panel_height = this.panels[panel_id].layout.proportional_height * this.layout.height;\n                            this.panels[panel_id].setDimensions(panel_width, panel_height);\n                            this.panels[panel_id].setOrigin(0, y_offset);\n                            this.panels[panel_id].layout.proportional_origin.x = 0;\n                            this.panels[panel_id].layout.proportional_origin.y = y_offset / this.layout.height;\n                            y_offset += panel_height;\n                            this.panels[panel_id].dashboard.update();\n                        }.bind(this));\n                    }    // If width and height arguments were NOT passed (and panels exist) then determine the plot dimensions\n                         // by making it conform to panel dimensions, assuming panels are already positioned correctly.\n                    else if (Object.keys(this.panels).length) {\n                        this.layout.width = 0;\n                        this.layout.height = 0;\n                        for (id in this.panels) {\n                            this.layout.width = Math.max(this.panels[id].layout.width, this.layout.width);\n                            this.layout.height += this.panels[id].layout.height;\n                        }\n                        this.layout.width = Math.max(this.layout.width, this.layout.min_width);\n                        this.layout.height = Math.max(this.layout.height, this.layout.min_height);\n                    }\n                    // Keep aspect ratio in agreement with dimensions\n                    this.layout.aspect_ratio = this.layout.width / this.layout.height;\n                    // Apply layout width and height as discrete values or viewbox values\n                    if (this.svg !== null) {\n                        if (this.layout.responsive_resize === 'both') {\n                            this.svg.attr('viewBox', '0 0 ' + this.layout.width + ' ' + this.layout.height).attr('preserveAspectRatio', 'xMinYMin meet');\n                        } else {\n                            this.svg.attr('width', this.layout.width).attr('height', this.layout.height);\n                        }\n                    }\n                    // If the plot has been initialized then trigger some necessary render functions\n                    if (this.initialized) {\n                        this.panel_boundaries.position();\n                        this.dashboard.update();\n                        this.curtain.update();\n                        this.loader.update();\n                    }\n                    return this.emit('layout_changed');\n                };\n                /**\n * Create a new panel from a layout, and handle the work of initializing and placing the panel on the plot\n * @param {Object} layout\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Plot.prototype.addPanel = function (layout) {\n                    // Sanity checks\n                    if (typeof layout !== 'object') {\n                        throw new Error('Invalid panel layout passed to LocusZoom.Plot.prototype.addPanel()');\n                    }\n                    // Create the Panel and set its parent\n                    var panel = new LocusZoom.Panel(layout, this);\n                    // Store the Panel on the Plot\n                    this.panels[panel.id] = panel;\n                    // If a discrete y_index was set in the layout then adjust other panel y_index values to accommodate this one\n                    if (panel.layout.y_index !== null && !isNaN(panel.layout.y_index) && this.panel_ids_by_y_index.length > 0) {\n                        // Negative y_index values should count backwards from the end, so convert negatives to appropriate values here\n                        if (panel.layout.y_index < 0) {\n                            panel.layout.y_index = Math.max(this.panel_ids_by_y_index.length + panel.layout.y_index, 0);\n                        }\n                        this.panel_ids_by_y_index.splice(panel.layout.y_index, 0, panel.id);\n                        this.applyPanelYIndexesToPanelLayouts();\n                    } else {\n                        var length = this.panel_ids_by_y_index.push(panel.id);\n                        this.panels[panel.id].layout.y_index = length - 1;\n                    }\n                    // Determine if this panel was already in the layout.panels array.\n                    // If it wasn't, add it. Either way store the layout.panels array index on the panel.\n                    var layout_idx = null;\n                    this.layout.panels.forEach(function (panel_layout, idx) {\n                        if (panel_layout.id === panel.id) {\n                            layout_idx = idx;\n                        }\n                    });\n                    if (layout_idx === null) {\n                        layout_idx = this.layout.panels.push(this.panels[panel.id].layout) - 1;\n                    }\n                    this.panels[panel.id].layout_idx = layout_idx;\n                    // Call positionPanels() to keep panels from overlapping and ensure filling all available vertical space\n                    if (this.initialized) {\n                        this.positionPanels();\n                        // Initialize and load data into the new panel\n                        this.panels[panel.id].initialize();\n                        this.panels[panel.id].reMap();\n                        // An extra call to setDimensions with existing discrete dimensions fixes some rounding errors with tooltip\n                        // positioning. TODO: make this additional call unnecessary.\n                        this.setDimensions(this.layout.width, this.layout.height);\n                    }\n                    return this.panels[panel.id];\n                };\n                /**\n * Clear all state, tooltips, and other persisted data associated with one (or all) panel(s) in the plot\n *\n * This is useful when reloading an existing plot with new data, eg \"click for genome region\" links.\n *   This is a utility method for custom usage. It is not fired automatically during normal rerender of existing panels\n *   @param {String} [panelId] If provided, clear state for only this panel. Otherwise, clear state for all panels.\n *   @param {('wipe'|'reset')} [mode='wipe'] Optionally specify how state should be cleared. `wipe` deletes all data\n *     and is useful for when the panel is being removed; `reset` is best when the panel will be reused in place.\n * @returns {LocusZoom.Plot}\n */\n                LocusZoom.Plot.prototype.clearPanelData = function (panelId, mode) {\n                    mode = mode || 'wipe';\n                    // TODO: Add unit tests for this method\n                    var panelsList;\n                    if (panelId) {\n                        panelsList = [panelId];\n                    } else {\n                        panelsList = Object.keys(this.panels);\n                    }\n                    var self = this;\n                    panelsList.forEach(function (pid) {\n                        self.panels[pid].data_layer_ids_by_z_index.forEach(function (dlid) {\n                            var layer = self.panels[pid].data_layers[dlid];\n                            layer.destroyAllTooltips();\n                            delete self.layout.state[pid + '.' + dlid];\n                            if (mode === 'reset') {\n                                layer.setDefaultState();\n                            }\n                        });\n                    });\n                    return this;\n                };\n                /**\n * Remove the panel from the plot, and clear any state, tooltips, or other visual elements belonging to nested content\n * @param {String} id\n * @returns {LocusZoom.Plot}\n */\n                LocusZoom.Plot.prototype.removePanel = function (id) {\n                    if (!this.panels[id]) {\n                        throw new Error('Unable to remove panel, ID not found: ' + id);\n                    }\n                    // Hide all panel boundaries\n                    this.panel_boundaries.hide();\n                    // Destroy all tooltips and state vars for all data layers on the panel\n                    this.clearPanelData(id);\n                    // Remove all panel-level HTML overlay elements\n                    this.panels[id].loader.hide();\n                    this.panels[id].dashboard.destroy(true);\n                    this.panels[id].curtain.hide();\n                    // Remove the svg container for the panel if it exists\n                    if (this.panels[id].svg.container) {\n                        this.panels[id].svg.container.remove();\n                    }\n                    // Delete the panel and its presence in the plot layout and state\n                    this.layout.panels.splice(this.panels[id].layout_idx, 1);\n                    delete this.panels[id];\n                    delete this.layout.state[id];\n                    // Update layout_idx values for all remaining panels\n                    this.layout.panels.forEach(function (panel_layout, idx) {\n                        this.panels[panel_layout.id].layout_idx = idx;\n                    }.bind(this));\n                    // Remove the panel id from the y_index array\n                    this.panel_ids_by_y_index.splice(this.panel_ids_by_y_index.indexOf(id), 1);\n                    this.applyPanelYIndexesToPanelLayouts();\n                    // Call positionPanels() to keep panels from overlapping and ensure filling all available vertical space\n                    if (this.initialized) {\n                        // Allow the plot to shrink when panels are removed, by forcing it to recalculate min dimensions from scratch\n                        this.layout.min_height = this._base_layout.min_height;\n                        this.layout.min_width = this._base_layout.min_width;\n                        this.positionPanels();\n                        // An extra call to setDimensions with existing discrete dimensions fixes some rounding errors with tooltip\n                        // positioning. TODO: make this additional call unnecessary.\n                        this.setDimensions(this.layout.width, this.layout.height);\n                    }\n                    this.emit('panel_removed', id);\n                    return this;\n                };\n                /**\n * Automatically position panels based on panel positioning rules and values.\n * Keep panels from overlapping vertically by adjusting origins, and keep the sum of proportional heights at 1.\n *\n * TODO: This logic currently only supports dynamic positioning of panels to prevent overlap in a VERTICAL orientation.\n *      Some framework exists for positioning panels in horizontal orientations as well (width, proportional_width, origin.x, etc.)\n *      but the logic for keeping these user-definable values straight approaches the complexity of a 2D box-packing algorithm.\n *      That's complexity we don't need right now, and may not ever need, so it's on hiatus until a use case materializes.\n */\n                LocusZoom.Plot.prototype.positionPanels = function () {\n                    var id;\n                    // We want to enforce that all x-linked panels have consistent horizontal margins\n                    // (to ensure that aligned items stay aligned despite inconsistent initial layout parameters)\n                    // NOTE: This assumes panels have consistent widths already. That should probably be enforced too!\n                    var x_linked_margins = {\n                        left: 0,\n                        right: 0\n                    };\n                    // Proportional heights for newly added panels default to null unless explicitly set, so determine appropriate\n                    // proportional heights for all panels with a null value from discretely set dimensions.\n                    // Likewise handle default nulls for proportional widths, but instead just force a value of 1 (full width)\n                    for (id in this.panels) {\n                        if (this.panels[id].layout.proportional_height === null) {\n                            this.panels[id].layout.proportional_height = this.panels[id].layout.height / this.layout.height;\n                        }\n                        if (this.panels[id].layout.proportional_width === null) {\n                            this.panels[id].layout.proportional_width = 1;\n                        }\n                        if (this.panels[id].layout.interaction.x_linked) {\n                            x_linked_margins.left = Math.max(x_linked_margins.left, this.panels[id].layout.margin.left);\n                            x_linked_margins.right = Math.max(x_linked_margins.right, this.panels[id].layout.margin.right);\n                        }\n                    }\n                    // Sum the proportional heights and then adjust all proportionally so that the sum is exactly 1\n                    var total_proportional_height = this.sumProportional('height');\n                    if (!total_proportional_height) {\n                        return this;\n                    }\n                    var proportional_adjustment = 1 / total_proportional_height;\n                    for (id in this.panels) {\n                        this.panels[id].layout.proportional_height *= proportional_adjustment;\n                    }\n                    // Update origins on all panels without changing plot-level dimensions yet\n                    // Also apply x-linked margins to x-linked panels, updating widths as needed\n                    var y_offset = 0;\n                    this.panel_ids_by_y_index.forEach(function (panel_id) {\n                        this.panels[panel_id].setOrigin(0, y_offset);\n                        this.panels[panel_id].layout.proportional_origin.x = 0;\n                        y_offset += this.panels[panel_id].layout.height;\n                        if (this.panels[panel_id].layout.interaction.x_linked) {\n                            var delta = Math.max(x_linked_margins.left - this.panels[panel_id].layout.margin.left, 0) + Math.max(x_linked_margins.right - this.panels[panel_id].layout.margin.right, 0);\n                            this.panels[panel_id].layout.width += delta;\n                            this.panels[panel_id].layout.margin.left = x_linked_margins.left;\n                            this.panels[panel_id].layout.margin.right = x_linked_margins.right;\n                            this.panels[panel_id].layout.cliparea.origin.x = x_linked_margins.left;\n                        }\n                    }.bind(this));\n                    var calculated_plot_height = y_offset;\n                    this.panel_ids_by_y_index.forEach(function (panel_id) {\n                        this.panels[panel_id].layout.proportional_origin.y = this.panels[panel_id].layout.origin.y / calculated_plot_height;\n                    }.bind(this));\n                    // Update dimensions on the plot to accommodate repositioned panels\n                    this.setDimensions();\n                    // Set dimensions on all panels using newly set plot-level dimensions and panel-level proportional dimensions\n                    this.panel_ids_by_y_index.forEach(function (panel_id) {\n                        this.panels[panel_id].setDimensions(this.layout.width * this.panels[panel_id].layout.proportional_width, this.layout.height * this.panels[panel_id].layout.proportional_height);\n                    }.bind(this));\n                    return this;\n                };\n                /**\n * Prepare the first rendering of the plot. This includes initializing the individual panels, but also creates shared\n *   elements such as mouse events, panel guides/boundaries, and loader/curtain.\n *\n * @returns {LocusZoom.Plot}\n */\n                LocusZoom.Plot.prototype.initialize = function () {\n                    // Ensure proper responsive class is present on the containing node if called for\n                    if (this.layout.responsive_resize) {\n                        d3.select(this.container).classed('lz-container-responsive', true);\n                    }\n                    // Create an element/layer for containing mouse guides\n                    if (this.layout.mouse_guide) {\n                        var mouse_guide_svg = this.svg.append('g').attr('class', 'lz-mouse_guide').attr('id', this.id + '.mouse_guide');\n                        var mouse_guide_vertical_svg = mouse_guide_svg.append('rect').attr('class', 'lz-mouse_guide-vertical').attr('x', -1);\n                        var mouse_guide_horizontal_svg = mouse_guide_svg.append('rect').attr('class', 'lz-mouse_guide-horizontal').attr('y', -1);\n                        this.mouse_guide = {\n                            svg: mouse_guide_svg,\n                            vertical: mouse_guide_vertical_svg,\n                            horizontal: mouse_guide_horizontal_svg\n                        };\n                    }\n                    // Add curtain and loader prototpyes to the plot\n                    this.curtain = LocusZoom.generateCurtain.call(this);\n                    this.loader = LocusZoom.generateLoader.call(this);\n                    // Create the panel_boundaries object with show/position/hide methods\n                    this.panel_boundaries = {\n                        parent: this,\n                        hide_timeout: null,\n                        showing: false,\n                        dragging: false,\n                        selectors: [],\n                        corner_selector: null,\n                        show: function () {\n                            // Generate panel boundaries\n                            if (!this.showing && !this.parent.curtain.showing) {\n                                this.showing = true;\n                                // Loop through all panels to create a horizontal boundary for each\n                                this.parent.panel_ids_by_y_index.forEach(function (panel_id, panel_idx) {\n                                    var selector = d3.select(this.parent.svg.node().parentNode).insert('div', '.lz-data_layer-tooltip').attr('class', 'lz-panel-boundary').attr('title', 'Resize panel');\n                                    selector.append('span');\n                                    var panel_resize_drag = d3.behavior.drag();\n                                    panel_resize_drag.on('dragstart', function () {\n                                        this.dragging = true;\n                                    }.bind(this));\n                                    panel_resize_drag.on('dragend', function () {\n                                        this.dragging = false;\n                                    }.bind(this));\n                                    panel_resize_drag.on('drag', function () {\n                                        // First set the dimensions on the panel we're resizing\n                                        var this_panel = this.parent.panels[this.parent.panel_ids_by_y_index[panel_idx]];\n                                        var original_panel_height = this_panel.layout.height;\n                                        this_panel.setDimensions(this_panel.layout.width, this_panel.layout.height + d3.event.dy);\n                                        var panel_height_change = this_panel.layout.height - original_panel_height;\n                                        var new_calculated_plot_height = this.parent.layout.height + panel_height_change;\n                                        // Next loop through all panels.\n                                        // Update proportional dimensions for all panels including the one we've resized using discrete heights.\n                                        // Reposition panels with a greater y-index than this panel to their appropriate new origin.\n                                        this.parent.panel_ids_by_y_index.forEach(function (loop_panel_id, loop_panel_idx) {\n                                            var loop_panel = this.parent.panels[this.parent.panel_ids_by_y_index[loop_panel_idx]];\n                                            loop_panel.layout.proportional_height = loop_panel.layout.height / new_calculated_plot_height;\n                                            if (loop_panel_idx > panel_idx) {\n                                                loop_panel.setOrigin(loop_panel.layout.origin.x, loop_panel.layout.origin.y + panel_height_change);\n                                                loop_panel.dashboard.position();\n                                            }\n                                        }.bind(this));\n                                        // Reset dimensions on the entire plot and reposition panel boundaries\n                                        this.parent.positionPanels();\n                                        this.position();\n                                    }.bind(this));\n                                    selector.call(panel_resize_drag);\n                                    this.parent.panel_boundaries.selectors.push(selector);\n                                }.bind(this));\n                                // Create a corner boundary / resize element on the bottom-most panel that resizes the entire plot\n                                var corner_selector = d3.select(this.parent.svg.node().parentNode).insert('div', '.lz-data_layer-tooltip').attr('class', 'lz-panel-corner-boundary').attr('title', 'Resize plot');\n                                corner_selector.append('span').attr('class', 'lz-panel-corner-boundary-outer');\n                                corner_selector.append('span').attr('class', 'lz-panel-corner-boundary-inner');\n                                var corner_drag = d3.behavior.drag();\n                                corner_drag.on('dragstart', function () {\n                                    this.dragging = true;\n                                }.bind(this));\n                                corner_drag.on('dragend', function () {\n                                    this.dragging = false;\n                                }.bind(this));\n                                corner_drag.on('drag', function () {\n                                    this.setDimensions(this.layout.width + d3.event.dx, this.layout.height + d3.event.dy);\n                                }.bind(this.parent));\n                                corner_selector.call(corner_drag);\n                                this.parent.panel_boundaries.corner_selector = corner_selector;\n                            }\n                            return this.position();\n                        },\n                        position: function () {\n                            if (!this.showing) {\n                                return this;\n                            }\n                            // Position panel boundaries\n                            var plot_page_origin = this.parent.getPageOrigin();\n                            this.selectors.forEach(function (selector, panel_idx) {\n                                var panel_page_origin = this.parent.panels[this.parent.panel_ids_by_y_index[panel_idx]].getPageOrigin();\n                                var left = plot_page_origin.x;\n                                var top = panel_page_origin.y + this.parent.panels[this.parent.panel_ids_by_y_index[panel_idx]].layout.height - 12;\n                                var width = this.parent.layout.width - 1;\n                                selector.style({\n                                    top: top + 'px',\n                                    left: left + 'px',\n                                    width: width + 'px'\n                                });\n                                selector.select('span').style({ width: width + 'px' });\n                            }.bind(this));\n                            // Position corner selector\n                            var corner_padding = 10;\n                            var corner_size = 16;\n                            this.corner_selector.style({\n                                top: plot_page_origin.y + this.parent.layout.height - corner_padding - corner_size + 'px',\n                                left: plot_page_origin.x + this.parent.layout.width - corner_padding - corner_size + 'px'\n                            });\n                            return this;\n                        },\n                        hide: function () {\n                            if (!this.showing) {\n                                return this;\n                            }\n                            this.showing = false;\n                            // Remove panel boundaries\n                            this.selectors.forEach(function (selector) {\n                                selector.remove();\n                            });\n                            this.selectors = [];\n                            // Remove corner boundary\n                            this.corner_selector.remove();\n                            this.corner_selector = null;\n                            return this;\n                        }\n                    };\n                    // Show panel boundaries stipulated by the layout (basic toggle, only show on mouse over plot)\n                    if (this.layout.panel_boundaries) {\n                        d3.select(this.svg.node().parentNode).on('mouseover.' + this.id + '.panel_boundaries', function () {\n                            clearTimeout(this.panel_boundaries.hide_timeout);\n                            this.panel_boundaries.show();\n                        }.bind(this));\n                        d3.select(this.svg.node().parentNode).on('mouseout.' + this.id + '.panel_boundaries', function () {\n                            this.panel_boundaries.hide_timeout = setTimeout(function () {\n                                this.panel_boundaries.hide();\n                            }.bind(this), 300);\n                        }.bind(this));\n                    }\n                    // Create the dashboard object and immediately show it\n                    this.dashboard = new LocusZoom.Dashboard(this).show();\n                    // Initialize all panels\n                    for (var id in this.panels) {\n                        this.panels[id].initialize();\n                    }\n                    // Define plot-level mouse events\n                    var namespace = '.' + this.id;\n                    if (this.layout.mouse_guide) {\n                        var mouseout_mouse_guide = function () {\n                            this.mouse_guide.vertical.attr('x', -1);\n                            this.mouse_guide.horizontal.attr('y', -1);\n                        }.bind(this);\n                        var mousemove_mouse_guide = function () {\n                            var coords = d3.mouse(this.svg.node());\n                            this.mouse_guide.vertical.attr('x', coords[0]);\n                            this.mouse_guide.horizontal.attr('y', coords[1]);\n                        }.bind(this);\n                        this.svg.on('mouseout' + namespace + '-mouse_guide', mouseout_mouse_guide).on('touchleave' + namespace + '-mouse_guide', mouseout_mouse_guide).on('mousemove' + namespace + '-mouse_guide', mousemove_mouse_guide);\n                    }\n                    var mouseup = function () {\n                        this.stopDrag();\n                    }.bind(this);\n                    var mousemove = function () {\n                        if (this.interaction.dragging) {\n                            var coords = d3.mouse(this.svg.node());\n                            if (d3.event) {\n                                d3.event.preventDefault();\n                            }\n                            this.interaction.dragging.dragged_x = coords[0] - this.interaction.dragging.start_x;\n                            this.interaction.dragging.dragged_y = coords[1] - this.interaction.dragging.start_y;\n                            this.panels[this.interaction.panel_id].render();\n                            this.interaction.linked_panel_ids.forEach(function (panel_id) {\n                                this.panels[panel_id].render();\n                            }.bind(this));\n                        }\n                    }.bind(this);\n                    this.svg.on('mouseup' + namespace, mouseup).on('touchend' + namespace, mouseup).on('mousemove' + namespace, mousemove).on('touchmove' + namespace, mousemove);\n                    // Add an extra namespaced mouseup handler to the containing body, if there is one\n                    // This helps to stop interaction events gracefully when dragging outside of the plot element\n                    if (!d3.select('body').empty()) {\n                        d3.select('body').on('mouseup' + namespace, mouseup).on('touchend' + namespace, mouseup);\n                    }\n                    this.on('match_requested', function (eventData) {\n                        // Layers can broadcast that a specific point has been selected, and the plot will tell every other layer\n                        //  to look for that value. Whenever a point is de-selected, it clears the match.\n                        var data = eventData.data;\n                        var to_send = data.active ? data.value : null;\n                        this.applyState({ lz_match_value: to_send });\n                    }.bind(this));\n                    this.initialized = true;\n                    // An extra call to setDimensions with existing discrete dimensions fixes some rounding errors with tooltip\n                    // positioning. TODO: make this additional call unnecessary.\n                    var client_rect = this.svg.node().getBoundingClientRect();\n                    var width = client_rect.width ? client_rect.width : this.layout.width;\n                    var height = client_rect.height ? client_rect.height : this.layout.height;\n                    this.setDimensions(width, height);\n                    return this;\n                };\n                /**\n * Refresh (or fetch) a plot's data from sources, regardless of whether position or state has changed\n * @returns {Promise}\n */\n                LocusZoom.Plot.prototype.refresh = function () {\n                    return this.applyState();\n                };\n                /**\n * A user-defined callback function that can receive (and potentially act on) new plot data.\n * @callback externalDataCallback\n * @param {Object} new_data The body resulting from a data request. This represents the same information that would be passed to\n *  a data layer making an equivalent request.\n */\n                /**\n * A user-defined callback function that can respond to errors received during a previous operation\n * @callback externalErrorCallback\n * @param err A representation of the error that occurred\n */\n                /**\n * Allow newly fetched data to be made available outside the LocusZoom plot. For example, a callback could be\n *  registered to draw an HTML table of top GWAS hits, and update that table whenever the plot region changes.\n *\n * This is a convenience method for external hooks. It registers an event listener and returns parsed data,\n *  using the same fields syntax and underlying methods as data layers.\n *\n * @param {String[]} fields An array of field names and transforms, in the same syntax used by a data layer.\n *  Different data sources should be prefixed by the source name.\n * @param {externalDataCallback} success_callback Used defined function that is automatically called any time that\n *  new data is received by the plot.\n * @param {Object} [opts] Options\n * @param {externalErrorCallback} [opts.onerror] User defined function that is automatically called if a problem\n *  occurs during the data request or subsequent callback operations\n * @param {boolean} [opts.discrete=false] Normally the callback will subscribe to the combined body from the chain,\n *  which may not be in a format that matches what the external callback wants to do. If discrete=true, returns the\n *  uncombined record info\n *  @return {function} The newly created event listener, to allow for later cleanup/removal\n */\n                LocusZoom.Plot.prototype.subscribeToData = function (fields, success_callback, opts) {\n                    opts = opts || {};\n                    // Register an event listener that is notified whenever new data has been rendered\n                    var error_callback = opts.onerror || function (err) {\n                        console.log('An error occurred while acting on an external callback', err);\n                    };\n                    var self = this;\n                    var listener = function () {\n                        try {\n                            self.lzd.getData(self.state, fields).then(function (new_data) {\n                                success_callback(opts.discrete ? new_data.discrete : new_data.body);\n                            }).catch(error_callback);\n                        } catch (error) {\n                            // In certain cases, errors are thrown before a promise can be generated, and LZ error display seems to rely on these errors bubbling up\n                            error_callback(error);\n                        }\n                    };\n                    this.on('data_rendered', listener);\n                    return listener;\n                };\n                /**\n * Update state values and trigger a pull for fresh data on all data sources for all data layers\n * @param state_changes\n * @returns {Promise} A promise that resolves when all data fetch and update operations are complete\n */\n                LocusZoom.Plot.prototype.applyState = function (state_changes) {\n                    state_changes = state_changes || {};\n                    if (typeof state_changes != 'object') {\n                        throw new Error('LocusZoom.applyState only accepts an object; ' + typeof state_changes + ' given');\n                    }\n                    // First make a copy of the current (old) state to work with\n                    var new_state = JSON.parse(JSON.stringify(this.state));\n                    // Apply changes by top-level property to the new state\n                    for (var property in state_changes) {\n                        new_state[property] = state_changes[property];\n                    }\n                    // Validate the new state (may do nothing, may do a lot, depends on how the user has things set up)\n                    new_state = LocusZoom.validateState(new_state, this.layout);\n                    // Apply new state to the actual state\n                    for (property in new_state) {\n                        this.state[property] = new_state[property];\n                    }\n                    // Generate requests for all panels given new state\n                    this.emit('data_requested');\n                    this.remap_promises = [];\n                    this.loading_data = true;\n                    for (var id in this.panels) {\n                        this.remap_promises.push(this.panels[id].reMap());\n                    }\n                    return Promise.all(this.remap_promises).catch(function (error) {\n                        console.error(error);\n                        this.curtain.show(error.message || error);\n                        this.loading_data = false;\n                    }.bind(this)).then(function () {\n                        // Update dashboard / components\n                        this.dashboard.update();\n                        // Apply panel-level state values\n                        this.panel_ids_by_y_index.forEach(function (panel_id) {\n                            var panel = this.panels[panel_id];\n                            panel.dashboard.update();\n                            // Apply data-layer-level state values\n                            panel.data_layer_ids_by_z_index.forEach(function (data_layer_id) {\n                                var data_layer = this.data_layers[data_layer_id];\n                                var state_id = panel_id + '.' + data_layer_id;\n                                for (var property in this.state[state_id]) {\n                                    if (!this.state[state_id].hasOwnProperty(property)) {\n                                        continue;\n                                    }\n                                    if (Array.isArray(this.state[state_id][property])) {\n                                        this.state[state_id][property].forEach(function (element_id) {\n                                            try {\n                                                this.setElementStatus(property, this.getElementById(element_id), true);\n                                            } catch (e) {\n                                                console.warn('Unable to apply state: ' + state_id + ', ' + property);\n                                                console.error(e);\n                                            }\n                                        }.bind(data_layer));\n                                    }\n                                }\n                            }.bind(panel));\n                        }.bind(this));\n                        // Emit events\n                        this.emit('layout_changed');\n                        this.emit('data_rendered');\n                        this.emit('state_changed', state_changes);\n                        this.loading_data = false;\n                    }.bind(this));\n                };\n                /**\n * Register interactions along the specified axis, provided that the target panel allows interaction.\n *\n * @param {LocusZoom.Panel} panel\n * @param {('x_tick'|'y1_tick'|'y2_tick')} method The direction (axis) along which dragging is being performed.\n * @returns {LocusZoom.Plot}\n */\n                LocusZoom.Plot.prototype.startDrag = function (panel, method) {\n                    panel = panel || null;\n                    method = method || null;\n                    var axis = null;\n                    switch (method) {\n                    case 'background':\n                    case 'x_tick':\n                        axis = 'x';\n                        break;\n                    case 'y1_tick':\n                        axis = 'y1';\n                        break;\n                    case 'y2_tick':\n                        axis = 'y2';\n                        break;\n                    }\n                    if (!(panel instanceof LocusZoom.Panel) || !axis || !this.canInteract()) {\n                        return this.stopDrag();\n                    }\n                    var coords = d3.mouse(this.svg.node());\n                    this.interaction = {\n                        panel_id: panel.id,\n                        linked_panel_ids: panel.getLinkedPanelIds(axis),\n                        dragging: {\n                            method: method,\n                            start_x: coords[0],\n                            start_y: coords[1],\n                            dragged_x: 0,\n                            dragged_y: 0,\n                            axis: axis\n                        }\n                    };\n                    this.svg.style('cursor', 'all-scroll');\n                    return this;\n                };\n                /**\n * Process drag interactions across the target panel and synchronize plot state across other panels in sync;\n *   clear the event when complete\n * @returns {LocusZoom.Plot}\n */\n                LocusZoom.Plot.prototype.stopDrag = function () {\n                    if (!this.interaction.dragging) {\n                        return this;\n                    }\n                    if (typeof this.panels[this.interaction.panel_id] != 'object') {\n                        this.interaction = {};\n                        return this;\n                    }\n                    var panel = this.panels[this.interaction.panel_id];\n                    // Helper function to find the appropriate axis layouts on child data layers\n                    // Once found, apply the extent as floor/ceiling and remove all other directives\n                    // This forces all associated axes to conform to the extent generated by a drag action\n                    var overrideAxisLayout = function (axis, axis_number, extent) {\n                        panel.data_layer_ids_by_z_index.forEach(function (id) {\n                            if (panel.data_layers[id].layout[axis + '_axis'].axis === axis_number) {\n                                panel.data_layers[id].layout[axis + '_axis'].floor = extent[0];\n                                panel.data_layers[id].layout[axis + '_axis'].ceiling = extent[1];\n                                delete panel.data_layers[id].layout[axis + '_axis'].lower_buffer;\n                                delete panel.data_layers[id].layout[axis + '_axis'].upper_buffer;\n                                delete panel.data_layers[id].layout[axis + '_axis'].min_extent;\n                                delete panel.data_layers[id].layout[axis + '_axis'].ticks;\n                            }\n                        });\n                    };\n                    switch (this.interaction.dragging.method) {\n                    case 'background':\n                    case 'x_tick':\n                        if (this.interaction.dragging.dragged_x !== 0) {\n                            overrideAxisLayout('x', 1, panel.x_extent);\n                            this.applyState({\n                                start: panel.x_extent[0],\n                                end: panel.x_extent[1]\n                            });\n                        }\n                        break;\n                    case 'y1_tick':\n                    case 'y2_tick':\n                        if (this.interaction.dragging.dragged_y !== 0) {\n                            // TODO: Hardcoded assumption of only two possible axes with single-digit #s (switch/case)\n                            var y_axis_number = parseInt(this.interaction.dragging.method[1]);\n                            overrideAxisLayout('y', y_axis_number, panel['y' + y_axis_number + '_extent']);\n                        }\n                        break;\n                    }\n                    this.interaction = {};\n                    this.svg.style('cursor', null);\n                    return this;\n                };\n                /* global LocusZoom */\n                'use strict';\n                /**\n * A panel is an abstract class representing a subdivision of the LocusZoom stage\n *   to display a distinct data representation as a collection of data layers.\n * @class\n * @param {Object} layout\n * @param {LocusZoom.Plot|null} parent\n*/\n                LocusZoom.Panel = function (layout, parent) {\n                    if (typeof layout !== 'object') {\n                        throw new Error('Unable to create panel, invalid layout');\n                    }\n                    /** @member {LocusZoom.Plot|null} */\n                    this.parent = parent || null;\n                    /** @member {LocusZoom.Plot|null} */\n                    this.parent_plot = parent;\n                    // Ensure a valid ID is present. If there is no valid ID then generate one\n                    if (typeof layout.id !== 'string' || !layout.id.length) {\n                        if (!this.parent) {\n                            layout.id = 'p' + Math.floor(Math.random() * Math.pow(10, 8));\n                        } else {\n                            var id = null;\n                            var generateID = function () {\n                                id = 'p' + Math.floor(Math.random() * Math.pow(10, 8));\n                                if (id == null || typeof this.parent.panels[id] != 'undefined') {\n                                    id = generateID();\n                                }\n                            }.bind(this);\n                            layout.id = id;\n                        }\n                    } else if (this.parent) {\n                        if (typeof this.parent.panels[layout.id] !== 'undefined') {\n                            throw new Error('Cannot create panel with id [' + layout.id + ']; panel with that id already exists');\n                        }\n                    }\n                    /** @member {String} */\n                    this.id = layout.id;\n                    /** @member {Boolean} */\n                    this.initialized = false;\n                    /**\n     * The index of this panel in the parent plot's `layout.panels`\n     * @member {number}\n     * */\n                    this.layout_idx = null;\n                    /** @member {Object} */\n                    this.svg = {};\n                    /**\n     * A JSON-serializable object used to describe the composition of the Panel\n     * @member {Object}\n     */\n                    this.layout = LocusZoom.Layouts.merge(layout || {}, LocusZoom.Panel.DefaultLayout);\n                    // Define state parameters specific to this panel\n                    if (this.parent) {\n                        /** @member {Object} */\n                        this.state = this.parent.state;\n                        /** @member {String} */\n                        this.state_id = this.id;\n                        this.state[this.state_id] = this.state[this.state_id] || {};\n                    } else {\n                        this.state = null;\n                        this.state_id = null;\n                    }\n                    /** @member {Object} */\n                    this.data_layers = {};\n                    /** @member {String[]} */\n                    this.data_layer_ids_by_z_index = [];\n                    /** @protected */\n                    this.applyDataLayerZIndexesToDataLayerLayouts = function () {\n                        this.data_layer_ids_by_z_index.forEach(function (dlid, idx) {\n                            this.data_layers[dlid].layout.z_index = idx;\n                        }.bind(this));\n                    }.bind(this);\n                    /**\n     * Track data requests in progress\n     * @member {Promise[]}\n     *  @protected\n     */\n                    this.data_promises = [];\n                    /** @member {d3.scale} */\n                    this.x_scale = null;\n                    /** @member {d3.scale} */\n                    this.y1_scale = null;\n                    /** @member {d3.scale} */\n                    this.y2_scale = null;\n                    /** @member {d3.extent} */\n                    this.x_extent = null;\n                    /** @member {d3.extent} */\n                    this.y1_extent = null;\n                    /** @member {d3.extent} */\n                    this.y2_extent = null;\n                    /** @member {Number[]} */\n                    this.x_ticks = [];\n                    /** @member {Number[]} */\n                    this.y1_ticks = [];\n                    /** @member {Number[]} */\n                    this.y2_ticks = [];\n                    /**\n     * A timeout ID as returned by setTimeout\n     * @protected\n     * @member {number}\n     */\n                    this.zoom_timeout = null;\n                    /** @returns {string} */\n                    this.getBaseId = function () {\n                        return this.parent.id + '.' + this.id;\n                    };\n                    /**\n     * Known event hooks that the panel can respond to\n     * @protected\n     * @member {Object}\n     */\n                    this.event_hooks = {\n                        'layout_changed': [],\n                        'data_requested': [],\n                        'data_rendered': [],\n                        'element_clicked': [],\n                        'element_selection': [],\n                        'match_requested': []    // A data layer is attempting to highlight matching points (internal use only)\n                    };\n                    /**\n     * There are several events that a LocusZoom panel can \"emit\" when appropriate, and LocusZoom supports registering\n     *   \"hooks\" for these events which are essentially custom functions intended to fire at certain times.\n     *\n     * The following panel-level events are currently supported:\n     *   - `layout_changed` - context: panel - Any aspect of the panel's layout (including dimensions or state) has changed.\n     *   - `data_requested` - context: panel - A request for new data from any data source used in the panel has been made.\n     *   - `data_rendered` - context: panel - Data from a request has been received and rendered in the panel.\n     *   - `element_clicked` - context: panel - A data element in any of the panel's data layers has been clicked.\n     *   - `element_selection` - context: panel - Triggered when an element changes \"selection\" status, and identifies\n     *        whether the element is being selected or deselected.\n     *\n     * To register a hook for any of these events use `panel.on('event_name', function() {})`.\n     *\n     * There can be arbitrarily many functions registered to the same event. They will be executed in the order they\n     *   were registered. The this context bound to each event hook function is dependent on the type of event, as\n     *   denoted above. For example, when data_requested is emitted the context for this in the event hook will be the\n     *   panel itself, but when element_clicked is emitted the context for this in the event hook will be the element\n     *   that was clicked.\n     *\n     * @param {String} event The name of the event (as defined in `event_hooks`)\n     * @param {function} hook\n     * @returns {function} The registered event listener\n     */\n                    this.on = function (event, hook) {\n                        // TODO: Dry plot and panel event code into a shared mixin\n                        if (typeof 'event' != 'string' || !Array.isArray(this.event_hooks[event])) {\n                            throw new Error('Unable to register event hook, invalid event: ' + event.toString());\n                        }\n                        if (typeof hook != 'function') {\n                            throw new Error('Unable to register event hook, invalid hook function passed');\n                        }\n                        this.event_hooks[event].push(hook);\n                        return hook;\n                    };\n                    /**\n     * Remove one or more previously defined event listeners\n     * @param {String} event The name of an event (as defined in `event_hooks`)\n     * @param {eventCallback} [hook] The callback to deregister\n     * @returns {LocusZoom.Panel}\n     */\n                    this.off = function (event, hook) {\n                        var theseHooks = this.event_hooks[event];\n                        if (typeof 'event' != 'string' || !Array.isArray(theseHooks)) {\n                            throw new Error('Unable to remove event hook, invalid event: ' + event.toString());\n                        }\n                        if (hook === undefined) {\n                            // Deregistering all hooks for this event may break basic functionality, and should only be used during\n                            //  cleanup operations (eg to prevent memory leaks)\n                            this.event_hooks[event] = [];\n                        } else {\n                            var hookMatch = theseHooks.indexOf(hook);\n                            if (hookMatch !== -1) {\n                                theseHooks.splice(hookMatch, 1);\n                            } else {\n                                throw new Error('The specified event listener is not registered and therefore cannot be removed');\n                            }\n                        }\n                        return this;\n                    };\n                    /**\n     * Handle running of event hooks when an event is emitted\n     *\n     * There is a shorter overloaded form of this method: if the event does not have any data, the second\n     *   argument can be a boolean to control bubbling\n     *\n     * @param {string} event A known event name\n     * @param {*} [eventData] Data or event description that will be passed to the event listener\n     * @param {boolean} [bubble=false] Whether to bubble the event to the parent\n     * @returns {LocusZoom.Panel}\n     */\n                    this.emit = function (event, eventData, bubble) {\n                        bubble = bubble || false;\n                        // TODO: DRY this with the parent plot implementation. Ensure interfaces remain compatible.\n                        // TODO: Improve documentation for overloaded method signature (JSDoc may have trouble here)\n                        if (typeof 'event' != 'string' || !Array.isArray(this.event_hooks[event])) {\n                            throw new Error('LocusZoom attempted to throw an invalid event: ' + event.toString());\n                        }\n                        if (typeof eventData === 'boolean' && arguments.length === 2) {\n                            // Overloaded method signature: emit(event, bubble)\n                            bubble = eventData;\n                            eventData = null;\n                        }\n                        var sourceID = this.getBaseId();\n                        var self = this;\n                        var eventContext = {\n                            sourceID: sourceID,\n                            data: eventData || null\n                        };\n                        this.event_hooks[event].forEach(function (hookToRun) {\n                            // By default, any handlers fired here will see the panel as the value of `this`. If a bound function is\n                            // registered as a handler, the previously bound `this` will override anything provided to `call` below.\n                            hookToRun.call(self, eventContext);\n                        });\n                        if (bubble && this.parent) {\n                            this.parent.emit(event, eventContext);\n                        }\n                        return this;\n                    };\n                    /**\n     * Get an object with the x and y coordinates of the panel's origin in terms of the entire page\n     * Necessary for positioning any HTML elements over the panel\n     * @returns {{x: Number, y: Number}}\n     */\n                    this.getPageOrigin = function () {\n                        var plot_origin = this.parent.getPageOrigin();\n                        return {\n                            x: plot_origin.x + this.layout.origin.x,\n                            y: plot_origin.y + this.layout.origin.y\n                        };\n                    };\n                    // Initialize the layout\n                    this.initializeLayout();\n                    return this;\n                };\n                /**\n * Default panel layout\n * @static\n * @type {Object}\n */\n                LocusZoom.Panel.DefaultLayout = {\n                    title: {\n                        text: '',\n                        style: {},\n                        x: 10,\n                        y: 22\n                    },\n                    y_index: null,\n                    width: 0,\n                    height: 0,\n                    origin: {\n                        x: 0,\n                        y: null\n                    },\n                    min_width: 1,\n                    min_height: 1,\n                    proportional_width: null,\n                    proportional_height: null,\n                    proportional_origin: {\n                        x: 0,\n                        y: null\n                    },\n                    margin: {\n                        top: 0,\n                        right: 0,\n                        bottom: 0,\n                        left: 0\n                    },\n                    background_click: 'clear_selections',\n                    dashboard: { components: [] },\n                    cliparea: {\n                        height: 0,\n                        width: 0,\n                        origin: {\n                            x: 0,\n                            y: 0\n                        }\n                    },\n                    axes: {\n                        // These are the only axes supported!!\n                        x: {},\n                        y1: {},\n                        y2: {}\n                    },\n                    legend: null,\n                    interaction: {\n                        drag_background_to_pan: false,\n                        drag_x_ticks_to_scale: false,\n                        drag_y1_ticks_to_scale: false,\n                        drag_y2_ticks_to_scale: false,\n                        scroll_to_zoom: false,\n                        x_linked: false,\n                        y1_linked: false,\n                        y2_linked: false\n                    },\n                    data_layers: []\n                };\n                /**\n * Prepare the panel for first use by performing parameter validation, creating axes, setting default dimensions,\n *   and preparing / positioning data layers as appropriate.\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Panel.prototype.initializeLayout = function () {\n                    // If the layout is missing BOTH width and proportional width then set the proportional width to 1.\n                    // This will default the panel to taking up the full width of the plot.\n                    if (this.layout.width === 0 && this.layout.proportional_width === null) {\n                        this.layout.proportional_width = 1;\n                    }\n                    // If the layout is missing BOTH height and proportional height then set the proportional height to\n                    // an equal share of the plot's current height.\n                    if (this.layout.height === 0 && this.layout.proportional_height === null) {\n                        var panel_count = Object.keys(this.parent.panels).length;\n                        if (panel_count > 0) {\n                            this.layout.proportional_height = 1 / panel_count;\n                        } else {\n                            this.layout.proportional_height = 1;\n                        }\n                    }\n                    // Set panel dimensions, origin, and margin\n                    this.setDimensions();\n                    this.setOrigin();\n                    this.setMargin();\n                    // Set ranges\n                    // TODO: Define stub values in constructor\n                    this.x_range = [\n                        0,\n                        this.layout.cliparea.width\n                    ];\n                    this.y1_range = [\n                        this.layout.cliparea.height,\n                        0\n                    ];\n                    this.y2_range = [\n                        this.layout.cliparea.height,\n                        0\n                    ];\n                    // Initialize panel axes\n                    [\n                        'x',\n                        'y1',\n                        'y2'\n                    ].forEach(function (axis) {\n                        if (!Object.keys(this.layout.axes[axis]).length || this.layout.axes[axis].render === false) {\n                            // The default layout sets the axis to an empty object, so set its render boolean here\n                            this.layout.axes[axis].render = false;\n                        } else {\n                            this.layout.axes[axis].render = true;\n                            this.layout.axes[axis].label = this.layout.axes[axis].label || null;\n                            this.layout.axes[axis].label_function = this.layout.axes[axis].label_function || null;\n                        }\n                    }.bind(this));\n                    // Add data layers (which define x and y extents)\n                    this.layout.data_layers.forEach(function (data_layer_layout) {\n                        this.addDataLayer(data_layer_layout);\n                    }.bind(this));\n                    return this;\n                };\n                /**\n * Set the dimensions for the panel. If passed with no arguments will calculate optimal size based on layout\n *   directives and the available area within the plot. If passed discrete width (number) and height (number) will\n *   attempt to resize the panel to them, but may be limited by minimum dimensions defined on the plot or panel.\n *\n * @public\n * @param {number} [width]\n * @param {number} [height]\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Panel.prototype.setDimensions = function (width, height) {\n                    if (typeof width != 'undefined' && typeof height != 'undefined') {\n                        if (!isNaN(width) && width >= 0 && !isNaN(height) && height >= 0) {\n                            this.layout.width = Math.max(Math.round(+width), this.layout.min_width);\n                            this.layout.height = Math.max(Math.round(+height), this.layout.min_height);\n                        }\n                    } else {\n                        if (this.layout.proportional_width !== null) {\n                            this.layout.width = Math.max(this.layout.proportional_width * this.parent.layout.width, this.layout.min_width);\n                        }\n                        if (this.layout.proportional_height !== null) {\n                            this.layout.height = Math.max(this.layout.proportional_height * this.parent.layout.height, this.layout.min_height);\n                        }\n                    }\n                    this.layout.cliparea.width = Math.max(this.layout.width - (this.layout.margin.left + this.layout.margin.right), 0);\n                    this.layout.cliparea.height = Math.max(this.layout.height - (this.layout.margin.top + this.layout.margin.bottom), 0);\n                    if (this.svg.clipRect) {\n                        this.svg.clipRect.attr('width', this.layout.width).attr('height', this.layout.height);\n                    }\n                    if (this.initialized) {\n                        this.render();\n                        this.curtain.update();\n                        this.loader.update();\n                        this.dashboard.update();\n                        if (this.legend) {\n                            this.legend.position();\n                        }\n                    }\n                    return this;\n                };\n                /**\n * Set panel origin on the plot, and re-render as appropriate\n *\n * @public\n * @param {number} x\n * @param {number} y\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Panel.prototype.setOrigin = function (x, y) {\n                    if (!isNaN(x) && x >= 0) {\n                        this.layout.origin.x = Math.max(Math.round(+x), 0);\n                    }\n                    if (!isNaN(y) && y >= 0) {\n                        this.layout.origin.y = Math.max(Math.round(+y), 0);\n                    }\n                    if (this.initialized) {\n                        this.render();\n                    }\n                    return this;\n                };\n                /**\n * Set margins around this panel\n * @public\n * @param {number} top\n * @param {number} right\n * @param {number} bottom\n * @param {number} left\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Panel.prototype.setMargin = function (top, right, bottom, left) {\n                    var extra;\n                    if (!isNaN(top) && top >= 0) {\n                        this.layout.margin.top = Math.max(Math.round(+top), 0);\n                    }\n                    if (!isNaN(right) && right >= 0) {\n                        this.layout.margin.right = Math.max(Math.round(+right), 0);\n                    }\n                    if (!isNaN(bottom) && bottom >= 0) {\n                        this.layout.margin.bottom = Math.max(Math.round(+bottom), 0);\n                    }\n                    if (!isNaN(left) && left >= 0) {\n                        this.layout.margin.left = Math.max(Math.round(+left), 0);\n                    }\n                    if (this.layout.margin.top + this.layout.margin.bottom > this.layout.height) {\n                        extra = Math.floor((this.layout.margin.top + this.layout.margin.bottom - this.layout.height) / 2);\n                        this.layout.margin.top -= extra;\n                        this.layout.margin.bottom -= extra;\n                    }\n                    if (this.layout.margin.left + this.layout.margin.right > this.layout.width) {\n                        extra = Math.floor((this.layout.margin.left + this.layout.margin.right - this.layout.width) / 2);\n                        this.layout.margin.left -= extra;\n                        this.layout.margin.right -= extra;\n                    }\n                    [\n                        'top',\n                        'right',\n                        'bottom',\n                        'left'\n                    ].forEach(function (m) {\n                        this.layout.margin[m] = Math.max(this.layout.margin[m], 0);\n                    }.bind(this));\n                    this.layout.cliparea.width = Math.max(this.layout.width - (this.layout.margin.left + this.layout.margin.right), 0);\n                    this.layout.cliparea.height = Math.max(this.layout.height - (this.layout.margin.top + this.layout.margin.bottom), 0);\n                    this.layout.cliparea.origin.x = this.layout.margin.left;\n                    this.layout.cliparea.origin.y = this.layout.margin.top;\n                    if (this.initialized) {\n                        this.render();\n                    }\n                    return this;\n                };\n                /**\n * Set the title for the panel. If passed an object, will merge the object with the existing layout configuration, so\n *   that all or only some of the title layout object's parameters can be customized. If passed null, false, or an empty\n *   string, the title DOM element will be set to display: none.\n *\n * @param {string|object|null} title The title text, or an object with additional configuration\n * @param {string} title.text Text to display. Since titles are rendered as SVG text, HTML and newlines will not be rendered.\n * @param {number} title.x X-offset, in pixels, for the title's text anchor (default left) relative to the top-left corner of the panel.\n * @param {number} title.y Y-offset, in pixels, for the title's text anchor (default left) relative to the top-left corner of the panel.\n    NOTE: SVG y values go from the top down, so the SVG origin of (0,0) is in the top left corner.\n * @param {object} title.style CSS styles object to be applied to the title's DOM element.\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Panel.prototype.setTitle = function (title) {\n                    if (typeof this.layout.title == 'string') {\n                        var text = this.layout.title;\n                        this.layout.title = {\n                            text: text,\n                            x: 0,\n                            y: 0,\n                            style: {}\n                        };\n                    }\n                    if (typeof title == 'string') {\n                        this.layout.title.text = title;\n                    } else if (typeof title == 'object' && title !== null) {\n                        this.layout.title = LocusZoom.Layouts.merge(title, this.layout.title);\n                    }\n                    if (this.layout.title.text.length) {\n                        this.title.attr('display', null).attr('x', parseFloat(this.layout.title.x)).attr('y', parseFloat(this.layout.title.y)).style(this.layout.title.style).text(this.layout.title.text);\n                    } else {\n                        this.title.attr('display', 'none');\n                    }\n                    return this;\n                };\n                /**\n * Prepare the first rendering of the panel. This includes drawing the individual data layers, but also creates shared\n *   elements such as axes,  title, and loader/curtain.\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Panel.prototype.initialize = function () {\n                    // Append a container group element to house the main panel group element and the clip path\n                    // Position with initial layout parameters\n                    this.svg.container = this.parent.svg.append('g').attr('id', this.getBaseId() + '.panel_container').attr('transform', 'translate(' + (this.layout.origin.x || 0) + ',' + (this.layout.origin.y || 0) + ')');\n                    // Append clip path to the parent svg element, size with initial layout parameters\n                    var clipPath = this.svg.container.append('clipPath').attr('id', this.getBaseId() + '.clip');\n                    this.svg.clipRect = clipPath.append('rect').attr('width', this.layout.width).attr('height', this.layout.height);\n                    // Append svg group for rendering all panel child elements, clipped by the clip path\n                    this.svg.group = this.svg.container.append('g').attr('id', this.getBaseId() + '.panel').attr('clip-path', 'url(#' + this.getBaseId() + '.clip)');\n                    // Add curtain and loader prototypes to the panel\n                    /** @member {Object} */\n                    this.curtain = LocusZoom.generateCurtain.call(this);\n                    /** @member {Object} */\n                    this.loader = LocusZoom.generateLoader.call(this);\n                    /**\n     * Create the dashboard object and hang components on it as defined by panel layout\n     * @member {LocusZoom.Dashboard}\n     */\n                    this.dashboard = new LocusZoom.Dashboard(this);\n                    // Inner border\n                    this.inner_border = this.svg.group.append('rect').attr('class', 'lz-panel-background').on('click', function () {\n                        if (this.layout.background_click === 'clear_selections') {\n                            this.clearSelections();\n                        }\n                    }.bind(this));\n                    // Add the title\n                    /** @member {Element} */\n                    this.title = this.svg.group.append('text').attr('class', 'lz-panel-title');\n                    if (typeof this.layout.title != 'undefined') {\n                        this.setTitle();\n                    }\n                    // Initialize Axes\n                    this.svg.x_axis = this.svg.group.append('g').attr('id', this.getBaseId() + '.x_axis').attr('class', 'lz-x lz-axis');\n                    if (this.layout.axes.x.render) {\n                        this.svg.x_axis_label = this.svg.x_axis.append('text').attr('class', 'lz-x lz-axis lz-label').attr('text-anchor', 'middle');\n                    }\n                    this.svg.y1_axis = this.svg.group.append('g').attr('id', this.getBaseId() + '.y1_axis').attr('class', 'lz-y lz-y1 lz-axis');\n                    if (this.layout.axes.y1.render) {\n                        this.svg.y1_axis_label = this.svg.y1_axis.append('text').attr('class', 'lz-y1 lz-axis lz-label').attr('text-anchor', 'middle');\n                    }\n                    this.svg.y2_axis = this.svg.group.append('g').attr('id', this.getBaseId() + '.y2_axis').attr('class', 'lz-y lz-y2 lz-axis');\n                    if (this.layout.axes.y2.render) {\n                        this.svg.y2_axis_label = this.svg.y2_axis.append('text').attr('class', 'lz-y2 lz-axis lz-label').attr('text-anchor', 'middle');\n                    }\n                    // Initialize child Data Layers\n                    this.data_layer_ids_by_z_index.forEach(function (id) {\n                        this.data_layers[id].initialize();\n                    }.bind(this));\n                    /**\n     * Legend object, as defined by panel layout and child data layer layouts\n     * @member {LocusZoom.Legend}\n     * */\n                    this.legend = null;\n                    if (this.layout.legend) {\n                        this.legend = new LocusZoom.Legend(this);\n                    }\n                    // Establish panel background drag interaction mousedown event handler (on the panel background)\n                    if (this.layout.interaction.drag_background_to_pan) {\n                        var namespace = '.' + this.parent.id + '.' + this.id + '.interaction.drag';\n                        var mousedown = function () {\n                            this.parent.startDrag(this, 'background');\n                        }.bind(this);\n                        this.svg.container.select('.lz-panel-background').on('mousedown' + namespace + '.background', mousedown).on('touchstart' + namespace + '.background', mousedown);\n                    }\n                    return this;\n                };\n                /**\n * Refresh the sort order of all data layers (called by data layer moveUp and moveDown methods)\n */\n                LocusZoom.Panel.prototype.resortDataLayers = function () {\n                    var sort = [];\n                    this.data_layer_ids_by_z_index.forEach(function (id) {\n                        sort.push(this.data_layers[id].layout.z_index);\n                    }.bind(this));\n                    this.svg.group.selectAll('g.lz-data_layer-container').data(sort).sort(d3.ascending);\n                    this.applyDataLayerZIndexesToDataLayerLayouts();\n                };\n                /**\n * Get an array of panel IDs that are axis-linked to this panel\n * @param {('x'|'y1'|'y2')} axis\n * @returns {Array}\n */\n                LocusZoom.Panel.prototype.getLinkedPanelIds = function (axis) {\n                    axis = axis || null;\n                    var linked_panel_ids = [];\n                    if ([\n                            'x',\n                            'y1',\n                            'y2'\n                        ].indexOf(axis) === -1) {\n                        return linked_panel_ids;\n                    }\n                    if (!this.layout.interaction[axis + '_linked']) {\n                        return linked_panel_ids;\n                    }\n                    this.parent.panel_ids_by_y_index.forEach(function (panel_id) {\n                        if (panel_id !== this.id && this.parent.panels[panel_id].layout.interaction[axis + '_linked']) {\n                            linked_panel_ids.push(panel_id);\n                        }\n                    }.bind(this));\n                    return linked_panel_ids;\n                };\n                /**\n * Move a panel up relative to others by y-index\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Panel.prototype.moveUp = function () {\n                    if (this.parent.panel_ids_by_y_index[this.layout.y_index - 1]) {\n                        this.parent.panel_ids_by_y_index[this.layout.y_index] = this.parent.panel_ids_by_y_index[this.layout.y_index - 1];\n                        this.parent.panel_ids_by_y_index[this.layout.y_index - 1] = this.id;\n                        this.parent.applyPanelYIndexesToPanelLayouts();\n                        this.parent.positionPanels();\n                    }\n                    return this;\n                };\n                /**\n * Move a panel down (y-axis) relative to others in the plot\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Panel.prototype.moveDown = function () {\n                    if (this.parent.panel_ids_by_y_index[this.layout.y_index + 1]) {\n                        this.parent.panel_ids_by_y_index[this.layout.y_index] = this.parent.panel_ids_by_y_index[this.layout.y_index + 1];\n                        this.parent.panel_ids_by_y_index[this.layout.y_index + 1] = this.id;\n                        this.parent.applyPanelYIndexesToPanelLayouts();\n                        this.parent.positionPanels();\n                    }\n                    return this;\n                };\n                /**\n * Create a new data layer from a provided layout object. Should have the keys specified in `DefaultLayout`\n * Will automatically add at the top (depth/z-index) of the panel unless explicitly directed differently\n *   in the layout provided.\n * @param {object} layout\n * @returns {*}\n */\n                LocusZoom.Panel.prototype.addDataLayer = function (layout) {\n                    // Sanity checks\n                    if (typeof layout !== 'object' || typeof layout.id !== 'string' || !layout.id.length) {\n                        throw new Error('Invalid data layer layout passed to LocusZoom.Panel.prototype.addDataLayer()');\n                    }\n                    if (typeof this.data_layers[layout.id] !== 'undefined') {\n                        throw new Error('Cannot create data_layer with id [' + layout.id + ']; data layer with that id already exists in the panel');\n                    }\n                    if (typeof layout.type !== 'string') {\n                        throw new Error('Invalid data layer type in layout passed to LocusZoom.Panel.prototype.addDataLayer()');\n                    }\n                    // If the layout defines a y axis make sure the axis number is set and is 1 or 2 (default to 1)\n                    if (typeof layout.y_axis == 'object' && (typeof layout.y_axis.axis == 'undefined' || [\n                            1,\n                            2\n                        ].indexOf(layout.y_axis.axis) === -1)) {\n                        layout.y_axis.axis = 1;\n                    }\n                    // Create the Data Layer\n                    var data_layer = LocusZoom.DataLayers.get(layout.type, layout, this);\n                    // Store the Data Layer on the Panel\n                    this.data_layers[data_layer.id] = data_layer;\n                    // If a discrete z_index was set in the layout then adjust other data layer z_index values to accommodate this one\n                    if (data_layer.layout.z_index !== null && !isNaN(data_layer.layout.z_index) && this.data_layer_ids_by_z_index.length > 0) {\n                        // Negative z_index values should count backwards from the end, so convert negatives to appropriate values here\n                        if (data_layer.layout.z_index < 0) {\n                            data_layer.layout.z_index = Math.max(this.data_layer_ids_by_z_index.length + data_layer.layout.z_index, 0);\n                        }\n                        this.data_layer_ids_by_z_index.splice(data_layer.layout.z_index, 0, data_layer.id);\n                        this.data_layer_ids_by_z_index.forEach(function (dlid, idx) {\n                            this.data_layers[dlid].layout.z_index = idx;\n                        }.bind(this));\n                    } else {\n                        var length = this.data_layer_ids_by_z_index.push(data_layer.id);\n                        this.data_layers[data_layer.id].layout.z_index = length - 1;\n                    }\n                    // Determine if this data layer was already in the layout.data_layers array.\n                    // If it wasn't, add it. Either way store the layout.data_layers array index on the data_layer.\n                    var layout_idx = null;\n                    this.layout.data_layers.forEach(function (data_layer_layout, idx) {\n                        if (data_layer_layout.id === data_layer.id) {\n                            layout_idx = idx;\n                        }\n                    });\n                    if (layout_idx === null) {\n                        layout_idx = this.layout.data_layers.push(this.data_layers[data_layer.id].layout) - 1;\n                    }\n                    this.data_layers[data_layer.id].layout_idx = layout_idx;\n                    return this.data_layers[data_layer.id];\n                };\n                /**\n * Remove a data layer by id\n * @param {string} id\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Panel.prototype.removeDataLayer = function (id) {\n                    if (!this.data_layers[id]) {\n                        throw new Error('Unable to remove data layer, ID not found: ' + id);\n                    }\n                    // Destroy all tooltips for the data layer\n                    this.data_layers[id].destroyAllTooltips();\n                    // Remove the svg container for the data layer if it exists\n                    if (this.data_layers[id].svg.container) {\n                        this.data_layers[id].svg.container.remove();\n                    }\n                    // Delete the data layer and its presence in the panel layout and state\n                    this.layout.data_layers.splice(this.data_layers[id].layout_idx, 1);\n                    delete this.state[this.data_layers[id].state_id];\n                    delete this.data_layers[id];\n                    // Remove the data_layer id from the z_index array\n                    this.data_layer_ids_by_z_index.splice(this.data_layer_ids_by_z_index.indexOf(id), 1);\n                    // Update layout_idx and layout.z_index values for all remaining data_layers\n                    this.applyDataLayerZIndexesToDataLayerLayouts();\n                    this.layout.data_layers.forEach(function (data_layer_layout, idx) {\n                        this.data_layers[data_layer_layout.id].layout_idx = idx;\n                    }.bind(this));\n                    return this;\n                };\n                /**\n * Clear all selections on all data layers\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Panel.prototype.clearSelections = function () {\n                    this.data_layer_ids_by_z_index.forEach(function (id) {\n                        this.data_layers[id].setAllElementStatus('selected', false);\n                    }.bind(this));\n                    return this;\n                };\n                /**\n * When the parent plot changes state, adjust the panel accordingly. For example, this may include fetching new data\n *   from the API as the viewing region changes\n * @returns {Promise}\n */\n                LocusZoom.Panel.prototype.reMap = function () {\n                    this.emit('data_requested');\n                    this.data_promises = [];\n                    // Remove any previous error messages before attempting to load new data\n                    this.curtain.hide();\n                    // Trigger reMap on each Data Layer\n                    for (var id in this.data_layers) {\n                        try {\n                            this.data_promises.push(this.data_layers[id].reMap());\n                        } catch (error) {\n                            console.error(error);\n                            this.curtain.show(error.message || error);\n                        }\n                    }\n                    // When all finished trigger a render\n                    return Promise.all(this.data_promises).then(function () {\n                        this.initialized = true;\n                        this.render();\n                        this.emit('layout_changed', true);\n                        this.emit('data_rendered');\n                    }.bind(this)).catch(function (error) {\n                        console.error(error);\n                        this.curtain.show(error.message || error);\n                    }.bind(this));\n                };\n                /**\n * Iterate over data layers to generate panel axis extents\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Panel.prototype.generateExtents = function () {\n                    // Reset extents\n                    [\n                        'x',\n                        'y1',\n                        'y2'\n                    ].forEach(function (axis) {\n                        this[axis + '_extent'] = null;\n                    }.bind(this));\n                    // Loop through the data layers\n                    for (var id in this.data_layers) {\n                        var data_layer = this.data_layers[id];\n                        // If defined and not decoupled, merge the x extent of the data layer with the panel's x extent\n                        if (data_layer.layout.x_axis && !data_layer.layout.x_axis.decoupled) {\n                            this.x_extent = d3.extent((this.x_extent || []).concat(data_layer.getAxisExtent('x')));\n                        }\n                        // If defined and not decoupled, merge the y extent of the data layer with the panel's appropriate y extent\n                        if (data_layer.layout.y_axis && !data_layer.layout.y_axis.decoupled) {\n                            var y_axis = 'y' + data_layer.layout.y_axis.axis;\n                            this[y_axis + '_extent'] = d3.extent((this[y_axis + '_extent'] || []).concat(data_layer.getAxisExtent('y')));\n                        }\n                    }\n                    // Override x_extent from state if explicitly defined to do so\n                    if (this.layout.axes.x && this.layout.axes.x.extent === 'state') {\n                        this.x_extent = [\n                            this.state.start,\n                            this.state.end\n                        ];\n                    }\n                    return this;\n                };\n                /**\n * Generate an array of ticks for an axis. These ticks are generated in one of three ways (highest wins):\n *   1. An array of specific tick marks\n *   2. Query each data layer for what ticks are appropriate, and allow a panel-level tick configuration parameter\n *     object to override the layer's default presentation settings\n *   3. Generate generic tick marks based on the extent of the data\n * @param {('x'|'y1'|'y2')} axis The string identifier of the axis\n * @returns {Number[]|Object[]}  TODO: number format?\n *   An array of numbers: interpreted as an array of axis value offsets for positioning.\n *   An array of objects: each object must have an 'x' attribute to position the tick.\n *   Other supported object keys:\n *     * text: string to render for a given tick\n *     * style: d3-compatible CSS style object\n *     * transform: SVG transform attribute string\n *     * color: string or LocusZoom scalable parameter object\n */\n                LocusZoom.Panel.prototype.generateTicks = function (axis) {\n                    // Parse an explicit 'ticks' attribute in the axis layout\n                    if (this.layout.axes[axis].ticks) {\n                        var layout = this.layout.axes[axis];\n                        var baseTickConfig = layout.ticks;\n                        if (Array.isArray(baseTickConfig)) {\n                            // Array of specific ticks hard-coded into a panel will override any ticks that an individual layer might specify\n                            return baseTickConfig;\n                        }\n                        if (typeof baseTickConfig === 'object') {\n                            // If the layout specifies base configuration for ticks- but without specific positions- then ask each\n                            //   data layer to report the tick marks that it thinks it needs\n                            // TODO: Few layers currently need to specify custom ticks (which is ok!). But if it becomes common, consider adding mechanisms to deduplicate ticks across layers\n                            var self = this;\n                            // Pass any layer-specific customizations for how ticks are calculated. (styles are overridden separately)\n                            var config = { position: baseTickConfig.position };\n                            var combinedTicks = this.data_layer_ids_by_z_index.reduce(function (acc, data_layer_id) {\n                                var nextLayer = self.data_layers[data_layer_id];\n                                return acc.concat(nextLayer.getTicks(axis, config));\n                            }, []);\n                            return combinedTicks.map(function (item) {\n                                // The layer makes suggestions, but tick configuration params specified on the panel take precedence\n                                var itemConfig = {};\n                                itemConfig = LocusZoom.Layouts.merge(itemConfig, baseTickConfig);\n                                return LocusZoom.Layouts.merge(itemConfig, item);\n                            });\n                        }\n                    }\n                    // If no other configuration is provided, attempt to generate ticks from the extent\n                    if (this[axis + '_extent']) {\n                        return LocusZoom.prettyTicks(this[axis + '_extent'], 'both');\n                    }\n                    return [];\n                };\n                /**\n * Update rendering of this panel whenever an event triggers a redraw. Assumes that the panel has already been\n *   prepared the first time via `initialize`\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Panel.prototype.render = function () {\n                    // Position the panel container\n                    this.svg.container.attr('transform', 'translate(' + this.layout.origin.x + ',' + this.layout.origin.y + ')');\n                    // Set size on the clip rect\n                    this.svg.clipRect.attr('width', this.layout.width).attr('height', this.layout.height);\n                    // Set and position the inner border, style if necessary\n                    this.inner_border.attr('x', this.layout.margin.left).attr('y', this.layout.margin.top).attr('width', this.layout.width - (this.layout.margin.left + this.layout.margin.right)).attr('height', this.layout.height - (this.layout.margin.top + this.layout.margin.bottom));\n                    if (this.layout.inner_border) {\n                        this.inner_border.style({\n                            'stroke-width': 1,\n                            'stroke': this.layout.inner_border\n                        });\n                    }\n                    // Set/update panel title if necessary\n                    this.setTitle();\n                    // Regenerate all extents\n                    this.generateExtents();\n                    // Helper function to constrain any procedurally generated vectors (e.g. ranges, extents)\n                    // Constraints applied here keep vectors from going to infinity or beyond a definable power of ten\n                    var constrain = function (value, limit_exponent) {\n                        var neg_min = Math.pow(-10, limit_exponent);\n                        var neg_max = Math.pow(-10, -limit_exponent);\n                        var pos_min = Math.pow(10, -limit_exponent);\n                        var pos_max = Math.pow(10, limit_exponent);\n                        if (value === Infinity) {\n                            value = pos_max;\n                        }\n                        if (value === -Infinity) {\n                            value = neg_min;\n                        }\n                        if (value === 0) {\n                            value = pos_min;\n                        }\n                        if (value > 0) {\n                            value = Math.max(Math.min(value, pos_max), pos_min);\n                        }\n                        if (value < 0) {\n                            value = Math.max(Math.min(value, neg_max), neg_min);\n                        }\n                        return value;\n                    };\n                    // Define default and shifted ranges for all axes\n                    var ranges = {};\n                    if (this.x_extent) {\n                        var base_x_range = {\n                            start: 0,\n                            end: this.layout.cliparea.width\n                        };\n                        if (this.layout.axes.x.range) {\n                            base_x_range.start = this.layout.axes.x.range.start || base_x_range.start;\n                            base_x_range.end = this.layout.axes.x.range.end || base_x_range.end;\n                        }\n                        ranges.x = [\n                            base_x_range.start,\n                            base_x_range.end\n                        ];\n                        ranges.x_shifted = [\n                            base_x_range.start,\n                            base_x_range.end\n                        ];\n                    }\n                    if (this.y1_extent) {\n                        var base_y1_range = {\n                            start: this.layout.cliparea.height,\n                            end: 0\n                        };\n                        if (this.layout.axes.y1.range) {\n                            base_y1_range.start = this.layout.axes.y1.range.start || base_y1_range.start;\n                            base_y1_range.end = this.layout.axes.y1.range.end || base_y1_range.end;\n                        }\n                        ranges.y1 = [\n                            base_y1_range.start,\n                            base_y1_range.end\n                        ];\n                        ranges.y1_shifted = [\n                            base_y1_range.start,\n                            base_y1_range.end\n                        ];\n                    }\n                    if (this.y2_extent) {\n                        var base_y2_range = {\n                            start: this.layout.cliparea.height,\n                            end: 0\n                        };\n                        if (this.layout.axes.y2.range) {\n                            base_y2_range.start = this.layout.axes.y2.range.start || base_y2_range.start;\n                            base_y2_range.end = this.layout.axes.y2.range.end || base_y2_range.end;\n                        }\n                        ranges.y2 = [\n                            base_y2_range.start,\n                            base_y2_range.end\n                        ];\n                        ranges.y2_shifted = [\n                            base_y2_range.start,\n                            base_y2_range.end\n                        ];\n                    }\n                    // Shift ranges based on any drag or zoom interactions currently underway\n                    if (this.parent.interaction.panel_id && (this.parent.interaction.panel_id === this.id || this.parent.interaction.linked_panel_ids.indexOf(this.id) !== -1)) {\n                        var anchor, scalar = null;\n                        if (this.parent.interaction.zooming && typeof this.x_scale == 'function') {\n                            var current_extent_size = Math.abs(this.x_extent[1] - this.x_extent[0]);\n                            var current_scaled_extent_size = Math.round(this.x_scale.invert(ranges.x_shifted[1])) - Math.round(this.x_scale.invert(ranges.x_shifted[0]));\n                            var zoom_factor = this.parent.interaction.zooming.scale;\n                            var potential_extent_size = Math.floor(current_scaled_extent_size * (1 / zoom_factor));\n                            if (zoom_factor < 1 && !isNaN(this.parent.layout.max_region_scale)) {\n                                zoom_factor = 1 / (Math.min(potential_extent_size, this.parent.layout.max_region_scale) / current_scaled_extent_size);\n                            } else if (zoom_factor > 1 && !isNaN(this.parent.layout.min_region_scale)) {\n                                zoom_factor = 1 / (Math.max(potential_extent_size, this.parent.layout.min_region_scale) / current_scaled_extent_size);\n                            }\n                            var new_extent_size = Math.floor(current_extent_size * zoom_factor);\n                            anchor = this.parent.interaction.zooming.center - this.layout.margin.left - this.layout.origin.x;\n                            var offset_ratio = anchor / this.layout.cliparea.width;\n                            var new_x_extent_start = Math.max(Math.floor(this.x_scale.invert(ranges.x_shifted[0]) - (new_extent_size - current_scaled_extent_size) * offset_ratio), 1);\n                            ranges.x_shifted = [\n                                this.x_scale(new_x_extent_start),\n                                this.x_scale(new_x_extent_start + new_extent_size)\n                            ];\n                        } else if (this.parent.interaction.dragging) {\n                            switch (this.parent.interaction.dragging.method) {\n                            case 'background':\n                                ranges.x_shifted[0] = +this.parent.interaction.dragging.dragged_x;\n                                ranges.x_shifted[1] = this.layout.cliparea.width + this.parent.interaction.dragging.dragged_x;\n                                break;\n                            case 'x_tick':\n                                if (d3.event && d3.event.shiftKey) {\n                                    ranges.x_shifted[0] = +this.parent.interaction.dragging.dragged_x;\n                                    ranges.x_shifted[1] = this.layout.cliparea.width + this.parent.interaction.dragging.dragged_x;\n                                } else {\n                                    anchor = this.parent.interaction.dragging.start_x - this.layout.margin.left - this.layout.origin.x;\n                                    scalar = constrain(anchor / (anchor + this.parent.interaction.dragging.dragged_x), 3);\n                                    ranges.x_shifted[0] = 0;\n                                    ranges.x_shifted[1] = Math.max(this.layout.cliparea.width * (1 / scalar), 1);\n                                }\n                                break;\n                            case 'y1_tick':\n                            case 'y2_tick':\n                                var y_shifted = 'y' + this.parent.interaction.dragging.method[1] + '_shifted';\n                                if (d3.event && d3.event.shiftKey) {\n                                    ranges[y_shifted][0] = this.layout.cliparea.height + this.parent.interaction.dragging.dragged_y;\n                                    ranges[y_shifted][1] = +this.parent.interaction.dragging.dragged_y;\n                                } else {\n                                    anchor = this.layout.cliparea.height - (this.parent.interaction.dragging.start_y - this.layout.margin.top - this.layout.origin.y);\n                                    scalar = constrain(anchor / (anchor - this.parent.interaction.dragging.dragged_y), 3);\n                                    ranges[y_shifted][0] = this.layout.cliparea.height;\n                                    ranges[y_shifted][1] = this.layout.cliparea.height - this.layout.cliparea.height * (1 / scalar);\n                                }\n                            }\n                        }\n                    }\n                    // Generate scales and ticks for all axes, then render them\n                    [\n                        'x',\n                        'y1',\n                        'y2'\n                    ].forEach(function (axis) {\n                        if (!this[axis + '_extent']) {\n                            return;\n                        }\n                        // Base Scale\n                        this[axis + '_scale'] = d3.scale.linear().domain(this[axis + '_extent']).range(ranges[axis + '_shifted']);\n                        // Shift the extent\n                        this[axis + '_extent'] = [\n                            this[axis + '_scale'].invert(ranges[axis][0]),\n                            this[axis + '_scale'].invert(ranges[axis][1])\n                        ];\n                        // Finalize Scale\n                        this[axis + '_scale'] = d3.scale.linear().domain(this[axis + '_extent']).range(ranges[axis]);\n                        // Render axis (and generate ticks as needed)\n                        this.renderAxis(axis);\n                    }.bind(this));\n                    // Establish mousewheel zoom event handers on the panel (namespacing not passed through by d3, so not used here)\n                    if (this.layout.interaction.scroll_to_zoom) {\n                        var zoom_handler = function () {\n                            // Look for a shift key press while scrolling to execute.\n                            // If not present, gracefully raise a notification and allow conventional scrolling\n                            if (!d3.event.shiftKey) {\n                                if (this.parent.canInteract(this.id)) {\n                                    this.loader.show('Press <tt>[SHIFT]</tt> while scrolling to zoom').hide(1000);\n                                }\n                                return;\n                            }\n                            d3.event.preventDefault();\n                            if (!this.parent.canInteract(this.id)) {\n                                return;\n                            }\n                            var coords = d3.mouse(this.svg.container.node());\n                            var delta = Math.max(-1, Math.min(1, d3.event.wheelDelta || -d3.event.detail || -d3.event.deltaY));\n                            if (delta === 0) {\n                                return;\n                            }\n                            this.parent.interaction = {\n                                panel_id: this.id,\n                                linked_panel_ids: this.getLinkedPanelIds('x'),\n                                zooming: {\n                                    scale: delta < 1 ? 0.9 : 1.1,\n                                    center: coords[0]\n                                }\n                            };\n                            this.render();\n                            this.parent.interaction.linked_panel_ids.forEach(function (panel_id) {\n                                this.parent.panels[panel_id].render();\n                            }.bind(this));\n                            if (this.zoom_timeout !== null) {\n                                clearTimeout(this.zoom_timeout);\n                            }\n                            this.zoom_timeout = setTimeout(function () {\n                                this.parent.interaction = {};\n                                this.parent.applyState({\n                                    start: this.x_extent[0],\n                                    end: this.x_extent[1]\n                                });\n                            }.bind(this), 500);\n                        }.bind(this);\n                        this.zoom_listener = d3.behavior.zoom();\n                        this.svg.container.call(this.zoom_listener).on('wheel.zoom', zoom_handler).on('mousewheel.zoom', zoom_handler).on('DOMMouseScroll.zoom', zoom_handler);\n                    }\n                    // Render data layers in order by z-index\n                    this.data_layer_ids_by_z_index.forEach(function (data_layer_id) {\n                        this.data_layers[data_layer_id].draw().render();\n                    }.bind(this));\n                    return this;\n                };\n                /**\n * Render ticks for a particular axis\n * @param {('x'|'y1'|'y2')} axis The identifier of the axes\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Panel.prototype.renderAxis = function (axis) {\n                    if ([\n                            'x',\n                            'y1',\n                            'y2'\n                        ].indexOf(axis) === -1) {\n                        throw new Error('Unable to render axis; invalid axis identifier: ' + axis);\n                    }\n                    var canRender = this.layout.axes[axis].render && typeof this[axis + '_scale'] == 'function' && !isNaN(this[axis + '_scale'](0));\n                    // If the axis has already been rendered then check if we can/can't render it\n                    // Make sure the axis element is shown/hidden to suit\n                    if (this[axis + '_axis']) {\n                        this.svg.container.select('g.lz-axis.lz-' + axis).style('display', canRender ? null : 'none');\n                    }\n                    if (!canRender) {\n                        return this;\n                    }\n                    // Axis-specific values to plug in where needed\n                    var axis_params = {\n                        x: {\n                            position: 'translate(' + this.layout.margin.left + ',' + (this.layout.height - this.layout.margin.bottom) + ')',\n                            orientation: 'bottom',\n                            label_x: this.layout.cliparea.width / 2,\n                            label_y: this.layout.axes[axis].label_offset || 0,\n                            label_rotate: null\n                        },\n                        y1: {\n                            position: 'translate(' + this.layout.margin.left + ',' + this.layout.margin.top + ')',\n                            orientation: 'left',\n                            label_x: -1 * (this.layout.axes[axis].label_offset || 0),\n                            label_y: this.layout.cliparea.height / 2,\n                            label_rotate: -90\n                        },\n                        y2: {\n                            position: 'translate(' + (this.layout.width - this.layout.margin.right) + ',' + this.layout.margin.top + ')',\n                            orientation: 'right',\n                            label_x: this.layout.axes[axis].label_offset || 0,\n                            label_y: this.layout.cliparea.height / 2,\n                            label_rotate: -90\n                        }\n                    };\n                    // Generate Ticks\n                    this[axis + '_ticks'] = this.generateTicks(axis);\n                    // Determine if the ticks are all numbers (d3-automated tick rendering) or not (manual tick rendering)\n                    var ticksAreAllNumbers = function (ticks) {\n                        for (var i = 0; i < ticks.length; i++) {\n                            if (isNaN(ticks[i])) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }(this[axis + '_ticks']);\n                    // Initialize the axis; set scale and orientation\n                    this[axis + '_axis'] = d3.svg.axis().scale(this[axis + '_scale']).orient(axis_params[axis].orientation).tickPadding(3);\n                    // Set tick values and format\n                    if (ticksAreAllNumbers) {\n                        this[axis + '_axis'].tickValues(this[axis + '_ticks']);\n                        if (this.layout.axes[axis].tick_format === 'region') {\n                            this[axis + '_axis'].tickFormat(function (d) {\n                                return LocusZoom.positionIntToString(d, 6);\n                            });\n                        }\n                    } else {\n                        var ticks = this[axis + '_ticks'].map(function (t) {\n                            return t[axis.substr(0, 1)];\n                        });\n                        this[axis + '_axis'].tickValues(ticks).tickFormat(function (t, i) {\n                            return this[axis + '_ticks'][i].text;\n                        }.bind(this));\n                    }\n                    // Position the axis in the SVG and apply the axis construct\n                    this.svg[axis + '_axis'].attr('transform', axis_params[axis].position).call(this[axis + '_axis']);\n                    // If necessary manually apply styles and transforms to ticks as specified by the layout\n                    if (!ticksAreAllNumbers) {\n                        var tick_selector = d3.selectAll('g#' + this.getBaseId().replace('.', '\\\\.') + '\\\\.' + axis + '_axis g.tick');\n                        var panel = this;\n                        tick_selector.each(function (d, i) {\n                            var selector = d3.select(this).select('text');\n                            if (panel[axis + '_ticks'][i].style) {\n                                selector.style(panel[axis + '_ticks'][i].style);\n                            }\n                            if (panel[axis + '_ticks'][i].transform) {\n                                selector.attr('transform', panel[axis + '_ticks'][i].transform);\n                            }\n                        });\n                    }\n                    // Render the axis label if necessary\n                    var label = this.layout.axes[axis].label || null;\n                    if (label !== null) {\n                        this.svg[axis + '_axis_label'].attr('x', axis_params[axis].label_x).attr('y', axis_params[axis].label_y).text(LocusZoom.parseFields(this.state, label));\n                        if (axis_params[axis].label_rotate !== null) {\n                            this.svg[axis + '_axis_label'].attr('transform', 'rotate(' + axis_params[axis].label_rotate + ' ' + axis_params[axis].label_x + ',' + axis_params[axis].label_y + ')');\n                        }\n                    }\n                    // Attach interactive handlers to ticks as needed\n                    [\n                        'x',\n                        'y1',\n                        'y2'\n                    ].forEach(function (axis) {\n                        if (this.layout.interaction['drag_' + axis + '_ticks_to_scale']) {\n                            var namespace = '.' + this.parent.id + '.' + this.id + '.interaction.drag';\n                            var tick_mouseover = function () {\n                                if (typeof d3.select(this).node().focus == 'function') {\n                                    d3.select(this).node().focus();\n                                }\n                                var cursor = axis === 'x' ? 'ew-resize' : 'ns-resize';\n                                if (d3.event && d3.event.shiftKey) {\n                                    cursor = 'move';\n                                }\n                                d3.select(this).style({\n                                    'font-weight': 'bold',\n                                    'cursor': cursor\n                                }).on('keydown' + namespace, tick_mouseover).on('keyup' + namespace, tick_mouseover);\n                            };\n                            this.svg.container.selectAll('.lz-axis.lz-' + axis + ' .tick text').attr('tabindex', 0)    // necessary to make the tick focusable so keypress events can be captured\n.on('mouseover' + namespace, tick_mouseover).on('mouseout' + namespace, function () {\n                                d3.select(this).style({ 'font-weight': 'normal' });\n                                d3.select(this).on('keydown' + namespace, null).on('keyup' + namespace, null);\n                            }).on('mousedown' + namespace, function () {\n                                this.parent.startDrag(this, axis + '_tick');\n                            }.bind(this));\n                        }\n                    }.bind(this));\n                    return this;\n                };\n                /**\n * Force the height of this panel to the largest absolute height of the data in\n *   all child data layers (if not null for any child data layers)\n * @param {number} [target_height] A target height, which will be used in situations when the expected height can be\n *   pre-calculated (eg when the layers are transitioning)\n */\n                LocusZoom.Panel.prototype.scaleHeightToData = function (target_height) {\n                    target_height = +target_height || null;\n                    if (target_height === null) {\n                        this.data_layer_ids_by_z_index.forEach(function (id) {\n                            var dh = this.data_layers[id].getAbsoluteDataHeight();\n                            if (+dh) {\n                                if (target_height === null) {\n                                    target_height = +dh;\n                                } else {\n                                    target_height = Math.max(target_height, +dh);\n                                }\n                            }\n                        }.bind(this));\n                    }\n                    if (+target_height) {\n                        target_height += +this.layout.margin.top + +this.layout.margin.bottom;\n                        this.setDimensions(this.layout.width, target_height);\n                        this.parent.setDimensions();\n                        this.parent.panel_ids_by_y_index.forEach(function (id) {\n                            this.parent.panels[id].layout.proportional_height = null;\n                        }.bind(this));\n                        this.parent.positionPanels();\n                    }\n                };\n                /**\n * Methods to set/unset element statuses across all data layers\n * @param {String} status\n * @param {Boolean} toggle\n * @param {Array} filters\n * @param {Boolean} exclusive\n */\n                LocusZoom.Panel.prototype.setElementStatusByFilters = function (status, toggle, filters, exclusive) {\n                    this.data_layer_ids_by_z_index.forEach(function (id) {\n                        this.data_layers[id].setElementStatusByFilters(status, toggle, filters, exclusive);\n                    }.bind(this));\n                };\n                /**\n * Set/unset element statuses across all data layers\n * @param {String} status\n * @param {Boolean} toggle\n */\n                LocusZoom.Panel.prototype.setAllElementStatus = function (status, toggle) {\n                    this.data_layer_ids_by_z_index.forEach(function (id) {\n                        this.data_layers[id].setAllElementStatus(status, toggle);\n                    }.bind(this));\n                };\n                // TODO: Capture documentation for dynamically generated methods\n                LocusZoom.DataLayer.Statuses.verbs.forEach(function (verb, idx) {\n                    var adjective = LocusZoom.DataLayer.Statuses.adjectives[idx];\n                    var antiverb = 'un' + verb;\n                    // Set/unset status for arbitrarily many elements given a set of filters\n                    LocusZoom.Panel.prototype[verb + 'ElementsByFilters'] = function (filters, exclusive) {\n                        if (typeof exclusive == 'undefined') {\n                            exclusive = false;\n                        } else {\n                            exclusive = !!exclusive;\n                        }\n                        return this.setElementStatusByFilters(adjective, true, filters, exclusive);\n                    };\n                    LocusZoom.Panel.prototype[antiverb + 'ElementsByFilters'] = function (filters, exclusive) {\n                        if (typeof exclusive == 'undefined') {\n                            exclusive = false;\n                        } else {\n                            exclusive = !!exclusive;\n                        }\n                        return this.setElementStatusByFilters(adjective, false, filters, exclusive);\n                    };\n                    // Set/unset status for all elements\n                    LocusZoom.Panel.prototype[verb + 'AllElements'] = function () {\n                        this.setAllElementStatus(adjective, true);\n                        return this;\n                    };\n                    LocusZoom.Panel.prototype[antiverb + 'AllElements'] = function () {\n                        this.setAllElementStatus(adjective, false);\n                        return this;\n                    };\n                });\n                /**\n * Add a \"basic\" loader to a panel\n * This method is just a shortcut for adding the most commonly used type of loading indicator, which appears when\n *   data is requested, animates (e.g. shows an infinitely cycling progress bar as opposed to one that loads from\n *   0-100% based on actual load progress), and disappears when new data is loaded and rendered.\n *\n *\n * @param {Boolean} show_immediately\n * @returns {LocusZoom.Panel}\n */\n                LocusZoom.Panel.prototype.addBasicLoader = function (show_immediately) {\n                    if (typeof show_immediately != 'undefined') {\n                        show_immediately = true;\n                    }\n                    if (show_immediately) {\n                        this.loader.show('Loading...').animate();\n                    }\n                    this.on('data_requested', function () {\n                        this.loader.show('Loading...').animate();\n                    }.bind(this));\n                    this.on('data_rendered', function () {\n                        this.loader.hide();\n                    }.bind(this));\n                    return this;\n                };\n            } catch (plugin_loading_error) {\n                console.error('LocusZoom Plugin error: ', plugin_loading_error);\n            }\n            return LocusZoom;\n        }));    //# sourceMappingURL=locuszoom.app.js.map\n    } catch (plugin_loading_error) {\n        console.error('LocusZoom Plugin error: ', plugin_loading_error);\n    }\n    return LocusZoom;\n}));","/* global LocusZoom */\n'use strict';\n\n/**\n * A Dashboard is an HTML element used for presenting arbitrary user interface components. Dashboards are anchored\n *   to either the entire Plot or to individual Panels.\n *\n * Each dashboard is an HTML-based (read: not SVG) collection of components used to display information or provide\n *   user interface. Dashboards can exist on entire plots, where their visibility is permanent and vertically adjacent\n *   to the plot, or on individual panels, where their visibility is tied to a behavior (e.g. a mouseover) and is as\n *   an overlay.\n * @class\n */\nLocusZoom.Dashboard = function(parent) {\n    // parent must be a locuszoom plot or panel\n    if (!(parent instanceof LocusZoom.Plot) && !(parent instanceof LocusZoom.Panel)) {\n        throw new Error('Unable to create dashboard, parent must be a locuszoom plot or panel');\n    }\n    /** @member {LocusZoom.Plot|LocusZoom.Panel} */\n    this.parent = parent;\n    /** @member {String} */\n    this.id = this.parent.getBaseId() + '.dashboard';\n    /** @member {('plot'|'panel')} */\n    this.type = (this.parent instanceof LocusZoom.Plot) ? 'plot' : 'panel';\n    /** @member {LocusZoom.Plot} */\n    this.parent_plot = this.type === 'plot' ? this.parent : this.parent.parent;\n\n    /** @member {d3.selection} */\n    this.selector = null;\n    /** @member {LocusZoom.Dashboard.Component[]} */\n    this.components = [];\n    /**\n     * The timer identifier as returned by setTimeout\n     * @member {Number}\n     */\n    this.hide_timeout = null;\n    /**\n     * Whether to hide the dashboard. Can be overridden by a child component. Check via `shouldPersist`\n     * @protected\n     * @member {Boolean}\n     */\n    this.persist = false;\n\n    // TODO: Return value from constructor function?\n    return this.initialize();\n};\n\n/**\n * Prepare the dashboard for first use: generate all component instances for this dashboard, based on the provided\n *   layout of the parent. Connects event listeners and shows/hides as appropriate.\n * @returns {LocusZoom.Dashboard}\n */\nLocusZoom.Dashboard.prototype.initialize = function() {\n    // Parse layout to generate component instances\n    if (Array.isArray(this.parent.layout.dashboard.components)) {\n        this.parent.layout.dashboard.components.forEach(function(layout) {\n            try {\n                var component = LocusZoom.Dashboard.Components.get(layout.type, layout, this);\n                this.components.push(component);\n            } catch (e) {\n                console.warn(e);\n            }\n        }.bind(this));\n    }\n\n    // Add mouseover event handlers to show/hide panel dashboard\n    if (this.type === 'panel') {\n        d3.select(this.parent.parent.svg.node().parentNode).on('mouseover.' + this.id, function() {\n            clearTimeout(this.hide_timeout);\n            if (!this.selector || this.selector.style('visibility') === 'hidden') { this.show(); }\n        }.bind(this));\n        d3.select(this.parent.parent.svg.node().parentNode).on('mouseout.' + this.id, function() {\n            clearTimeout(this.hide_timeout);\n            this.hide_timeout = setTimeout(function() { this.hide(); }.bind(this), 300);\n        }.bind(this));\n    }\n\n    return this;\n\n};\n\n/**\n * Whether to persist the dashboard. Returns true if at least one component should persist, or if the panel is engaged\n *   in an active drag event.\n * @returns {boolean}\n */\nLocusZoom.Dashboard.prototype.shouldPersist = function() {\n    if (this.persist) { return true; }\n    var persist = false;\n    // Persist if at least one component should also persist\n    this.components.forEach(function(component) {\n        persist = persist || component.shouldPersist();\n    });\n    // Persist if in a parent drag event\n    persist = persist || (this.parent_plot.panel_boundaries.dragging || this.parent_plot.interaction.dragging);\n    return !!persist;\n};\n\n/**\n * Make the dashboard appear. If it doesn't exist yet create it, including creating/positioning all components within,\n *   and make sure it is set to be visible.\n */\nLocusZoom.Dashboard.prototype.show = function() {\n    if (!this.selector) {\n        switch (this.type) {\n        case 'plot':\n            this.selector = d3.select(this.parent.svg.node().parentNode)\n                .insert('div',':first-child');\n            break;\n        case 'panel':\n            this.selector = d3.select(this.parent.parent.svg.node().parentNode)\n                .insert('div', '.lz-data_layer-tooltip, .lz-dashboard-menu, .lz-curtain').classed('lz-panel-dashboard', true);\n            break;\n        }\n        this.selector.classed('lz-dashboard', true).classed('lz-' + this.type + '-dashboard', true).attr('id', this.id);\n    }\n    this.components.forEach(function(component) { component.show(); });\n    this.selector.style({ visibility: 'visible' });\n    return this.update();\n};\n\n/**\n * Update the dashboard and rerender all child components. This can be called whenever plot state changes.\n * @returns {LocusZoom.Dashboard}\n */\nLocusZoom.Dashboard.prototype.update = function() {\n    if (!this.selector) { return this; }\n    this.components.forEach(function(component) { component.update(); });\n    return this.position();\n};\n\n/**\n * Position the dashboard (and child components) within the panel\n * @returns {LocusZoom.Dashboard}\n */\nLocusZoom.Dashboard.prototype.position = function() {\n    if (!this.selector) { return this; }\n    // Position the dashboard itself (panel only)\n    if (this.type === 'panel') {\n        var page_origin = this.parent.getPageOrigin();\n        var top = (page_origin.y + 3.5).toString() + 'px';\n        var left = page_origin.x.toString() + 'px';\n        var width = (this.parent.layout.width - 4).toString() + 'px';\n        this.selector.style({ position: 'absolute', top: top, left: left, width: width });\n    }\n    // Recursively position components\n    this.components.forEach(function(component) { component.position(); });\n    return this;\n};\n\n/**\n * Hide the dashboard (make invisible but do not destroy). Will do nothing if `shouldPersist` returns true.\n *\n * @returns {LocusZoom.Dashboard}\n */\nLocusZoom.Dashboard.prototype.hide = function() {\n    if (!this.selector || this.shouldPersist()) { return this; }\n    this.components.forEach(function(component) { component.hide(); });\n    this.selector.style({ visibility: 'hidden' });\n    return this;\n};\n\n/**\n * Completely remove dashboard and all child components. (may be overridden by persistence settings)\n * @param {Boolean} [force=false] If true, will ignore persistence settings and always destroy the dashboard\n * @returns {LocusZoom.Dashboard}\n */\nLocusZoom.Dashboard.prototype.destroy = function(force) {\n    if (typeof force == 'undefined') { force = false; }\n    if (!this.selector) { return this; }\n    if (this.shouldPersist() && !force) { return this; }\n    this.components.forEach(function(component) { component.destroy(true); });\n    this.components = [];\n    this.selector.remove();\n    this.selector = null;\n    return this;\n};\n\n/**\n *\n * A dashboard component is an empty div rendered on a dashboard that can display custom\n * html of user interface elements. LocusZoom.Dashboard.Components is a singleton used to\n * define and manage an extendable collection of dashboard components.\n * (e.g. by LocusZoom.Dashboard.Components.add())\n * @class\n * @param {Object} layout A JSON-serializable object of layout configuration parameters\n * @param {('left'|'right')} [layout.position='left']  Whether to float the component left or right.\n * @param {('start'|'middle'|'end')} [layout.group_position] Buttons can optionally be gathered into a visually\n *  distinctive group whose elements are closer together. If a button is identified as the start or end of a group,\n *  it will be drawn with rounded corners and an extra margin of spacing from any button not part of the group.\n *  For example, the region_nav_plot dashboard is a defined as a group.\n * @param {('gray'|'red'|'orange'|'yellow'|'green'|'blue'|'purple'} [layout.color='gray']  Color scheme for the\n *   component. Applies to buttons and menus.\n * @param {LocusZoom.Dashboard} parent The dashboard that contains this component\n*/\nLocusZoom.Dashboard.Component = function(layout, parent) {\n    /** @member {Object} */\n    this.layout = layout || {};\n    if (!this.layout.color) { this.layout.color = 'gray'; }\n\n    /** @member {LocusZoom.Dashboard|*} */\n    this.parent = parent || null;\n    /**\n     * Some dashboards are attached to a panel, rather than directly to a plot\n     * @member {LocusZoom.Panel|null}\n     */\n    this.parent_panel = null;\n    /** @member {LocusZoom.Plot} */\n    this.parent_plot = null;\n    /**\n     * This is a reference to either the panel or the plot, depending on what the dashboard is\n     *   tied to. Useful when absolutely positioning dashboard components relative to their SVG anchor.\n     * @member {LocusZoom.Plot|LocusZoom.Panel}\n     */\n    this.parent_svg = null;\n    if (this.parent instanceof LocusZoom.Dashboard) {\n        // TODO: when is the immediate parent *not* a dashboard?\n        if (this.parent.type === 'panel') {\n            this.parent_panel = this.parent.parent;\n            this.parent_plot = this.parent.parent.parent;\n            this.parent_svg = this.parent_panel;\n        } else {\n            this.parent_plot = this.parent.parent;\n            this.parent_svg = this.parent_plot;\n        }\n    }\n    /** @member {d3.selection} */\n    this.selector = null;\n    /**\n     * If this is an interactive component, it will contain a button or menu instance that handles the interactivity.\n     *   There is a 1-to-1 relationship of dashboard component to button\n     * @member {null|LocusZoom.Dashboard.Component.Button}\n     */\n    this.button  = null;\n    /**\n     * If any single component is marked persistent, it will bubble up to prevent automatic hide behavior on a\n     *   component's parent dashboard. Check via `shouldPersist`\n     * @protected\n     * @member {Boolean}\n     */\n    this.persist = false;\n    if (!this.layout.position) { this.layout.position = 'left'; }\n\n    // TODO: Return value in constructor\n    return this;\n};\n/**\n * Perform all rendering of component, including toggling visibility to true. Will initialize and create SVG element\n *   if necessary, as well as updating with new data and performing layout actions.\n */\nLocusZoom.Dashboard.Component.prototype.show = function() {\n    if (!this.parent || !this.parent.selector) { return; }\n    if (!this.selector) {\n        var group_position = (['start','middle','end'].indexOf(this.layout.group_position) !== -1 ? ' lz-dashboard-group-' + this.layout.group_position : '');\n        this.selector = this.parent.selector.append('div')\n            .attr('class', 'lz-dashboard-' + this.layout.position + group_position);\n        if (this.layout.style) { this.selector.style(this.layout.style); }\n        if (typeof this.initialize == 'function') { this.initialize(); }\n    }\n    if (this.button && this.button.status === 'highlighted') { this.button.menu.show(); }\n    this.selector.style({ visibility: 'visible' });\n    this.update();\n    return this.position();\n};\n/**\n * Update the dashboard component with any new data or plot state as appropriate. This method performs all\n *  necessary rendering steps.\n */\nLocusZoom.Dashboard.Component.prototype.update = function() { /* stub */ };\n/**\n * Place the component correctly in the plot\n * @returns {LocusZoom.Dashboard.Component}\n */\nLocusZoom.Dashboard.Component.prototype.position = function() {\n    if (this.button) { this.button.menu.position(); }\n    return this;\n};\n/**\n * Determine whether the component should persist (will bubble up to parent dashboard)\n * @returns {boolean}\n */\nLocusZoom.Dashboard.Component.prototype.shouldPersist = function() {\n    if (this.persist) { return true; }\n    if (this.button && this.button.persist) { return true; }\n    return false;\n};\n/**\n * Toggle visibility to hidden, unless marked as persistent\n * @returns {LocusZoom.Dashboard.Component}\n */\nLocusZoom.Dashboard.Component.prototype.hide = function() {\n    if (!this.selector || this.shouldPersist()) { return this; }\n    if (this.button) { this.button.menu.hide(); }\n    this.selector.style({ visibility: 'hidden' });\n    return this;\n};\n/**\n * Completely remove component and button. (may be overridden by persistence settings)\n * @param {Boolean} [force=false] If true, will ignore persistence settings and always destroy the dashboard\n * @returns {LocusZoom.Dashboard}\n */\nLocusZoom.Dashboard.Component.prototype.destroy = function(force) {\n    if (typeof force == 'undefined') { force = false; }\n    if (!this.selector) { return this; }\n    if (this.shouldPersist() && !force) { return this; }\n    if (this.button && this.button.menu) { this.button.menu.destroy(); }\n    this.selector.remove();\n    this.selector = null;\n    this.button = null;\n    return this;\n};\n\n/**\n * Singleton registry of all known components\n * @class\n * @static\n */\nLocusZoom.Dashboard.Components = (function() {\n    /** @lends LocusZoom.Dashboard.Components */\n    var obj = {};\n    var components = {};\n\n    /**\n     * Create a new component instance by name\n     * @param {String} name The string identifier of the desired component\n     * @param {Object} layout The layout to use to create the component\n     * @param {LocusZoom.Dashboard} parent The containing dashboard to use when creating the component\n     * @returns {LocusZoom.Dashboard.Component}\n     */\n    obj.get = function(name, layout, parent) {\n        if (!name) {\n            return null;\n        } else if (components[name]) {\n            if (typeof layout != 'object') {\n                throw new Error('invalid layout argument for dashboard component [' + name + ']');\n            } else {\n                return new components[name](layout, parent);\n            }\n        } else {\n            throw new Error('dashboard component [' + name + '] not found');\n        }\n    };\n    /**\n     * Add a new component constructor to the registry and ensure that it extends the correct parent class\n     * @protected\n     * @param name\n     * @param component\n     */\n    obj.set = function(name, component) {\n        if (component) {\n            if (typeof component != 'function') {\n                throw new Error('unable to set dashboard component [' + name + '], argument provided is not a function');\n            } else {\n                components[name] = component;\n                components[name].prototype = new LocusZoom.Dashboard.Component();\n            }\n        } else {\n            delete components[name];\n        }\n    };\n\n    /**\n     * Register a new component constructor by name\n     * @param {String} name\n     * @param {function} component The component constructor\n     */\n    obj.add = function(name, component) {\n        if (components[name]) {\n            throw new Error('dashboard component already exists with name: ' + name);\n        } else {\n            obj.set(name, component);\n        }\n    };\n\n    /**\n     * List the names of all registered components\n     * @returns {String[]}\n     */\n    obj.list = function() {\n        return Object.keys(components);\n    };\n\n    return obj;\n})();\n\n/**\n * Plots and panels may have a \"dashboard\" element suited for showing HTML components that may be interactive.\n *   When components need to incorporate a generic button, or additionally a button that generates a menu, this\n *   class provides much of the necessary framework.\n * @class\n * @param {LocusZoom.Dashboard.Component} parent\n */\nLocusZoom.Dashboard.Component.Button = function(parent) {\n\n    if (!(parent instanceof LocusZoom.Dashboard.Component)) {\n        throw new Error('Unable to create dashboard component button, invalid parent');\n    }\n    /** @member {LocusZoom.Dashboard.Component} */\n    this.parent = parent;\n    /** @member {LocusZoom.Dashboard.Panel} */\n    this.parent_panel = this.parent.parent_panel;\n    /** @member {LocusZoom.Dashboard.Plot} */\n    this.parent_plot = this.parent.parent_plot;\n    /** @member {LocusZoom.Plot|LocusZoom.Panel} */\n    this.parent_svg = this.parent.parent_svg;\n\n    /** @member {LocusZoom.Dashboard|null|*} */\n    this.parent_dashboard = this.parent.parent;\n    /** @member {d3.selection} */\n    this.selector = null;\n\n    /**\n     * Tag to use for the button (default: a)\n     * @member {String}\n     */\n    this.tag = 'a';\n\n    /**\n     * TODO This method does not appear to be used anywhere\n     * @param {String} tag\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n    this.setTag = function(tag) {\n        if (typeof tag != 'undefined') { this.tag = tag.toString(); }\n        return this;\n    };\n\n    /**\n     * HTML for the button to show.\n     * @protected\n     * @member {String}\n     */\n    this.html = '';\n    /**\n     * Specify the HTML content of this button.\n     * WARNING: The string provided will be inserted into the document as raw markup; XSS mitigation is the\n     *   responsibility of each button implementation.\n     * @param {String} html\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n    this.setHtml = function(html) {\n        if (typeof html != 'undefined') { this.html = html.toString(); }\n        return this;\n    };\n    /**\n     * @deprecated since 0.5.6; use setHtml instead\n     */\n    this.setText = this.setHtml;\n\n    /**\n     * Mouseover title text for the button to show\n     * @protected\n     * @member {String}\n     */\n    this.title = '';\n    /**\n     * Set the mouseover title text for the button (if any)\n     * @param {String} title Simple text to display\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n    this.setTitle = function(title) {\n        if (typeof title != 'undefined') { this.title = title.toString(); }\n        return this;\n    };\n\n    /**\n     * Color of the button\n     * @member {String}\n     */\n    this.color = 'gray';\n\n    /**\n     * Set the color associated with this button\n     * @param {('gray'|'red'|'orange'|'yellow'|'green'|'blue'|'purple')} color Any selection not in the preset list\n     *   will be replaced with gray.\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n    this.setColor = function(color) {\n        if (typeof color != 'undefined') {\n            if (['gray', 'red', 'orange', 'yellow', 'green', 'blue', 'purple'].indexOf(color) !== -1) { this.color = color; }\n            else { this.color = 'gray'; }\n        }\n        return this;\n    };\n\n    /**\n     * Hash of arbitrary button styles to apply as {name: value} entries\n     * @protected\n     * @member {Object}\n     */\n    this.style = {};\n    /**\n     * Set a collection of custom styles to be used by the button\n     * @param {Object} style Hash of {name:value} entries\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n    this.setStyle = function(style) {\n        if (typeof style != 'undefined') { this.style = style; }\n        return this;\n    };\n\n    //\n    /**\n     * Method to generate a CSS class string\n     * @returns {string}\n     */\n    this.getClass = function() {\n        var group_position = (['start','middle','end'].indexOf(this.parent.layout.group_position) !== -1 ? ' lz-dashboard-button-group-' + this.parent.layout.group_position : '');\n        return 'lz-dashboard-button lz-dashboard-button-' + this.color + (this.status ? '-' + this.status : '') + group_position;\n    };\n\n    // Permanence\n    /**\n     * Track internal state on whether to keep showing the button/ menu contents at the moment\n     * @protected\n     * @member {Boolean}\n     */\n    this.persist = false;\n    /**\n     * Configuration when defining a button: track whether this component should be allowed to keep open\n     *   menu/button contents in response to certain events\n     * @protected\n     * @member {Boolean}\n     */\n    this.permanent = false;\n    /**\n     * Allow code to change whether the button is allowed to be `permanent`\n     * @param {boolean} bool\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n    this.setPermanent = function(bool) {\n        if (typeof bool == 'undefined') { bool = true; } else { bool = Boolean(bool); }\n        this.permanent = bool;\n        if (this.permanent) { this.persist = true; }\n        return this;\n    };\n    /**\n     * Determine whether the button/menu contents should persist in response to a specific event\n     * @returns {Boolean}\n     */\n    this.shouldPersist = function() {\n        return this.permanent || this.persist;\n    };\n\n    /**\n     * Button status (highlighted / disabled/ etc)\n     * @protected\n     * @member {String}\n     */\n    this.status = '';\n    /**\n     * Change button state\n     * @param {('highlighted'|'disabled'|'')} status\n     */\n    this.setStatus = function(status) {\n        if (typeof status != 'undefined' && ['', 'highlighted', 'disabled'].indexOf(status) !== -1) { this.status = status; }\n        return this.update();\n    };\n    /**\n     * Toggle whether the button is highlighted\n     * @param {boolean} bool If provided, explicitly set highlighted state\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n    this.highlight = function(bool) {\n        if (typeof bool == 'undefined') { bool = true; } else { bool = Boolean(bool); }\n        if (bool) { return this.setStatus('highlighted'); }\n        else if (this.status === 'highlighted') { return this.setStatus(''); }\n        return this;\n    };\n    /**\n     * Toggle whether the button is disabled\n     * @param {boolean} bool If provided, explicitly set disabled state\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n    this.disable = function(bool) {\n        if (typeof bool == 'undefined') { bool = true; } else { bool = Boolean(bool); }\n        if (bool) { return this.setStatus('disabled'); }\n        else if (this.status === 'disabled') { return this.setStatus(''); }\n        return this;\n    };\n\n    // Mouse events\n    /** @member {function} */\n    this.onmouseover = function() {};\n    this.setOnMouseover = function(onmouseover) {\n        if (typeof onmouseover == 'function') { this.onmouseover = onmouseover; }\n        else { this.onmouseover = function() {}; }\n        return this;\n    };\n    /** @member {function} */\n    this.onmouseout = function() {};\n    this.setOnMouseout = function(onmouseout) {\n        if (typeof onmouseout == 'function') { this.onmouseout = onmouseout; }\n        else { this.onmouseout = function() {}; }\n        return this;\n    };\n    /** @member {function} */\n    this.onclick = function() {};\n    this.setOnclick = function(onclick) {\n        if (typeof onclick == 'function') { this.onclick = onclick; }\n        else { this.onclick = function() {}; }\n        return this;\n    };\n\n    // Primary behavior functions\n    /**\n     * Show the button, including creating DOM elements if necessary for first render\n     */\n    this.show = function() {\n        if (!this.parent) { return; }\n        if (!this.selector) {\n            this.selector = this.parent.selector.append(this.tag).attr('class', this.getClass());\n        }\n        return this.update();\n    };\n    /**\n     * Hook for any actions or state cleanup to be performed before rerendering\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n    this.preUpdate = function() { return this; };\n    /**\n     * Update button state and contents, and fully rerender\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n    this.update = function() {\n        if (!this.selector) { return this; }\n        this.preUpdate();\n        this.selector\n            .attr('class', this.getClass())\n            .attr('title', this.title).style(this.style)\n            .on('mouseover', (this.status === 'disabled') ? null : this.onmouseover)\n            .on('mouseout', (this.status === 'disabled') ? null : this.onmouseout)\n            .on('click', (this.status === 'disabled') ? null : this.onclick)\n            .html(this.html);\n        this.menu.update();\n        this.postUpdate();\n        return this;\n    };\n    /**\n     * Hook for any behavior to be added/changed after the button has been re-rendered\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n    this.postUpdate = function() { return this; };\n    /**\n     * Hide the button by removing it from the DOM (may be overridden by current persistence setting)\n     * @returns {LocusZoom.Dashboard.Component.Button}\n     */\n    this.hide = function() {\n        if (this.selector && !this.shouldPersist()) {\n            this.selector.remove();\n            this.selector = null;\n        }\n        return this;\n    };\n\n    /**\n     * Button Menu Object\n     * The menu is an HTML overlay that can appear below a button. It can contain arbitrary HTML and\n     *   has logic to be automatically positioned and sized to behave more or less like a dropdown menu.\n     * @member {Object}\n     */\n    this.menu = {\n        outer_selector: null,\n        inner_selector: null,\n        scroll_position: 0,\n        hidden: true,\n        /**\n         * Show the button menu, including setting up any DOM elements needed for first rendering\n         */\n        show: function() {\n            if (!this.menu.outer_selector) {\n                this.menu.outer_selector = d3.select(this.parent_plot.svg.node().parentNode).append('div')\n                    .attr('class', 'lz-dashboard-menu lz-dashboard-menu-' + this.color)\n                    .attr('id', this.parent_svg.getBaseId() + '.dashboard.menu');\n                this.menu.inner_selector = this.menu.outer_selector.append('div')\n                    .attr('class', 'lz-dashboard-menu-content');\n                this.menu.inner_selector.on('scroll', function() {\n                    this.menu.scroll_position = this.menu.inner_selector.node().scrollTop;\n                }.bind(this));\n            }\n            this.menu.outer_selector.style({ visibility: 'visible' });\n            this.menu.hidden = false;\n            return this.menu.update();\n        }.bind(this),\n        /**\n         * Update the rendering of the menu\n         */\n        update: function() {\n            if (!this.menu.outer_selector) { return this.menu; }\n            this.menu.populate(); // This function is stubbed for all buttons by default and custom implemented in component definition\n            if (this.menu.inner_selector) { this.menu.inner_selector.node().scrollTop = this.menu.scroll_position; }\n            return this.menu.position();\n        }.bind(this),\n        position: function() {\n            if (!this.menu.outer_selector) { return this.menu; }\n            // Unset any explicitly defined outer selector height so that menus dynamically shrink if content is removed\n            this.menu.outer_selector.style({ height: null });\n            var padding = 3;\n            var scrollbar_padding = 20;\n            var menu_height_padding = 14; // 14: 2x 6px padding, 2x 1px border\n            var page_origin = this.parent_svg.getPageOrigin();\n            var page_scroll_top = document.documentElement.scrollTop || document.body.scrollTop;\n            var container_offset = this.parent_plot.getContainerOffset();\n            var dashboard_client_rect = this.parent_dashboard.selector.node().getBoundingClientRect();\n            var button_client_rect = this.selector.node().getBoundingClientRect();\n            var menu_client_rect = this.menu.outer_selector.node().getBoundingClientRect();\n            var total_content_height = this.menu.inner_selector.node().scrollHeight;\n            var top = 0; var left = 0;\n            if (this.parent_dashboard.type === 'panel') {\n                top = (page_origin.y + dashboard_client_rect.height + (2 * padding));\n                left = Math.max(page_origin.x + this.parent_svg.layout.width - menu_client_rect.width - padding, page_origin.x + padding);\n            } else {\n                top = button_client_rect.bottom + page_scroll_top + padding - container_offset.top;\n                left = Math.max(button_client_rect.left + button_client_rect.width - menu_client_rect.width - container_offset.left, page_origin.x + padding);\n            }\n            var base_max_width = Math.max(this.parent_svg.layout.width - (2 * padding) - scrollbar_padding, scrollbar_padding);\n            var container_max_width = base_max_width;\n            var content_max_width = (base_max_width - (4 * padding));\n            var base_max_height = Math.max(this.parent_svg.layout.height - (10 * padding) - menu_height_padding, menu_height_padding);\n            var height = Math.min(total_content_height, base_max_height);\n            var max_height = base_max_height;\n            this.menu.outer_selector.style({\n                'top': top.toString() + 'px',\n                'left': left.toString() + 'px',\n                'max-width': container_max_width.toString() + 'px',\n                'max-height': max_height.toString() + 'px',\n                'height': height.toString() + 'px'\n            });\n            this.menu.inner_selector.style({ 'max-width': content_max_width.toString() + 'px' });\n            this.menu.inner_selector.node().scrollTop = this.menu.scroll_position;\n            return this.menu;\n        }.bind(this),\n        hide: function() {\n            if (!this.menu.outer_selector) { return this.menu; }\n            this.menu.outer_selector.style({ visibility: 'hidden' });\n            this.menu.hidden = true;\n            return this.menu;\n        }.bind(this),\n        destroy: function() {\n            if (!this.menu.outer_selector) { return this.menu; }\n            this.menu.inner_selector.remove();\n            this.menu.outer_selector.remove();\n            this.menu.inner_selector = null;\n            this.menu.outer_selector = null;\n            return this.menu;\n        }.bind(this),\n        /**\n         * Internal method definition\n         * By convention populate() does nothing and should be reimplemented with each dashboard button definition\n         *   Reimplement by way of Dashboard.Component.Button.menu.setPopulate to define the populate method and hook\n         *   up standard menu click-toggle behavior prototype.\n         * @protected\n         */\n        populate: function() { /* stub */ }.bind(this),\n        /**\n         * Define how the menu is populated with items, and set up click and display properties as appropriate\n         * @public\n         */\n        setPopulate: function(menu_populate_function) {\n            if (typeof menu_populate_function == 'function') {\n                this.menu.populate = menu_populate_function;\n                this.setOnclick(function() {\n                    if (this.menu.hidden) {\n                        this.menu.show();\n                        this.highlight().update();\n                        this.persist = true;\n                    } else {\n                        this.menu.hide();\n                        this.highlight(false).update();\n                        if (!this.permanent) { this.persist = false; }\n                    }\n                }.bind(this));\n            } else {\n                this.setOnclick();\n            }\n            return this;\n        }.bind(this)\n    };\n\n};\n\n/**\n * Renders arbitrary text with title formatting\n * @class LocusZoom.Dashboard.Components.title\n * @augments LocusZoom.Dashboard.Component\n * @param {object} layout\n * @param {string} layout.title Text to render\n */\nLocusZoom.Dashboard.Components.add('title', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n    this.show = function() {\n        this.div_selector = this.parent.selector.append('div')\n            .attr('class', 'lz-dashboard-title lz-dashboard-' + this.layout.position);\n        this.title_selector = this.div_selector.append('h3');\n        return this.update();\n    };\n    this.update = function() {\n        var title = layout.title.toString();\n        if (this.layout.subtitle) { title += ' <small>' + this.layout.subtitle + '</small>'; }\n        this.title_selector.html(title);\n        return this;\n    };\n});\n\n/**\n * Renders text to display the current dimensions of the plot. Automatically updated as plot dimensions change\n * @class LocusZoom.Dashboard.Components.dimensions\n * @augments LocusZoom.Dashboard.Component\n */\nLocusZoom.Dashboard.Components.add('dimensions', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n    this.update = function() {\n        var display_width = this.parent_plot.layout.width.toString().indexOf('.') === -1 ? this.parent_plot.layout.width : this.parent_plot.layout.width.toFixed(2);\n        var display_height = this.parent_plot.layout.height.toString().indexOf('.') === -1 ? this.parent_plot.layout.height : this.parent_plot.layout.height.toFixed(2);\n        this.selector.html(display_width + 'px  ' + display_height + 'px');\n        if (layout.class) { this.selector.attr('class', layout.class); }\n        if (layout.style) { this.selector.style(layout.style); }\n        return this;\n    };\n});\n\n/**\n * Display the current scale of the genome region displayed in the plot, as defined by the difference between\n *  `state.end` and `state.start`.\n * @class LocusZoom.Dashboard.Components.region_scale\n * @augments LocusZoom.Dashboard.Component\n */\nLocusZoom.Dashboard.Components.add('region_scale', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n    this.update = function() {\n        if (!isNaN(this.parent_plot.state.start) && !isNaN(this.parent_plot.state.end)\n            && this.parent_plot.state.start !== null && this.parent_plot.state.end !== null) {\n            this.selector.style('display', null);\n            this.selector.html(LocusZoom.positionIntToString(this.parent_plot.state.end - this.parent_plot.state.start, null, true));\n        } else {\n            this.selector.style('display', 'none');\n        }\n        if (layout.class) { this.selector.attr('class', layout.class); }\n        if (layout.style) { this.selector.style(layout.style); }\n        return this;\n    };\n});\n\n/**\n * Button to export current plot to an SVG image\n * @class LocusZoom.Dashboard.Components.download\n * @augments LocusZoom.Dashboard.Component\n */\nLocusZoom.Dashboard.Components.add('download', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n    this.update = function() {\n        if (this.button) { return this; }\n        this.button = new LocusZoom.Dashboard.Component.Button(this)\n            .setColor(layout.color).setHtml('Download Image').setTitle('Download image of the current plot as locuszoom.svg')\n            .setOnMouseover(function() {\n                this.button.selector\n                    .classed('lz-dashboard-button-gray-disabled', true)\n                    .html('Preparing Image');\n                this.generateBase64SVG().then(function(url) {\n                    var old = this.button.selector.attr('href');\n                    if (old) { URL.revokeObjectURL(old); }  // Clean up old url instance to prevent memory leaks\n                    this.button.selector\n                        .attr('href', url)\n                        .classed('lz-dashboard-button-gray-disabled', false)\n                        .classed('lz-dashboard-button-gray-highlighted', true)\n                        .html('Download Image');\n                }.bind(this));\n            }.bind(this))\n            .setOnMouseout(function() {\n                this.button.selector.classed('lz-dashboard-button-gray-highlighted', false);\n            }.bind(this));\n        this.button.show();\n        this.button.selector.attr('href-lang', 'image/svg+xml').attr('download', 'locuszoom.svg');\n        return this;\n    };\n    this.css_string = '';\n    for (var stylesheet in Object.keys(document.styleSheets)) {\n        if ( document.styleSheets[stylesheet].href !== null\n             && document.styleSheets[stylesheet].href.indexOf('locuszoom.css') !== -1) {\n            // TODO: \"Download image\" button will render the image incorrectly if the stylesheet has been renamed or concatenated\n            LocusZoom.createCORSPromise('GET', document.styleSheets[stylesheet].href)\n                .then(function(response) {\n                    this.css_string = response.replace(/[\\r\\n]/g,' ').replace(/\\s+/g,' ');\n                    if (this.css_string.indexOf('/* ! LocusZoom HTML Styles */')) {\n                        this.css_string = this.css_string.substring(0, this.css_string.indexOf('/* ! LocusZoom HTML Styles */'));\n                    }\n                }.bind(this));\n            break;\n        }\n    }\n    this.generateBase64SVG = function() {\n        return new Promise(function (resolve, reject) {\n            // Insert a hidden div, clone the node into that so we can modify it with d3\n            var container = this.parent.selector.append('div').style('display', 'none')\n                .html(this.parent_plot.svg.node().outerHTML);\n            // Remove unnecessary elements\n            container.selectAll('g.lz-curtain').remove();\n            container.selectAll('g.lz-mouse_guide').remove();\n            // Convert units on axis tick dy attributes from ems to pixels\n            container.selectAll('g.tick text').each(function() {\n                var dy = +(d3.select(this).attr('dy').substring(-2).slice(0,-2)) * 10;\n                d3.select(this).attr('dy', dy);\n            });\n            // Pull the svg into a string and add the contents of the locuszoom stylesheet\n            // Don't add this with d3 because it will escape the CDATA declaration incorrectly\n            var initial_html = d3.select(container.select('svg').node().parentNode).html();\n            var style_def = '<style type=\"text/css\"><![CDATA[ ' + this.css_string + ' ]]></style>';\n            var insert_at = initial_html.indexOf('>') + 1;\n            initial_html = initial_html.slice(0,insert_at) + style_def + initial_html.slice(insert_at);\n            // Delete the container node\n            container.remove();\n            // Create an object URL based on the rendered markup\n            var content = new Blob([initial_html], { type: 'image/svg+xml' });\n            resolve(URL.createObjectURL(content));\n        }.bind(this));\n    };\n});\n\n/**\n * Button to remove panel from plot.\n *   NOTE: Will only work on panel dashboards.\n * @class LocusZoom.Dashboard.Components.remove_panel\n * @augments LocusZoom.Dashboard.Component\n * @param {Boolean} [layout.suppress_confirm=false] If true, removes the panel without prompting user for confirmation\n */\nLocusZoom.Dashboard.Components.add('remove_panel', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n    this.update = function() {\n        if (this.button) { return this; }\n        this.button = new LocusZoom.Dashboard.Component.Button(this)\n            .setColor(layout.color).setHtml('').setTitle('Remove panel')\n            .setOnclick(function() {\n                if (!layout.suppress_confirm && !confirm('Are you sure you want to remove this panel? This cannot be undone!')) {\n                    return false;\n                }\n                var panel = this.parent_panel;\n                panel.dashboard.hide(true);\n                d3.select(panel.parent.svg.node().parentNode).on('mouseover.' + panel.getBaseId() + '.dashboard', null);\n                d3.select(panel.parent.svg.node().parentNode).on('mouseout.' + panel.getBaseId() + '.dashboard', null);\n                return panel.parent.removePanel(panel.id);\n            }.bind(this));\n        this.button.show();\n        return this;\n    };\n});\n\n/**\n * Button to move panel up relative to other panels (in terms of y-index on the page)\n *   NOTE: Will only work on panel dashboards.\n * @class LocusZoom.Dashboard.Components.move_panel_up\n * @augments LocusZoom.Dashboard.Component\n */\nLocusZoom.Dashboard.Components.add('move_panel_up', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n    this.update = function() {\n        if (this.button) {\n            var is_at_top = (this.parent_panel.layout.y_index === 0);\n            this.button.disable(is_at_top);\n            return this;\n        }\n        this.button = new LocusZoom.Dashboard.Component.Button(this)\n            .setColor(layout.color).setHtml('').setTitle('Move panel up')\n            .setOnclick(function() {\n                this.parent_panel.moveUp();\n                this.update();\n            }.bind(this));\n        this.button.show();\n        return this.update();\n    };\n});\n\n/**\n * Button to move panel down relative to other panels (in terms of y-index on the page)\n *   NOTE: Will only work on panel dashboards.\n * @class LocusZoom.Dashboard.Components.move_panel_down\n * @augments LocusZoom.Dashboard.Component\n */\nLocusZoom.Dashboard.Components.add('move_panel_down', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n    this.update = function() {\n        if (this.button) {\n            var is_at_bottom = (this.parent_panel.layout.y_index === this.parent_plot.panel_ids_by_y_index.length - 1);\n            this.button.disable(is_at_bottom);\n            return this;\n        }\n        this.button = new LocusZoom.Dashboard.Component.Button(this)\n            .setColor(layout.color).setHtml('').setTitle('Move panel down')\n            .setOnclick(function() {\n                this.parent_panel.moveDown();\n                this.update();\n            }.bind(this));\n        this.button.show();\n        return this.update();\n    };\n});\n\n/**\n * Button to shift plot region forwards or back by a `step` increment provided in the layout\n * @class LocusZoom.Dashboard.Components.shift_region\n * @augments LocusZoom.Dashboard.Component\n * @param {object} layout\n * @param {number} [layout.step=50000] The stepsize to change the region by\n * @param {string} [layout.button_html]\n * @param {string} [layout.button_title]\n */\nLocusZoom.Dashboard.Components.add('shift_region', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n    if (isNaN(this.parent_plot.state.start) || isNaN(this.parent_plot.state.end)) {\n        this.update = function() {};\n        console.warn('Unable to add shift_region dashboard component: plot state does not have region bounds');\n        return;\n    }\n    if (isNaN(layout.step) || layout.step === 0) { layout.step = 50000; }\n    if (typeof layout.button_html !== 'string') { layout.button_html = layout.step > 0 ? '>' : '<'; }\n    if (typeof layout.button_title !== 'string') {\n        layout.button_title = 'Shift region by ' + (layout.step > 0 ? '+' : '-') + LocusZoom.positionIntToString(Math.abs(layout.step),null,true);\n    }\n    this.update = function() {\n        if (this.button) { return this; }\n        this.button = new LocusZoom.Dashboard.Component.Button(this)\n            .setColor(layout.color).setHtml(layout.button_html).setTitle(layout.button_title)\n            .setOnclick(function() {\n                this.parent_plot.applyState({\n                    start: Math.max(this.parent_plot.state.start + layout.step, 1),\n                    end: this.parent_plot.state.end + layout.step\n                });\n            }.bind(this));\n        this.button.show();\n        return this;\n    };\n});\n\n/**\n * Zoom in or out on the plot, centered on the middle of the plot region, by the specified amount\n * @class LocusZoom.Dashboard.Components.zoom_region\n * @augments LocusZoom.Dashboard.Component\n * @param {object} layout\n * @param {number} [layout.step=0.2] The amount to zoom in by (where 1 indicates 100%)\n */\nLocusZoom.Dashboard.Components.add('zoom_region', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n    if (isNaN(this.parent_plot.state.start) || isNaN(this.parent_plot.state.end)) {\n        this.update = function() {};\n        console.warn('Unable to add zoom_region dashboard component: plot state does not have region bounds');\n        return;\n    }\n    if (isNaN(layout.step) || layout.step === 0) { layout.step = 0.2; }\n    if (typeof layout.button_html != 'string') { layout.button_html = layout.step > 0 ? 'z' : 'z+'; }\n    if (typeof layout.button_title != 'string') {\n        layout.button_title = 'Zoom region ' + (layout.step > 0 ? 'out' : 'in') + ' by ' + (Math.abs(layout.step) * 100).toFixed(1) + '%';\n    }\n    this.update = function() {\n        if (this.button) {\n            var can_zoom = true;\n            var current_region_scale = this.parent_plot.state.end - this.parent_plot.state.start;\n            if (layout.step > 0 && !isNaN(this.parent_plot.layout.max_region_scale) && current_region_scale >= this.parent_plot.layout.max_region_scale) {\n                can_zoom = false;\n            }\n            if (layout.step < 0 && !isNaN(this.parent_plot.layout.min_region_scale) && current_region_scale <= this.parent_plot.layout.min_region_scale) {\n                can_zoom = false;\n            }\n            this.button.disable(!can_zoom);\n            return this;\n        }\n        this.button = new LocusZoom.Dashboard.Component.Button(this)\n            .setColor(layout.color).setHtml(layout.button_html).setTitle(layout.button_title)\n            .setOnclick(function() {\n                var current_region_scale = this.parent_plot.state.end - this.parent_plot.state.start;\n                var zoom_factor = 1 + layout.step;\n                var new_region_scale = current_region_scale * zoom_factor;\n                if (!isNaN(this.parent_plot.layout.max_region_scale)) {\n                    new_region_scale = Math.min(new_region_scale, this.parent_plot.layout.max_region_scale);\n                }\n                if (!isNaN(this.parent_plot.layout.min_region_scale)) {\n                    new_region_scale = Math.max(new_region_scale, this.parent_plot.layout.min_region_scale);\n                }\n                var delta = Math.floor((new_region_scale - current_region_scale) / 2);\n                this.parent_plot.applyState({\n                    start: Math.max(this.parent_plot.state.start - delta, 1),\n                    end: this.parent_plot.state.end + delta\n                });\n            }.bind(this));\n        this.button.show();\n        return this;\n    };\n});\n\n/**\n * Renders button with arbitrary text that, when clicked, shows a dropdown containing arbitrary HTML\n *  NOTE: Trusts content exactly as given. XSS prevention is the responsibility of the implementer.\n * @class LocusZoom.Dashboard.Components.menu\n * @augments LocusZoom.Dashboard.Component\n * @param {object} layout\n * @param {string} layout.button_html The HTML to render inside the button\n * @param {string} layout.button_title Text to display as a tooltip when hovering over the button\n * @param {string} layout.menu_html The HTML content of the dropdown menu\n */\nLocusZoom.Dashboard.Components.add('menu', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n    this.update = function() {\n        if (this.button) { return this; }\n        this.button = new LocusZoom.Dashboard.Component.Button(this)\n            .setColor(layout.color).setHtml(layout.button_html).setTitle(layout.button_title);\n        this.button.menu.setPopulate(function() {\n            this.button.menu.inner_selector.html(layout.menu_html);\n        }.bind(this));\n        this.button.show();\n        return this;\n    };\n});\n\n/**\n * Special button/menu to allow model building by tracking individual covariants. Will track a list of covariate\n *   objects and store them in the special `model.covariates` field of plot `state`.\n * @class LocusZoom.Dashboard.Components.covariates_model\n * @augments LocusZoom.Dashboard.Component\n * @param {object} layout\n * @param {string} layout.button_html The HTML to render inside the button\n * @param {string} layout.button_title Text to display as a tooltip when hovering over the button\n */\nLocusZoom.Dashboard.Components.add('covariates_model', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n\n    this.initialize = function() {\n        // Initialize state.model.covariates\n        this.parent_plot.state.model = this.parent_plot.state.model || {};\n        this.parent_plot.state.model.covariates = this.parent_plot.state.model.covariates || [];\n        // Create an object at the plot level for easy access to interface methods in custom client-side JS\n        /**\n         * When a covariates model dashboard element is present, create (one) object at the plot level that exposes\n         *   component data and state for custom interactions with other plot elements.\n         * @class LocusZoom.Plot.CovariatesModel\n         */\n        this.parent_plot.CovariatesModel = {\n            /** @member {LocusZoom.Dashboard.Component.Button} */\n            button: this,\n            /**\n             * Add an element to the model and show a representation of it in the dashboard component menu. If the\n             *   element is already part of the model, do nothing (to avoid adding duplicates).\n             * When plot state is changed, this will automatically trigger requests for new data accordingly.\n             * @param {string|object} element_reference Can be any value that can be put through JSON.stringify()\n             *   to create a serialized representation of itself.\n             */\n            add: function(element_reference) {\n                var element = JSON.parse(JSON.stringify(element_reference));\n                if (typeof element_reference == 'object' && typeof element.html != 'string') {\n                    element.html = ( (typeof element_reference.toHTML == 'function') ? element_reference.toHTML() : element_reference.toString());\n                }\n                // Check if the element is already in the model covariates array and return if it is.\n                for (var i = 0; i < this.state.model.covariates.length; i++) {\n                    if (JSON.stringify(this.state.model.covariates[i]) === JSON.stringify(element)) {\n                        return this;\n                    }\n                }\n                this.state.model.covariates.push(element);\n                this.applyState();\n                this.CovariatesModel.updateComponent();\n                return this;\n            }.bind(this.parent_plot),\n            /**\n             * Remove an element from `state.model.covariates` (and from the dashboard component menu's\n             *  representation of the state model). When plot state is changed, this will automatically trigger\n             *  requests for new data accordingly.\n             * @param {number} idx Array index of the element, in the `state.model.covariates array`.\n             */\n            removeByIdx: function(idx) {\n                if (typeof this.state.model.covariates[idx] == 'undefined') {\n                    throw new Error('Unable to remove model covariate, invalid index: ' + idx.toString());\n                }\n                this.state.model.covariates.splice(idx, 1);\n                this.applyState();\n                this.CovariatesModel.updateComponent();\n                return this;\n            }.bind(this.parent_plot),\n            /**\n             * Empty the `state.model.covariates` array (and dashboard component menu representation thereof) of all\n             *  elements. When plot state is changed, this will automatically trigger requests for new data accordingly\n             */\n            removeAll: function() {\n                this.state.model.covariates = [];\n                this.applyState();\n                this.CovariatesModel.updateComponent();\n                return this;\n            }.bind(this.parent_plot),\n            /**\n             * Manually trigger the update methods on the dashboard component's button and menu elements to force\n             *   display of most up-to-date content. Can be used to force the dashboard to reflect changes made, eg if\n             *   modifying `state.model.covariates` directly instead of via `plot.CovariatesModel`\n             */\n            updateComponent: function() {\n                this.button.update();\n                this.button.menu.update();\n            }.bind(this)\n        };\n    }.bind(this);\n\n    this.update = function() {\n\n        if (this.button) { return this; }\n\n        this.button = new LocusZoom.Dashboard.Component.Button(this)\n            .setColor(layout.color).setHtml(layout.button_html).setTitle(layout.button_title)\n            .setOnclick(function() {\n                this.button.menu.populate();\n            }.bind(this));\n\n        this.button.menu.setPopulate(function() {\n            var selector = this.button.menu.inner_selector;\n            selector.html('');\n            // General model HTML representation\n            if (typeof this.parent_plot.state.model.html != 'undefined') {\n                selector.append('div').html(this.parent_plot.state.model.html);\n            }\n            // Model covariates table\n            if (!this.parent_plot.state.model.covariates.length) {\n                selector.append('i').html('no covariates in model');\n            } else {\n                selector.append('h5').html('Model Covariates (' + this.parent_plot.state.model.covariates.length + ')');\n                var table = selector.append('table');\n                this.parent_plot.state.model.covariates.forEach(function(covariate, idx) {\n                    var html = ( (typeof covariate == 'object' && typeof covariate.html == 'string') ? covariate.html : covariate.toString() );\n                    var row = table.append('tr');\n                    row.append('td').append('button')\n                        .attr('class', 'lz-dashboard-button lz-dashboard-button-' + this.layout.color)\n                        .style({ 'margin-left': '0em' })\n                        .on('click', function() {\n                            this.parent_plot.CovariatesModel.removeByIdx(idx);\n                        }.bind(this))\n                        .html('');\n                    row.append('td').html(html);\n                }.bind(this));\n                selector.append('button')\n                    .attr('class', 'lz-dashboard-button lz-dashboard-button-' + this.layout.color)\n                    .style({ 'margin-left': '4px' }).html(' Remove All Covariates')\n                    .on('click', function() {\n                        this.parent_plot.CovariatesModel.removeAll();\n                    }.bind(this));\n            }\n        }.bind(this));\n\n        this.button.preUpdate = function() {\n            var html = 'Model';\n            if (this.parent_plot.state.model.covariates.length) {\n                var cov = this.parent_plot.state.model.covariates.length > 1 ? 'covariates' : 'covariate';\n                html += ' (' + this.parent_plot.state.model.covariates.length + ' ' + cov + ')';\n            }\n            this.button.setHtml(html).disable(false);\n        }.bind(this);\n\n        this.button.show();\n\n        return this;\n    };\n});\n\n/**\n * Button to toggle split tracks\n * @class LocusZoom.Dashboard.Components.toggle_split_tracks\n * @augments LocusZoom.Dashboard.Component\n */\nLocusZoom.Dashboard.Components.add('toggle_split_tracks', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n    if (!layout.data_layer_id) { layout.data_layer_id = 'intervals'; }\n    if (!this.parent_panel.data_layers[layout.data_layer_id]) {\n        throw new Error('Dashboard toggle split tracks component missing valid data layer ID');\n    }\n    this.update = function() {\n        var data_layer = this.parent_panel.data_layers[layout.data_layer_id];\n        var html = data_layer.layout.split_tracks ? 'Merge Tracks' : 'Split Tracks';\n        if (this.button) {\n            this.button.setHtml(html);\n            this.button.show();\n            this.parent.position();\n            return this;\n        } else {\n            this.button = new LocusZoom.Dashboard.Component.Button(this)\n                .setColor(layout.color).setHtml(html)\n                .setTitle('Toggle whether tracks are split apart or merged together')\n                .setOnclick(function() {\n                    data_layer.toggleSplitTracks();\n                    if (this.scale_timeout) { clearTimeout(this.scale_timeout); }\n                    var timeout = data_layer.layout.transition ? +data_layer.layout.transition.duration || 0 : 0;\n                    this.scale_timeout = setTimeout(function() {\n                        this.parent_panel.scaleHeightToData();\n                        this.parent_plot.positionPanels();\n                    }.bind(this), timeout);\n                    this.update();\n                }.bind(this));\n            return this.update();\n        }\n    };\n});\n\n/**\n * Button to resize panel height to fit available data (eg when showing a list of tracks)\n * @class LocusZoom.Dashboard.Components.resize_to_data\n * @augments LocusZoom.Dashboard.Component\n */\nLocusZoom.Dashboard.Components.add('resize_to_data', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n    this.update = function() {\n        if (this.button) { return this; }\n        this.button = new LocusZoom.Dashboard.Component.Button(this)\n            .setColor(layout.color).setHtml('Resize to Data')\n            .setTitle('Automatically resize this panel to fit the data its currently showing')\n            .setOnclick(function() {\n                this.parent_panel.scaleHeightToData();\n                this.update();\n            }.bind(this));\n        this.button.show();\n        return this;\n    };\n});\n\n/**\n * Button to toggle legend\n * @class LocusZoom.Dashboard.Components.toggle_legend\n * @augments LocusZoom.Dashboard.Component\n */\nLocusZoom.Dashboard.Components.add('toggle_legend', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n    this.update = function() {\n        var html = this.parent_panel.legend.layout.hidden ? 'Show Legend' : 'Hide Legend';\n        if (this.button) {\n            this.button.setHtml(html).show();\n            this.parent.position();\n            return this;\n        }\n        this.button = new LocusZoom.Dashboard.Component.Button(this)\n            .setColor(layout.color)\n            .setTitle('Show or hide the legend for this panel')\n            .setOnclick(function() {\n                this.parent_panel.legend.layout.hidden = !this.parent_panel.legend.layout.hidden;\n                this.parent_panel.legend.render();\n                this.update();\n            }.bind(this));\n        return this.update();\n    };\n});\n\n/**\n * Menu for manipulating multiple data layers in a single panel: show/hide, change order, etc.\n * @class LocusZoom.Dashboard.Components.data_layers\n * @augments LocusZoom.Dashboard.Component\n */\nLocusZoom.Dashboard.Components.add('data_layers', function(layout) {\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n\n    this.update = function() {\n\n        if (typeof layout.button_html != 'string') { layout.button_html = 'Data Layers'; }\n        if (typeof layout.button_title != 'string') { layout.button_title = 'Manipulate Data Layers (sort, dim, show/hide, etc.)'; }\n\n        if (this.button) { return this; }\n\n        this.button = new LocusZoom.Dashboard.Component.Button(this)\n            .setColor(layout.color).setHtml(layout.button_html).setTitle(layout.button_title)\n            .setOnclick(function() {\n                this.button.menu.populate();\n            }.bind(this));\n\n        this.button.menu.setPopulate(function() {\n            this.button.menu.inner_selector.html('');\n            var table = this.button.menu.inner_selector.append('table');\n            this.parent_panel.data_layer_ids_by_z_index.slice().reverse().forEach(function(id, idx) {\n                var data_layer = this.parent_panel.data_layers[id];\n                var name = (typeof data_layer.layout.name != 'string') ? data_layer.id : data_layer.layout.name;\n                var row = table.append('tr');\n                // Layer name\n                row.append('td').html(name);\n                // Status toggle buttons\n                layout.statuses.forEach(function(status_adj) {\n                    var status_idx = LocusZoom.DataLayer.Statuses.adjectives.indexOf(status_adj);\n                    var status_verb = LocusZoom.DataLayer.Statuses.verbs[status_idx];\n                    var html, onclick, highlight;\n                    if (data_layer.global_statuses[status_adj]) {\n                        html = LocusZoom.DataLayer.Statuses.menu_antiverbs[status_idx];\n                        onclick = 'un' + status_verb + 'AllElements';\n                        highlight = '-highlighted';\n                    } else {\n                        html = LocusZoom.DataLayer.Statuses.verbs[status_idx];\n                        onclick = status_verb + 'AllElements';\n                        highlight = '';\n                    }\n                    row.append('td').append('a')\n                        .attr('class', 'lz-dashboard-button lz-dashboard-button-' + this.layout.color + highlight)\n                        .style({ 'margin-left': '0em' })\n                        .on('click', function() { data_layer[onclick](); this.button.menu.populate(); }.bind(this))\n                        .html(html);\n                }.bind(this));\n                // Sort layer buttons\n                var at_top = (idx === 0);\n                var at_bottom = (idx === (this.parent_panel.data_layer_ids_by_z_index.length - 1));\n                var td = row.append('td');\n                td.append('a')\n                    .attr('class', 'lz-dashboard-button lz-dashboard-button-group-start lz-dashboard-button-' + this.layout.color + (at_bottom ? '-disabled' : ''))\n                    .style({ 'margin-left': '0em' })\n                    .on('click', function() { data_layer.moveDown(); this.button.menu.populate(); }.bind(this))\n                    .html('').attr('title', 'Move layer down (further back)');\n                td.append('a')\n                    .attr('class', 'lz-dashboard-button lz-dashboard-button-group-middle lz-dashboard-button-' + this.layout.color + (at_top ? '-disabled' : ''))\n                    .style({ 'margin-left': '0em' })\n                    .on('click', function() { data_layer.moveUp(); this.button.menu.populate(); }.bind(this))\n                    .html('').attr('title', 'Move layer up (further front)');\n                td.append('a')\n                    .attr('class', 'lz-dashboard-button lz-dashboard-button-group-end lz-dashboard-button-red')\n                    .style({ 'margin-left': '0em' })\n                    .on('click', function() {\n                        if (confirm('Are you sure you want to remove the ' + name + ' layer? This cannot be undone!')) {\n                            data_layer.parent.removeDataLayer(id);\n                        }\n                        return this.button.menu.populate();\n                    }.bind(this))\n                    .html('').attr('title', 'Remove layer');\n            }.bind(this));\n            return this;\n        }.bind(this));\n\n        this.button.show();\n\n        return this;\n    };\n});\n\n/**\n * Dropdown menu allowing the user to choose between different display options for a single specific data layer\n *  within a panel.\n *\n * This allows controlling how points on a datalayer can be displayed- any display options supported via the layout for the target datalayer. This includes point\n *  size/shape, coloring, etc.\n *\n * This button intentionally limits display options it can control to those available on common plot types.\n *   Although the list of options it sets can be overridden (to control very special custom plot types), this\n *   capability should be used sparingly if at all.\n *\n * @class LocusZoom.Dashboard.Components.display_options\n * @augments LocusZoom.Dashboard.Component\n * @param {object} layout\n * @param {String} [layout.button_html=\"Display options...\"] Text to display on the toolbar button\n * @param {String} [layout.button_title=\"Control how plot items are displayed\"] Hover text for the toolbar button\n * @param {string} layout.layer_name Specify the datalayer that this button should affect\n * @param {string} [layout.default_config_display_name] Store the default configuration for this datalayer\n *  configuration, and show a button to revert to the \"default\" (listing the human-readable display name provided)\n * @param {Array} [layout.fields_whitelist='see code'] The list of presentation fields that this button can control.\n *  This can be overridden if this button needs to be used on a custom layer type with special options.\n * @typedef {{display_name: string, display: Object}} DisplayOptionsButtonConfigField\n * @param {DisplayOptionsButtonConfigField[]} layout.options Specify a label and set of layout directives associated\n *  with this `display` option. Display field should include all changes to datalayer presentation options.\n */\nLocusZoom.Dashboard.Components.add('display_options', function (layout) {\n    if (typeof layout.button_html != 'string') { layout.button_html = 'Display options...'; }\n    if (typeof layout.button_title != 'string') { layout.button_title = 'Control how plot items are displayed'; }\n\n    // Call parent constructor\n    LocusZoom.Dashboard.Component.apply(this, arguments);\n\n    // List of layout fields that this button is allowed to control. This ensures that we don't override any other\n    //  information (like plot height etc) while changing point rendering\n    var allowed_fields = layout.fields_whitelist || ['color', 'fill_opacity', 'label', 'legend',\n        'point_shape', 'point_size', 'tooltip', 'tooltip_positioning'];\n\n    var dataLayer = this.parent_panel.data_layers[layout.layer_name];\n    if (!dataLayer) {\n        throw new Error(\"Display options could not locate the specified layer_name: '\" + layout.layer_name + \"'\");\n    }\n    var dataLayerLayout = dataLayer.layout;\n\n    // Store default configuration for the layer as a clean deep copy, so we may revert later\n    var defaultConfig = {};\n    allowed_fields.forEach(function(name) {\n        var configSlot = dataLayerLayout[name];\n        if (configSlot !== undefined) {\n            defaultConfig[name] = JSON.parse(JSON.stringify(configSlot));\n        }\n    });\n\n    /**\n     * Which item in the menu is currently selected. (track for rerendering menu)\n     * @member {String}\n     * @private\n     */\n    this._selected_item = 'default';\n\n    // Define the button + menu that provides the real functionality for this dashboard component\n    var self = this;\n    this.button = new LocusZoom.Dashboard.Component.Button(self)\n        .setColor(layout.color).setHtml(layout.button_html).setTitle(layout.button_title)\n        .setOnclick(function () {\n            self.button.menu.populate();\n        });\n    this.button.menu.setPopulate(function () {\n        // Multiple copies of this button might be used on a single LZ page; append unique IDs where needed\n        var uniqueID = Math.floor(Math.random() * 1e4).toString();\n\n        self.button.menu.inner_selector.html('');\n        var table = self.button.menu.inner_selector.append('table');\n\n        var menuLayout = self.layout;\n\n        var renderRow = function(display_name, display_options, row_id) { // Helper method\n            var row = table.append('tr');\n            var radioId = '' + uniqueID + row_id;\n            row.append('td')\n                .append('input')\n                .attr({id: radioId, type: 'radio', name: 'display-option-' + uniqueID, value: row_id})\n                .style('margin', 0) // Override css libraries (eg skeleton) that style form inputs\n                .property('checked', (row_id === self._selected_item))\n                .on('click', function () {\n                    // If an option is not specified in these display options, use the original defaults\n                    allowed_fields.forEach(function(field_name) {\n                        dataLayer.layout[field_name] = display_options[field_name] || defaultConfig[field_name];\n                    });\n\n                    self._selected_item = row_id;\n                    self.parent_panel.render();\n                    var legend = self.parent_panel.legend;\n                    if (legend) {\n                        legend.render();\n                    }\n                });\n            row.append('td').append('label')\n                .style('font-weight', 'normal')\n                .attr('for', radioId)\n                .text(display_name);\n        };\n        // Render the \"display options\" menu: default and special custom options\n        var defaultName = menuLayout.default_config_display_name || 'Default style';\n        renderRow(defaultName, defaultConfig, 'default');\n        menuLayout.options.forEach(function (item, index) {\n            renderRow(item.display_name, item.display, index);\n        });\n        return self;\n    });\n\n    this.update = function () {\n        this.button.show();\n        return this;\n    };\n});\n","/* global LocusZoom */\n'use strict';\n\n/**\n *\n * LocusZoom has various singleton objects that are used for registering functions or classes.\n * These objects provide safe, standard methods to redefine or delete existing functions/classes\n * as well as define new custom functions/classes to be used in a plot.\n *\n * @namespace Singletons\n */\n\n\n/*\n * The Collection of \"Known\" Data Sources. This registry is used internally by the `DataSources` class\n * @class\n * @static\n */\nLocusZoom.KnownDataSources = (function() {\n    /** @lends LocusZoom.KnownDataSources */\n    var obj = {};\n    /* @member {function[]} */\n    var sources = [];\n\n    var findSourceByName = function(x) {\n        for(var i = 0; i < sources.length; i++) {\n            if (!sources[i].SOURCE_NAME) {\n                throw new Error('KnownDataSources at position ' + i + \" does not have a 'SOURCE_NAME' static property\");\n            }\n            if (sources[i].SOURCE_NAME === x) {\n                return sources[i];\n            }\n        }\n        return null;\n    };\n\n    /**\n     * Identify the datasource associated with a given name\n     * @param {String} name\n     * @returns {function} The constructor for the data source; will usually extend `Data.Source`\n     */\n    obj.get = function(name) {\n        return findSourceByName(name);\n    };\n\n    /**\n     * Register a data source constructor so that it may be located by name\n     * @param {function} source A constructor function for a data source; will usually extend `Data.Source`,\n     *   and should have a `SOURCE_NAME` property\n     */\n    obj.add = function(source) {\n        if (!source.SOURCE_NAME) {\n            console.warn('Data source added does not have a SOURCE_NAME');\n        }\n        sources.push(source);\n    };\n\n    /**\n     * Create a custom source type that extends the behavior of an existing source, and registers that\n     *  source by the provided name\n     * @param {String} parent_name The name of a previously registered data source type to use as a template\n     * @param {String} source_name The new name to use when registering this data source\n     * @param {Object} overrides An object of additional properties and methods to add/override behavior\n     * @returns {LocusZoom.Data.Source} The newly defined class for this source\n     */\n    obj.extend = function(parent_name, source_name, overrides) {\n        var parent = findSourceByName(parent_name);\n        if (!parent) {\n            throw new Error('Attempted to subclass an unknown or unregistered data source');\n        }\n        if (!source_name) {\n            throw new Error('Must provide a name for the new data source');\n        }\n        if (typeof overrides !== 'object') {\n            throw new Error('Must specify an object of properties and methods');\n        }\n        var child = LocusZoom.subclass(parent, overrides);\n        child.SOURCE_NAME = source_name;\n        sources.push(child);\n        return child;\n    };\n\n    /** @deprecated */\n    obj.push = function(source) {\n        console.warn('Warning: KnownDataSources.push() is deprecated. Use .add() instead');\n        obj.add(source);\n    };\n\n    /**\n     * List the names of all registered datasources\n     * @returns {String[]}\n     */\n    obj.list = function() {\n        return sources.map(function(x) {return x.SOURCE_NAME;});\n    };\n\n    /**\n     * Create a datasource instance\n     * @param {String} name The name of the desired datasource to instantiate (must be defined in the registry)\n     * @returns {LocusZoom.Data.Source}\n     */\n    obj.create = function(name) {\n        //create new object (pass additional parameters to constructor)\n        var newObj = findSourceByName(name);\n        if (newObj) {\n            var params = arguments;\n            params[0] = null;\n            return new (Function.prototype.bind.apply(newObj, params));\n        } else {\n            throw new Error('Unable to find data source for name: ' + name);\n        }\n    };\n\n    /**\n     * Get the array of all registered constructors\n     *   Generally only used for unit tests internally\n     * @private\n     * @returns {function[]}\n     */\n    obj.getAll = function() {\n        return sources;\n    };\n\n    /**\n     * Register an entire collection of data sources\n     *   Generally only used for unit tests internally\n     * @private\n     * @param {function[]} x An array of datasource constructors\n     */\n    obj.setAll = function(x) {\n        sources = x;\n    };\n\n    /**\n     * Unregister all known data sources\n     *   Generally only used for unit tests internally\n     * @private\n     */\n    obj.clear = function() {\n        sources = [];\n    };\n\n    return obj;\n})();\n\n/**************************\n * Transformation Functions\n *\n * Singleton for formatting or transforming a single input, for instance turning raw p values into negative log10 form\n * Transformation functions are chainable with a pipe on a field name, like so: \"pvalue|neglog10\"\n *\n * NOTE: Because these functions are chainable the FUNCTION is returned by get(), not the result of that function.\n *\n * All transformation functions must accept an object of parameters and a value to process.\n * @class\n */\nLocusZoom.TransformationFunctions = (function() {\n    /** @lends LocusZoom.TransformationFunctions */\n    var obj = {};\n    var transformations = {};\n\n    var getTrans = function(name) {\n        if (!name) {\n            return null;\n        }\n        var fun = transformations[name];\n        if (fun)  {\n            return fun;\n        } else {\n            throw new Error('transformation ' + name + ' not found');\n        }\n    };\n\n    //a single transformation with any parameters\n    //(parameters not currently supported)\n    var parseTrans = function(name) {\n        return getTrans(name);\n    };\n\n    //a \"raw\" transformation string with a leading pipe\n    //and one or more transformations\n    var parseTransString = function(x) {\n        var funs = [];\n        var re = /\\|([^|]+)/g;\n        var result;\n        while((result = re.exec(x)) !== null) {\n            funs.push(result[1]);\n        }\n        if (funs.length === 1) {\n            return parseTrans(funs[0]);\n        } else if (funs.length > 1) {\n            return function(x) {\n                var val = x;\n                for(var i = 0; i < funs.length; i++) {\n                    val = parseTrans(funs[i])(val);\n                }\n                return val;\n            };\n        }\n        return null;\n    };\n\n    /**\n     * Retrieve a transformation function by name\n     * @param {String} name The name of the transformation function to retrieve. May optionally be prefixed with a\n     *   pipe (`|`) when chaining multiple transformation functions.\n     * @returns {function} The constructor for the transformation function\n     */\n    obj.get = function(name) {\n        if (name && name.substring(0,1) === '|') {\n            return parseTransString(name);\n        } else {\n            return parseTrans(name);\n        }\n    };\n    /**\n     * Internal logic that registers a transformation function\n     * @protected\n     * @param {String} name\n     * @param {function} fn\n     */\n    obj.set = function(name, fn) {\n        if (name.substring(0,1) === '|') {\n            throw new Error('transformation name should not start with a pipe');\n        } else {\n            if (fn) {\n                transformations[name] = fn;\n            } else {\n                delete transformations[name];\n            }\n        }\n    };\n\n    /**\n     * Register a transformation function\n     * @param {String} name\n     * @param {function} fn A transformation function (should accept one argument with the value)\n     */\n    obj.add = function(name, fn) {\n        if (transformations[name]) {\n            throw new Error('transformation already exists with name: ' + name);\n        } else {\n            obj.set(name, fn);\n        }\n    };\n    /**\n     * List the names of all registered transformation functions\n     * @returns {String[]}\n     */\n    obj.list = function() {\n        return Object.keys(transformations);\n    };\n\n    return obj;\n})();\n\n/**\n * Return the -log (base 10)\n * @function neglog10\n */\nLocusZoom.TransformationFunctions.add('neglog10', function(x) {\n    if (isNaN(x) || x <= 0) { return null; }\n    return -Math.log(x) / Math.LN10;\n});\n\n/**\n * Convert a number from logarithm to scientific notation. Useful for, eg, a datasource that returns -log(p) by default\n * @function logtoscinotation\n */\nLocusZoom.TransformationFunctions.add('logtoscinotation', function(x) {\n    if (isNaN(x)) { return 'NaN'; }\n    if (x === 0) { return '1'; }\n    var exp = Math.ceil(x);\n    var diff = exp - x;\n    var base = Math.pow(10, diff);\n    if (exp === 1) {\n        return (base / 10).toFixed(4);\n    } else if (exp === 2) {\n        return (base / 100).toFixed(3);\n    } else {\n        return base.toFixed(2) + '  10^-' + exp;\n    }\n});\n\n/**\n * Represent a number in scientific notation\n * @function scinotation\n * @param {Number} x\n * @returns {String}\n */\nLocusZoom.TransformationFunctions.add('scinotation', function(x) {\n    if (isNaN(x)) { return 'NaN'; }\n    if (x === 0) { return '0'; }\n\n    var abs = Math.abs(x);\n    var log;\n    if (abs > 1) {\n        log = Math.ceil(Math.log(abs) / Math.LN10);\n    } else {  // 0...1\n        log = Math.floor(Math.log(abs) / Math.LN10);\n    }\n    if (Math.abs(log) <= 3) {\n        return x.toFixed(3);\n    } else {\n        return x.toExponential(2).replace('+', '').replace('e', '  10^');\n    }\n});\n\n/**\n * URL-encode the provided text, eg for constructing hyperlinks\n * @function urlencode\n * @param {String} str\n */\nLocusZoom.TransformationFunctions.add('urlencode', function(str) {\n    return encodeURIComponent(str);\n});\n\n/**\n * HTML-escape user entered values for use in constructed HTML fragments\n *\n * For example, this filter can be used on tooltips with custom HTML display\n * @function htmlescape\n * @param {String} str HTML-escape the provided value\n */\nLocusZoom.TransformationFunctions.add('htmlescape', function(str) {\n    if ( !str ) {\n        return '';\n    }\n    str = str + '';\n\n    return str.replace( /['\"<>&`]/g, function( s ) {\n        switch ( s ) {\n        case \"'\":\n            return '&#039;';\n        case '\"':\n            return '&quot;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '&':\n            return '&amp;';\n        case '`':\n            return '&#x60;';\n        }\n    });\n});\n\n/**\n * Singleton for accessing/storing functions that will convert arbitrary data points to values in a given scale\n * Useful for anything that needs to scale discretely with data (e.g. color, point size, etc.)\n *\n * A Scale Function can be thought of as a modifier to a layout directive that adds extra logic to how a piece of data\n *   can be resolved to a value.\n *\n * All scale functions must accept an object of parameters and a value to process.\n * @class\n * @static\n */\nLocusZoom.ScaleFunctions = (function() {\n    /** @lends LocusZoom.ScaleFunctions */\n    var obj = {};\n    var functions = {};\n\n    /**\n     * Find a scale function and return it. If parameters and values are passed, calls the function directly; otherwise\n     *   returns a callable.\n     * @param {String} name\n     * @param {Object} [parameters] Configuration parameters specific to the specified scale function\n     * @param {*} [value] The value to operate on\n     * @returns {*}\n     */\n    obj.get = function(name, parameters, value) {\n        if (!name) {\n            return null;\n        } else if (functions[name]) {\n            if (typeof parameters === 'undefined' && typeof value === 'undefined') {\n                return functions[name];\n            } else {\n                return functions[name](parameters, value);\n            }\n        } else {\n            throw new Error('scale function [' + name + '] not found');\n        }\n    };\n\n    /**\n     * @protected\n     * @param {String} name The name of the function to set/unset\n     * @param {Function} [fn] The function to register. If blank, removes this function name from the registry.\n     */\n    obj.set = function(name, fn) {\n        if (fn) {\n            functions[name] = fn;\n        } else {\n            delete functions[name];\n        }\n    };\n\n    /**\n     * Add a new scale function to the registry\n     * @param {String} name The name of the scale function\n     * @param {function} fn A scale function that accepts two parameters: an object of configuration and a value\n     */\n    obj.add = function(name, fn) {\n        if (functions[name]) {\n            throw new Error('scale function already exists with name: ' + name);\n        } else {\n            obj.set(name, fn);\n        }\n    };\n\n    /**\n     * List the names of all registered scale functions\n     * @returns {String[]}\n     */\n    obj.list = function() {\n        return Object.keys(functions);\n    };\n\n    return obj;\n})();\n\n/**\n * Basic conditional function to evaluate the value of the input field and return based on equality.\n * @param {Object} parameters\n * @param {*} parameters.field_value The value against which to test the input value.\n * @param {*} parameters.then The value to return if the input value matches the field value\n * @param {*} parameters.else  The value to return if the input value does not match the field value. Optional. If not\n *   defined this scale function will return null (or value of null_value parameter, if defined) when input value fails\n *   to match field_value.\n * @param {*} input value\n */\nLocusZoom.ScaleFunctions.add('if', function(parameters, input) {\n    if (typeof input == 'undefined' || parameters.field_value !== input) {\n        if (typeof parameters.else != 'undefined') {\n            return parameters.else;\n        } else {\n            return null;\n        }\n    } else {\n        return parameters.then;\n    }\n});\n\n/**\n * Function to sort numerical values into bins based on numerical break points. Will only operate on numbers and\n *   return null (or value of null_value parameter, if defined) if provided a non-numeric input value. Parameters:\n * @function numerical_bin\n * @param {Object} parameters\n * @param {Number[]} parameters.breaks  Array of numerical break points against which to evaluate the input value.\n *   Must be of equal length to values parameter. If the input value is greater than or equal to break n and less than\n *   or equal to break n+1 (or break n+1 doesn't exist) then returned value is the nth entry in the values parameter.\n * @param {Array} parameters.values  Array of values to return given evaluations against break points. Must be of\n *   equal length to breaks parameter. Each entry n represents the value to return if the input value is greater than\n *   or equal to break n and less than or equal to break n+1 (or break n+1 doesn't exist).\n * @param {*} null_value\n * @param {*} input value\n * @returns\n */\nLocusZoom.ScaleFunctions.add('numerical_bin', function(parameters, input) {\n    var breaks = parameters.breaks || [];\n    var values = parameters.values || [];\n    if (typeof input == 'undefined' || input === null || isNaN(+input)) {\n        return (parameters.null_value ? parameters.null_value : null);\n    }\n    var threshold = breaks.reduce(function(prev, curr) {\n        if (+input < prev || (+input >= prev && +input < curr)) {\n            return prev;\n        } else {\n            return curr;\n        }\n    });\n    return values[breaks.indexOf(threshold)];\n});\n\n/**\n * Function to sort values of any type into bins based on direct equality testing with a list of categories.\n *   Will return null if provided an input value that does not match to a listed category.\n * @function categorical_bin\n * @param {Object} parameters\n * @param {Array} parameters.categories  Array of values against which to evaluate the input value. Must be of equal\n *   length to values parameter. If the input value is equal to category n then returned value is the nth entry in the\n *   values parameter.\n * @param {Array} parameters.values  Array of values to return given evaluations against categories. Must be of equal\n *   length to categories parameter. Each entry n represents the value to return if the input value is equal to the nth\n *   value in the categories parameter.\n * @param {*} parameters.null_value  Value to return if the input value fails to match to any categories. Optional.\n */\nLocusZoom.ScaleFunctions.add('categorical_bin', function(parameters, value) {\n    if (typeof value == 'undefined' || parameters.categories.indexOf(value) === -1) {\n        return (parameters.null_value ? parameters.null_value : null);\n    } else {\n        return parameters.values[parameters.categories.indexOf(value)];\n    }\n});\n\n/**\n * Function for continuous interpolation of numerical values along a gradient with arbitrarily many break points.\n * @function interpolate\n * @parameters {Object} parameters\n * @parameters {Number[]} parameters.breaks  Array of numerical break points against which to evaluate the input value.\n *   Must be of equal length to values parameter and contain at least two elements. Input value will be evaluated for\n *   relative position between two break points n and n+1 and the returned value will be interpolated at a relative\n *   position between values n and n+1.\n * @parameters {*[]} parameters.values  Array of values to interpolate and return given evaluations against break\n *   points. Must be of equal length to breaks parameter and contain at least two elements. Each entry n represents\n *   the value to return if the input value matches the nth entry in breaks exactly. Note that this scale function\n *   uses d3.interpolate to provide for effective interpolation of many different value types, including numbers,\n *   colors, shapes, etc.\n * @parameters {*} parameters.null_value\n */\nLocusZoom.ScaleFunctions.add('interpolate', function(parameters, input) {\n    var breaks = parameters.breaks || [];\n    var values = parameters.values || [];\n    var nullval = (parameters.null_value ? parameters.null_value : null);\n    if (breaks.length < 2 || breaks.length !== values.length) { return nullval; }\n    if (typeof input == 'undefined' || input === null || isNaN(+input)) { return nullval; }\n    if (+input <= parameters.breaks[0]) {\n        return values[0];\n    } else if (+input >= parameters.breaks[parameters.breaks.length - 1]) {\n        return values[breaks.length - 1];\n    } else {\n        var upper_idx = null;\n        breaks.forEach(function(brk, idx) {\n            if (!idx) { return; }\n            if (breaks[idx - 1] <= +input && breaks[idx] >= +input) { upper_idx = idx; }\n        });\n        if (upper_idx === null) { return nullval; }\n        var normalized_input = (+input - breaks[upper_idx - 1]) / (breaks[upper_idx] - breaks[upper_idx - 1]);\n        if (!isFinite(normalized_input)) { return nullval; }\n        return d3.interpolate(values[upper_idx - 1], values[upper_idx])(normalized_input);\n    }\n});\n","/* global LocusZoom */\n'use strict';\n\n/**\n * A data layer is an abstract class representing a data set and its graphical representation within a panel\n * @public\n * @class\n * @param {Object} layout A JSON-serializable object describing the layout for this layer\n * @param {LocusZoom.DataLayer|LocusZoom.Panel} parent Where this layout is used\n*/\nLocusZoom.DataLayer = function(layout, parent) {\n    /** @member {Boolean} */\n    this.initialized = false;\n    /** @member {Number} */\n    this.layout_idx = null;\n\n    /** @member {String} */\n    this.id     = null;\n    /** @member {LocusZoom.Panel} */\n    this.parent = parent || null;\n    /**\n     * @member {{group: d3.selection, container: d3.selection, clipRect: d3.selection}}\n     */\n    this.svg    = {};\n\n    /** @member {LocusZoom.Plot} */\n    this.parent_plot = null;\n    if (typeof parent != 'undefined' && parent instanceof LocusZoom.Panel) { this.parent_plot = parent.parent; }\n\n    /** @member {Object} */\n    this.layout = LocusZoom.Layouts.merge(layout || {}, LocusZoom.DataLayer.DefaultLayout);\n    if (this.layout.id) { this.id = this.layout.id; }\n\n    // Ensure any axes defined in the layout have an explicit axis number (default: 1)\n    if (this.layout.x_axis !== {} && typeof this.layout.x_axis.axis !== 'number') { this.layout.x_axis.axis = 1; }\n    if (this.layout.y_axis !== {} && typeof this.layout.y_axis.axis !== 'number') { this.layout.y_axis.axis = 1; }\n\n    /**\n     * Values in the layout object may change during rendering etc. Retain a copy of the original data layer state\n     * @member {Object}\n     */\n    this._base_layout = JSON.parse(JSON.stringify(this.layout));\n\n    /** @member {Object} */\n    this.state = {};\n    /** @member {String} */\n    this.state_id = null;\n\n    this.setDefaultState();\n\n    // Initialize parameters for storing data and tool tips\n    /** @member {Array} */\n    this.data = [];\n    if (this.layout.tooltip) {\n        /** @member {Object} */\n        this.tooltips = {};\n    }\n\n    // Initialize flags for tracking global statuses\n    this.global_statuses = {\n        'highlighted': false,\n        'selected': false,\n        'faded': false,\n        'hidden': false\n    };\n\n    return this;\n\n};\n\n/**\n * Instruct this datalayer to begin tracking additional fields from data sources (does not guarantee that such a field actually exists)\n *\n * Custom plots can use this to dynamically extend datalayer functionality after the plot is drawn\n *\n *  (since removing core fields may break layer functionality, there is presently no hook for the inverse behavior)\n * @param fieldName\n * @param namespace\n * @param {String|String[]} transformations The name (or array of names) of transformations to apply to this field\n * @returns {String} The raw string added to the fields array\n */\nLocusZoom.DataLayer.prototype.addField = function(fieldName, namespace, transformations) {\n    if (!fieldName || !namespace) {\n        throw new Error('Must specify field name and namespace to use when adding field');\n    }\n    var fieldString = namespace + ':' + fieldName;\n    if (transformations) {\n        fieldString += '|';\n        if (typeof transformations === 'string') {\n            fieldString += transformations;\n        } else if (Array.isArray(transformations)) {\n            fieldString += transformations.join('|');\n        } else {\n            throw new Error('Must provide transformations as either a string or array of strings');\n        }\n    }\n    var fields = this.layout.fields;\n    if (fields.indexOf(fieldString) === -1) {\n        fields.push(fieldString);\n    }\n    return fieldString;\n};\n\n/**\n * Define default state that should get tracked during the lifetime of this layer.\n *\n * In some special custom usages, it may be useful to completely reset a panel (eg \"click for\n *   genome region\" links), plotting new data that invalidates any previously tracked state.  This hook makes it\n *   possible to reset without destroying the panel entirely. It is used by `Plot.clearPanelData`.\n */\nLocusZoom.DataLayer.prototype.setDefaultState = function() {\n    // Define state parameters specific to this data layer. Within plot state, this will live under a key\n    //  `panel_name.layer_name`.\n    if (this.parent) {\n        this.state = this.parent.state;\n        this.state_id = this.parent.id + '.' + this.id;\n        this.state[this.state_id] = this.state[this.state_id] || {};\n        var layer_state = this.state[this.state_id];\n        LocusZoom.DataLayer.Statuses.adjectives.forEach(function(status) {\n            layer_state[status] = layer_state[status] || [];\n        });\n        // Also initialize \"internal-only\" state fields\n        layer_state['has_tooltip'] = layer_state['has_tooltip'] || [];\n    }\n};\n\n/**\n * A basic description of keys expected in a layout. Not intended to be directly used or modified by an end user.\n * @protected\n * @type {{type: string, fields: Array, x_axis: {}, y_axis: {}}}\n */\nLocusZoom.DataLayer.DefaultLayout = {\n    type: '',\n    fields: [],\n    x_axis: {},\n    y_axis: {}\n};\n\n/**\n * Available statuses that individual elements can have. Each status is described by\n *   a verb/antiverb and an adjective. Verbs and antiverbs are used to generate data layer\n *   methods for updating the status on one or more elements. Adjectives are used in class\n *   names and applied or removed from elements to have a visual representation of the status,\n *   as well as used as keys in the state for tracking which elements are in which status(es)\n * @static\n * @type {{verbs: String[], adjectives: String[], menu_antiverbs: String[]}}\n */\nLocusZoom.DataLayer.Statuses = {\n    verbs: ['highlight', 'select', 'fade', 'hide'],\n    adjectives: ['highlighted', 'selected', 'faded', 'hidden'],\n    menu_antiverbs: ['unhighlight', 'deselect', 'unfade', 'show']\n};\n\n/**\n * Get the fully qualified identifier for the data layer, prefixed by any parent or container elements\n *\n * @returns {string} A dot-delimited string of the format <plot>.<panel>.<data_layer>\n */\nLocusZoom.DataLayer.prototype.getBaseId = function() {\n    return this.parent_plot.id + '.' + this.parent.id + '.' + this.id;\n};\n\n/**\n * Determine the pixel height of data-bound objects represented inside this data layer. (excluding elements such as axes)\n *\n * May be used by operations that resize the data layer to fit available data\n *\n * @public\n * @returns {number}\n */\nLocusZoom.DataLayer.prototype.getAbsoluteDataHeight = function() {\n    var dataBCR = this.svg.group.node().getBoundingClientRect();\n    return dataBCR.height;\n};\n\n/**\n * Whether transitions can be applied to this data layer\n * @returns {boolean}\n */\nLocusZoom.DataLayer.prototype.canTransition = function() {\n    if (!this.layout.transition) { return false; }\n    return !(this.parent_plot.panel_boundaries.dragging || this.parent_plot.interaction.panel_id);\n};\n\n/**\n * Fetch the fully qualified ID to be associated with a specific visual element, based on the data to which that\n *   element is bound. In general this element ID will be unique, allowing it to be addressed directly via selectors.\n * @param {String|Object} element\n * @returns {String}\n */\nLocusZoom.DataLayer.prototype.getElementId = function(element) {\n    var element_id = 'element';\n    if (typeof element == 'string') {\n        element_id = element;\n    } else if (typeof element == 'object') {\n        var id_field = this.layout.id_field || 'id';\n        if (typeof element[id_field] == 'undefined') {\n            throw new Error('Unable to generate element ID');\n        }\n        element_id = element[id_field].toString().replace(/\\W/g,'');\n    }\n    return (this.getBaseId() + '-' + element_id).replace(/([:.[\\],])/g, '_');\n};\n\n/**\n * Fetch an ID that may bind a data element to a separate visual node for displaying status\n * Examples of this might be seperate visual nodes to show select/highlight statuses, or\n * even a common/shared node to show status across many elements in a set.\n * Abstract method. It should be overridden by data layers that implement seperate status\n * nodes specifically to the use case of the data layer type.\n * @param {String|Object} element\n * @returns {String|null}\n */\nLocusZoom.DataLayer.prototype.getElementStatusNodeId = function(element) {\n    return null;\n};\n\n/**\n * Returns a reference to the underlying data associated with a single visual element in the data layer, as\n *   referenced by the unique identifier for the element\n\n * @param {String} id The unique identifier for the element, as defined by `getElementId`\n * @returns {Object|null} The data bound to that element\n */\nLocusZoom.DataLayer.prototype.getElementById = function(id) {\n    var selector = d3.select('#' + id.replace(/([:.[\\],])/g, '\\\\$1')); // escape special characters\n    if (!selector.empty() && selector.data() && selector.data().length) {\n        return selector.data()[0];\n    } else {\n        return null;\n    }\n};\n\n/**\n * Basic method to apply arbitrary methods and properties to data elements.\n *   This is called on all data immediately after being fetched.\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.DataLayer.prototype.applyDataMethods = function() {\n    var field_to_match = (this.layout.match && this.layout.match.receive);\n    var broadcast_value = this.parent_plot.state.lz_match_value;\n\n    this.data.forEach(function(d, i) {\n        // Basic toHTML() method - return the stringified value in the id_field, if defined.\n\n        // When this layer receives data, mark whether points match (via a synthetic boolean field)\n        //   Any field-based layout directives (color, size, shape) can then be used to control display\n        if (field_to_match && broadcast_value !== null && broadcast_value !== undefined) {\n            d.lz_highlight_match = (d[field_to_match] === broadcast_value);\n        }\n\n        this.data[i].toHTML = function() {\n            var id_field = this.layout.id_field || 'id';\n            var html = '';\n            if (this.data[i][id_field]) { html = this.data[i][id_field].toString(); }\n            return html;\n        }.bind(this);\n        // getDataLayer() method - return a reference to the data layer\n        this.data[i].getDataLayer = function() {\n            return this;\n        }.bind(this);\n        // deselect() method - shortcut method to deselect the element\n        this.data[i].deselect = function() {\n            var data_layer = this.getDataLayer();\n            data_layer.unselectElement(this);\n        };\n    }.bind(this));\n    this.applyCustomDataMethods();\n    return this;\n};\n\n/**\n * Hook that allows custom datalayers to apply additional methods and properties to data elements as needed\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.DataLayer.prototype.applyCustomDataMethods = function() {\n    return this;\n};\n\n/**\n * Initialize a data layer\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.DataLayer.prototype.initialize = function() {\n\n    // Append a container group element to house the main data layer group element and the clip path\n    this.svg.container = this.parent.svg.group.append('g')\n        .attr('class', 'lz-data_layer-container')\n        .attr('id', this.getBaseId() + '.data_layer_container');\n\n    // Append clip path to the container element\n    this.svg.clipRect = this.svg.container.append('clipPath')\n        .attr('id', this.getBaseId() + '.clip')\n        .append('rect');\n\n    // Append svg group for rendering all data layer elements, clipped by the clip path\n    this.svg.group = this.svg.container.append('g')\n        .attr('id', this.getBaseId() + '.data_layer')\n        .attr('clip-path', 'url(#' + this.getBaseId() + '.clip)');\n\n    return this;\n\n};\n\n/**\n * Move a data layer up relative to others by z-index\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.DataLayer.prototype.moveUp = function() {\n    if (this.parent.data_layer_ids_by_z_index[this.layout.z_index + 1]) {\n        this.parent.data_layer_ids_by_z_index[this.layout.z_index] = this.parent.data_layer_ids_by_z_index[this.layout.z_index + 1];\n        this.parent.data_layer_ids_by_z_index[this.layout.z_index + 1] = this.id;\n        this.parent.resortDataLayers();\n    }\n    return this;\n};\n\n/**\n * Move a data layer down relative to others by z-index\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.DataLayer.prototype.moveDown = function() {\n    if (this.parent.data_layer_ids_by_z_index[this.layout.z_index - 1]) {\n        this.parent.data_layer_ids_by_z_index[this.layout.z_index] = this.parent.data_layer_ids_by_z_index[this.layout.z_index - 1];\n        this.parent.data_layer_ids_by_z_index[this.layout.z_index - 1] = this.id;\n        this.parent.resortDataLayers();\n    }\n    return this;\n};\n\n/**\n * Apply scaling functions to an element or parameter as needed, based on its layout and the element's data\n * If the layout parameter is already a primitive type, simply return the value as given\n * @param {Array|Number|String|Object} layout\n * @param {*} data The value to be used with the filter\n * @returns {*} The transformed value\n */\nLocusZoom.DataLayer.prototype.resolveScalableParameter = function(layout, data) {\n    var ret = null;\n    if (Array.isArray(layout)) {\n        var idx = 0;\n        while (ret === null && idx < layout.length) {\n            ret = this.resolveScalableParameter(layout[idx], data);\n            idx++;\n        }\n    } else {\n        switch (typeof layout) {\n        case 'number':\n        case 'string':\n            ret = layout;\n            break;\n        case 'object':\n            if (layout.scale_function) {\n                if(layout.field) {\n                    var f = new LocusZoom.Data.Field(layout.field);\n                    ret = LocusZoom.ScaleFunctions.get(layout.scale_function, layout.parameters || {}, f.resolve(data));\n                } else {\n                    ret = LocusZoom.ScaleFunctions.get(layout.scale_function, layout.parameters || {}, data);\n                }\n            }\n            break;\n        }\n    }\n    return ret;\n};\n\n\n/**\n * Implementation hook for fetching the min and max values of available data. Used to determine axis range, if no other\n *   explicit axis settings override. Useful for data layers where the data extent depends on more than one field.\n *   (eg confidence intervals in a forest plot)\n * @param data\n * @param axis_config The configuration object for the specified axis.\n * @returns {Array} [min, max] without any padding applied\n * @private\n */\nLocusZoom.DataLayer.prototype._getDataExtent = function(data, axis_config) {\n    data = data || this.data;\n    // By default this depends only on a single field.\n    return d3.extent(data, function (d) {\n        var f = new LocusZoom.Data.Field(axis_config.field);\n        return +f.resolve(d);\n    });\n};\n\n/**\n * Generate dimension extent function based on layout parameters\n * @param {('x'|'y')} dimension\n */\nLocusZoom.DataLayer.prototype.getAxisExtent = function(dimension) {\n\n    if (['x', 'y'].indexOf(dimension) === -1) {\n        throw new Error('Invalid dimension identifier passed to LocusZoom.DataLayer.getAxisExtent()');\n    }\n\n    var axis_name = dimension + '_axis';\n    var axis_layout = this.layout[axis_name];\n\n    // If a floor AND a ceiling are explicitly defined then just return that extent and be done\n    if (!isNaN(axis_layout.floor) && !isNaN(axis_layout.ceiling)) {\n        return [+axis_layout.floor, +axis_layout.ceiling];\n    }\n\n    // If a field is defined for the axis and the data layer has data then generate the extent from the data set\n    var data_extent = [];\n    if (axis_layout.field && this.data) {\n        if (!this.data.length) {\n            // If data has been fetched (but no points in region), enforce the min_extent (with no buffers,\n            //  because we don't need padding around an empty screen)\n            data_extent = axis_layout.min_extent || [];\n            return data_extent;\n        } else {\n            data_extent = this._getDataExtent(this.data, axis_layout);\n\n            // Apply upper/lower buffers, if applicable\n            var original_extent_span = data_extent[1] - data_extent[0];\n            if (!isNaN(axis_layout.lower_buffer)) {\n                data_extent[0] -= original_extent_span * axis_layout.lower_buffer;\n            }\n            if (!isNaN(axis_layout.upper_buffer)) {\n                data_extent[1] += original_extent_span * axis_layout.upper_buffer;\n            }\n\n            if (typeof axis_layout.min_extent == 'object') {\n                // The data should span at least the range specified by min_extent, an array with [low, high]\n                var range_min = axis_layout.min_extent[0];\n                var range_max = axis_layout.min_extent[1];\n                if (!isNaN(range_min) && !isNaN(range_max)) {\n                    data_extent[0] = Math.min(data_extent[0], range_min);\n                }\n                if (!isNaN(range_max)) {\n                    data_extent[1] = Math.max(data_extent[1], range_max);\n                }\n            }\n            // If specified, floor and ceiling will override the actual data range\n            return [\n                isNaN(axis_layout.floor) ? data_extent[0] : axis_layout.floor,\n                isNaN(axis_layout.ceiling) ? data_extent[1] : axis_layout.ceiling\n            ];\n        }\n    }\n\n    // If this is for the x axis and no extent could be generated yet but state has a defined start and end\n    // then default to using the state-defined region as the extent\n    if (dimension === 'x' && !isNaN(this.state.start) && !isNaN(this.state.end)) {\n        return [this.state.start, this.state.end];\n    }\n\n    // No conditions met for generating a valid extent, return an empty array\n    return [];\n\n};\n\n/**\n * Allow this data layer to tell the panel what axis ticks it thinks it will require. The panel may choose whether\n *   to use some, all, or none of these when rendering, either alone or in conjunction with other data layers.\n *\n *   This method is a stub and should be overridden in data layers that need to specify custom behavior.\n *\n * @param {('x'|'y1'|'y2')} dimension\n * @param {Object} [config] Additional parameters for the panel to specify how it wants ticks to be drawn. The names\n *   and meanings of these parameters may vary between different data layers.\n * @returns {Object[]}\n *   An array of objects: each object must have an 'x' attribute to position the tick.\n *   Other supported object keys:\n *     * text: string to render for a given tick\n *     * style: d3-compatible CSS style object\n *     * transform: SVG transform attribute string\n *     * color: string or LocusZoom scalable parameter object\n */\nLocusZoom.DataLayer.prototype.getTicks = function (dimension, config) {\n    if (['x', 'y1', 'y2'].indexOf(dimension) === -1) {\n        throw new Error('Invalid dimension identifier at layer level' + dimension);\n    }\n    return [];\n};\n\n/**\n * Generate a tool tip for a given element\n * @param {String|Object} data Data for the element associated with the tooltip\n */\nLocusZoom.DataLayer.prototype.createTooltip = function(data) {\n    if (typeof this.layout.tooltip != 'object') {\n        throw new Error('DataLayer [' + this.id + '] layout does not define a tooltip');\n    }\n    var id = this.getElementId(data);\n    if (this.tooltips[id]) {\n        this.positionTooltip(id);\n        return;\n    }\n    this.tooltips[id] = {\n        data: data,\n        arrow: null,\n        selector: d3.select(this.parent_plot.svg.node().parentNode).append('div')\n            .attr('class', 'lz-data_layer-tooltip')\n            .attr('id', id + '-tooltip')\n    };\n    this.state[this.state_id]['has_tooltip'].push(id);\n    this.updateTooltip(data);\n    return this;\n};\n\n/**\n * Update a tool tip (generate its inner HTML)\n * @param {String|Object} d The element associated with the tooltip\n * @param {String} [id] An identifier to the tooltip\n */\nLocusZoom.DataLayer.prototype.updateTooltip = function(d, id) {\n    if (typeof id == 'undefined') { id = this.getElementId(d); }\n    // Empty the tooltip of all HTML (including its arrow!)\n    this.tooltips[id].selector.html('');\n    this.tooltips[id].arrow = null;\n    // Set the new HTML\n    if (this.layout.tooltip.html) {\n        this.tooltips[id].selector.html(LocusZoom.parseFields(d, this.layout.tooltip.html));\n    }\n    // If the layout allows tool tips on this data layer to be closable then add the close button\n    // and add padding to the tooltip to accommodate it\n    if (this.layout.tooltip.closable) {\n        this.tooltips[id].selector.insert('button', ':first-child')\n            .attr('class', 'lz-tooltip-close-button')\n            .attr('title', 'Close')\n            .text('')\n            .on('click', function() {\n                this.destroyTooltip(id);\n            }.bind(this));\n    }\n    // Apply data directly to the tool tip for easier retrieval by custom UI elements inside the tool tip\n    this.tooltips[id].selector.data([d]);\n    // Reposition and draw a new arrow\n    this.positionTooltip(id);\n    return this;\n};\n\n/**\n * Destroy tool tip - remove the tool tip element from the DOM and delete the tool tip's record on the data layer\n * @param {String|Object} element_or_id The element (or id) associated with the tooltip\n * @param {boolean} [temporary=false] Whether this is temporary (not to be tracked in state). Differentiates\n *  \"recreate tooltips on re-render\" (which is temporary) from \"user has closed this tooltip\" (permanent)\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.DataLayer.prototype.destroyTooltip = function(element_or_id, temporary) {\n    var id;\n    if (typeof element_or_id == 'string') {\n        id = element_or_id;\n    } else {\n        id = this.getElementId(element_or_id);\n    }\n    if (this.tooltips[id]) {\n        if (typeof this.tooltips[id].selector == 'object') {\n            this.tooltips[id].selector.remove();\n        }\n        delete this.tooltips[id];\n    }\n    // When a tooltip is removed, also remove the reference from the state\n    if (!temporary) {\n        var state = this.state[this.state_id]['has_tooltip'];\n        var label_mark_position = state.indexOf(id);\n        state.splice(label_mark_position, 1);\n    }\n    return this;\n};\n\n/**\n * Loop through and destroy all tool tips on this data layer\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.DataLayer.prototype.destroyAllTooltips = function() {\n    for (var id in this.tooltips) {\n        this.destroyTooltip(id, true);\n    }\n    return this;\n};\n\n//\n/**\n * Position tool tip - nave function to place a tool tip to the lower right of the current mouse element\n *   Most data layers reimplement this method to position tool tips specifically for the data they display\n * @param {String} id The identifier of the tooltip to position\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.DataLayer.prototype.positionTooltip = function(id) {\n    if (typeof id != 'string') {\n        throw new Error('Unable to position tooltip: id is not a string');\n    }\n    // Position the div itself\n    this.tooltips[id].selector\n        .style('left', (d3.event.pageX) + 'px')\n        .style('top', (d3.event.pageY) + 'px');\n    // Create / update position on arrow connecting tooltip to data\n    if (!this.tooltips[id].arrow) {\n        this.tooltips[id].arrow = this.tooltips[id].selector.append('div')\n            .style('position', 'absolute')\n            .attr('class', 'lz-data_layer-tooltip-arrow_top_left');\n    }\n    this.tooltips[id].arrow\n        .style('left', '-1px')\n        .style('top', '-1px');\n    return this;\n};\n\n/**\n * Loop through and position all tool tips on this data layer\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.DataLayer.prototype.positionAllTooltips = function() {\n    for (var id in this.tooltips) {\n        this.positionTooltip(id);\n    }\n    return this;\n};\n\n/**\n * Show or hide a tool tip by ID depending on directives in the layout and state values relative to the ID\n * @param {String|Object} element The element associated with the tooltip\n * @param {boolean} first_time Because panels can re-render, the rules for showing a tooltip\n *  depend on whether this is the first time a status change affecting display has been applied.\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.DataLayer.prototype.showOrHideTooltip = function(element, first_time) {\n    if (typeof this.layout.tooltip != 'object') { return; }\n    var id = this.getElementId(element);\n\n    /**\n     * Apply rules and decide whether to show or hide the tooltip\n     * @param {Object} statuses All statuses that apply to an element\n     * @param {String[]|object} directive A layout directive object\n     * @param operator\n     * @returns {null|bool}\n     */\n    var resolveStatus = function(statuses, directive, operator) {\n        var status = null;\n        if (typeof statuses != 'object' || statuses === null) { return null; }\n        if (Array.isArray(directive)) {\n            // This happens when the function is called on the inner part of the directive\n            operator = operator || 'and';\n            if (directive.length === 1) {\n                status = statuses[directive[0]];\n            } else {\n                status = directive.reduce(function(previousValue, currentValue) {\n                    if (operator === 'and') {\n                        return statuses[previousValue] && statuses[currentValue];\n                    } else if (operator === 'or') {\n                        return statuses[previousValue] || statuses[currentValue];\n                    }\n                    return null;\n                });\n            }\n        } else if (typeof directive == 'object') {\n            var sub_status;\n            for (var sub_operator in directive) {\n                sub_status = resolveStatus(statuses, directive[sub_operator], sub_operator);\n                if (status === null) {\n                    status = sub_status;\n                } else if (operator === 'and') {\n                    status = status && sub_status;\n                } else if (operator === 'or') {\n                    status = status || sub_status;\n                }\n            }\n        } else {\n            return false;\n        }\n        return status;\n    };\n\n    var show_directive = {};\n    if (typeof this.layout.tooltip.show == 'string') {\n        show_directive = { and: [ this.layout.tooltip.show ] };\n    } else if (typeof this.layout.tooltip.show == 'object') {\n        show_directive = this.layout.tooltip.show;\n    }\n\n    var hide_directive = {};\n    if (typeof this.layout.tooltip.hide == 'string') {\n        hide_directive = { and: [ this.layout.tooltip.hide ] };\n    } else if (typeof this.layout.tooltip.hide == 'object') {\n        hide_directive = this.layout.tooltip.hide;\n    }\n\n    // Find all the statuses that apply to just this single element\n    var layer_state = this.state[this.state_id];\n    var statuses = {};  // {status_name: bool}\n    LocusZoom.DataLayer.Statuses.adjectives.forEach(function(status) {\n        var antistatus = 'un' + status;\n        statuses[status] = (layer_state[status].indexOf(id) !== -1);\n        statuses[antistatus] = !statuses[status];\n    });\n\n    // Decide whether to show/hide the tooltip based solely on the underlying element\n    var show_resolved = resolveStatus(statuses, show_directive);\n    var hide_resolved = resolveStatus(statuses, hide_directive);\n\n    // Most of the tooltip display logic depends on behavior layouts: was point (un)selected, (un)highlighted, etc.\n    // But sometimes, a point is selected, and the user then closes the tooltip. If the panel is re-rendered for\n    //  some outside reason (like state change), we must track this in the create/destroy events as tooltip state.\n    var has_tooltip = (layer_state['has_tooltip'].indexOf(id) !== -1);\n    var tooltip_was_closed = first_time ? false : !has_tooltip;\n    if (show_resolved && !tooltip_was_closed && !hide_resolved) {\n        this.createTooltip(element);\n    } else {\n        this.destroyTooltip(element);\n    }\n\n    return this;\n};\n\n/**\n * Find the elements (or indices) that match any of a set of provided filters\n * @protected\n * @param {Array[]} filters A list of filter entries: [field, value] (for equivalence testing) or\n *   [field, operator, value] for other operators\n * @param {('indexes'|'elements')} [return_type='indexes'] Specify whether to return either the indices of the matching\n *   elements, or references to the elements themselves\n * @returns {Array}\n */\nLocusZoom.DataLayer.prototype.filter = function(filters, return_type) {\n    if (typeof return_type == 'undefined' || ['indexes','elements'].indexOf(return_type) === -1) {\n        return_type = 'indexes';\n    }\n    if (!Array.isArray(filters)) { return []; }\n    var test = function(element, filter) {\n        var operators = {\n            '=': function(a,b) { return a === b; },\n            // eslint-disable-next-line eqeqeq\n            '!=': function(a,b) { return a != b; }, // For absence of a value, deliberately allow weak comparisons (eg undefined/null)\n            '<': function(a,b) { return a < b; },\n            '<=': function(a,b) { return a <= b; },\n            '>': function(a,b) { return a > b; },\n            '>=': function(a,b) { return a >= b; },\n            '%': function(a,b) { return a % b; }\n        };\n        if (!Array.isArray(filter)) { return false; }\n        if (filter.length === 2) {\n            return element[filter[0]] === filter[1];\n        } else if (filter.length === 3 && operators[filter[1]]) {\n            return operators[filter[1]](element[filter[0]], filter[2]);\n        } else {\n            return false;\n        }\n    };\n    var matches = [];\n    this.data.forEach(function(element, idx) {\n        var match = true;\n        filters.forEach(function(filter) {\n            if (!test(element, filter)) { match = false; }\n        });\n        if (match) { matches.push(return_type === 'indexes' ? idx : element); }\n    });\n    return matches;\n};\n\n/**\n * @param filters\n * @returns {Array}\n */\nLocusZoom.DataLayer.prototype.filterIndexes = function(filters) { return this.filter(filters, 'indexes'); };\n/**\n * @param filters\n * @returns {Array}\n */\nLocusZoom.DataLayer.prototype.filterElements = function(filters) { return this.filter(filters, 'elements'); };\n\nLocusZoom.DataLayer.Statuses.verbs.forEach(function(verb, idx) {\n    var adjective = LocusZoom.DataLayer.Statuses.adjectives[idx];\n    var antiverb = 'un' + verb;\n    // Set/unset a single element's status\n    // TODO: Improve documentation for dynamically generated methods/properties\n    LocusZoom.DataLayer.prototype[verb + 'Element'] = function(element, exclusive) {\n        if (typeof exclusive == 'undefined') { exclusive = false; } else { exclusive = !!exclusive; }\n        this.setElementStatus(adjective, element, true, exclusive);\n        return this;\n    };\n    LocusZoom.DataLayer.prototype[antiverb + 'Element'] = function(element, exclusive) {\n        if (typeof exclusive == 'undefined') { exclusive = false; } else { exclusive = !!exclusive; }\n        this.setElementStatus(adjective, element, false, exclusive);\n        return this;\n    };\n    // Set/unset status for arbitrarily many elements given a set of filters\n    LocusZoom.DataLayer.prototype[verb + 'ElementsByFilters'] = function(filters, exclusive) {\n        if (typeof exclusive == 'undefined') { exclusive = false; } else { exclusive = !!exclusive; }\n        return this.setElementStatusByFilters(adjective, true, filters, exclusive);\n    };\n    LocusZoom.DataLayer.prototype[antiverb + 'ElementsByFilters'] = function(filters, exclusive) {\n        if (typeof exclusive == 'undefined') { exclusive = false; } else { exclusive = !!exclusive; }\n        return this.setElementStatusByFilters(adjective, false, filters, exclusive);\n    };\n    // Set/unset status for all elements\n    LocusZoom.DataLayer.prototype[verb + 'AllElements'] = function() {\n        this.setAllElementStatus(adjective, true);\n        return this;\n    };\n    LocusZoom.DataLayer.prototype[antiverb + 'AllElements'] = function() {\n        this.setAllElementStatus(adjective, false);\n        return this;\n    };\n});\n\n/**\n * Toggle a status (e.g. highlighted, selected, identified) on an element\n * @param {String} status The name of a recognized status to be added/removed on an appropriate element\n * @param {String|Object} element The data bound to the element of interest\n * @param {Boolean} active True to add the status (and associated CSS styles); false to remove it\n * @param {Boolean} exclusive Whether to only allow a state for a single element at a time\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.DataLayer.prototype.setElementStatus = function(status, element, active, exclusive) {\n    if (status === 'has_tooltip') {\n        // This is a special adjective that exists solely to track tooltip state. It has no CSS and never gets set\n        //  directly. It is invisible to the official enums.\n        return this;\n    }\n\n    // Sanity checks\n    if (typeof status == 'undefined' || LocusZoom.DataLayer.Statuses.adjectives.indexOf(status) === -1) {\n        throw new Error('Invalid status passed to DataLayer.setElementStatus()');\n    }\n    if (typeof element == 'undefined') {\n        throw new Error('Invalid element passed to DataLayer.setElementStatus()');\n    }\n    if (typeof active == 'undefined') {\n        active = true;\n    }\n\n    // Get an ID for the element or return having changed nothing\n    try {\n        var element_id = this.getElementId(element);\n    } catch (get_element_id_error) {\n        return this;\n    }\n\n    // Enforce exclusivity (force all elements to have the opposite of toggle first)\n    if (exclusive) {\n        this.setAllElementStatus(status, !active);\n    }\n\n    // Set/unset the proper status class on the appropriate DOM element(s)\n    d3.select('#' + element_id).classed('lz-data_layer-' + this.layout.type + '-' + status, active);\n    var element_status_node_id = this.getElementStatusNodeId(element);\n    if (element_status_node_id !== null) {\n        d3.select('#' + element_status_node_id).classed('lz-data_layer-' + this.layout.type + '-statusnode-' + status, active);\n    }\n\n    // Track element ID in the proper status state array\n    var element_status_idx = this.state[this.state_id][status].indexOf(element_id);\n    var added_status = (element_status_idx === -1);  // On a re-render, existing statuses will be reapplied.\n    if (active && added_status) {\n        this.state[this.state_id][status].push(element_id);\n    }\n    if (!active && !added_status) {\n        this.state[this.state_id][status].splice(element_status_idx, 1);\n    }\n\n    // Trigger tool tip show/hide logic\n    this.showOrHideTooltip(element, added_status);\n\n    // Trigger layout changed event hook\n    if (added_status) {\n        this.parent.emit('layout_changed', true);\n    }\n\n    var is_selected =  (status === 'selected');\n    if (is_selected && (added_status || !active)) {\n        // Notify parents that an element has changed selection status (either active, or inactive)\n        this.parent.emit('element_selection', { element: element, active: active }, true);\n    }\n\n    var value_to_broadcast = (this.layout.match && this.layout.match.send);\n    if (is_selected && value_to_broadcast && (added_status || !active)) {\n        this.parent.emit(\n            'match_requested',\n            { value: element[value_to_broadcast], active: active },\n            true\n        );\n    }\n    return this;\n};\n\n/**\n * Toggle a status on elements in the data layer based on a set of filters\n * @param {String} status\n * @param {Boolean} toggle\n * @param {Array} filters\n * @param {Boolean} exclusive\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.DataLayer.prototype.setElementStatusByFilters = function(status, toggle, filters, exclusive) {\n\n    // Sanity check\n    if (typeof status == 'undefined' || LocusZoom.DataLayer.Statuses.adjectives.indexOf(status) === -1) {\n        throw new Error('Invalid status passed to DataLayer.setElementStatusByFilters()');\n    }\n    if (typeof this.state[this.state_id][status] == 'undefined') { return this; }\n    if (typeof toggle == 'undefined') { toggle = true; } else { toggle = !!toggle; }\n    if (typeof exclusive == 'undefined') { exclusive = false; } else { exclusive = !!exclusive; }\n    if (!Array.isArray(filters)) { filters = []; }\n\n    // Enforce exclusivity (force all elements to have the opposite of toggle first)\n    if (exclusive) {\n        this.setAllElementStatus(status, !toggle);\n    }\n\n    // Apply statuses\n    this.filterElements(filters).forEach(function(element) {\n        this.setElementStatus(status, element, toggle);\n    }.bind(this));\n\n    return this;\n};\n\n/**\n * Toggle a status on all elements in the data layer\n * @param {String} status\n * @param {Boolean} toggle\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.DataLayer.prototype.setAllElementStatus = function(status, toggle) {\n\n    // Sanity check\n    if (typeof status == 'undefined' || LocusZoom.DataLayer.Statuses.adjectives.indexOf(status) === -1) {\n        throw new Error('Invalid status passed to DataLayer.setAllElementStatus()');\n    }\n    if (typeof this.state[this.state_id][status] == 'undefined') { return this; }\n    if (typeof toggle == 'undefined') { toggle = true; }\n\n    // Apply statuses\n    if (toggle) {\n        this.data.forEach(function(element) {\n            this.setElementStatus(status, element, true);\n        }.bind(this));\n    } else {\n        var status_ids = this.state[this.state_id][status].slice();\n        status_ids.forEach(function(id) {\n            var element = this.getElementById(id);\n            if (typeof element == 'object' && element !== null) {\n                this.setElementStatus(status, element, false);\n            }\n        }.bind(this));\n        this.state[this.state_id][status] = [];\n    }\n\n    // Update global status flag\n    this.global_statuses[status] = toggle;\n\n    return this;\n};\n\n/**\n * Apply all layout-defined behaviors (DOM event handlers) to a selection of elements\n * @param {d3.selection} selection\n */\nLocusZoom.DataLayer.prototype.applyBehaviors = function(selection) {\n    if (typeof this.layout.behaviors != 'object') { return; }\n    Object.keys(this.layout.behaviors).forEach(function(directive) {\n        var event_match = /(click|mouseover|mouseout)/.exec(directive);\n        if (!event_match) { return; }\n        selection.on(event_match[0] + '.' + directive, this.executeBehaviors(directive, this.layout.behaviors[directive]));\n    }.bind(this));\n};\n\n/**\n * Generate a function that executes an arbitrary list of behaviors on an element during an event\n * @param {String} directive The name of the event, as described in layout.behaviors for this datalayer\n * @param {Object} behaviors An object describing the behavior to attach to this single element\n * @param {string} behaviors.action The name of the action that would trigger this behavior (eg click, mouseover, etc)\n * @param {string} behaviors.status What status to apply to the element when this behavior is triggered (highlighted,\n *  selected, etc)\n * @param {string} [behaviors.exclusive] Whether triggering the event for this element should unset the relevant status\n *   for all other elements. Useful for, eg, click events that exclusively highlight one thing.\n * @returns {function(this:LocusZoom.DataLayer)} Return a function that handles the event in context with the behavior\n *   and the element- can be attached as an event listener\n */\nLocusZoom.DataLayer.prototype.executeBehaviors = function(directive, behaviors) {\n\n    // Determine the required state of control and shift keys during the event\n    var requiredKeyStates = {\n        'ctrl': (directive.indexOf('ctrl') !== -1),\n        'shift': (directive.indexOf('shift') !== -1)\n    };\n\n    return function(element) {\n\n        // Do nothing if the required control and shift key presses (or lack thereof) doesn't match the event\n        if (requiredKeyStates.ctrl !== !!d3.event.ctrlKey || requiredKeyStates.shift !== !!d3.event.shiftKey) { return; }\n\n        // Loop through behaviors making each one go in succession\n        behaviors.forEach(function(behavior) {\n\n            // Route first by the action, if defined\n            if (typeof behavior != 'object' || behavior === null) { return; }\n\n            switch (behavior.action) {\n\n            // Set a status (set to true regardless of current status, optionally with exclusivity)\n            case 'set':\n                this.setElementStatus(behavior.status, element, true, behavior.exclusive);\n                break;\n\n            // Unset a status (set to false regardless of current status, optionally with exclusivity)\n            case 'unset':\n                this.setElementStatus(behavior.status, element, false, behavior.exclusive);\n                break;\n\n            // Toggle a status\n            case 'toggle':\n                var current_status_boolean = (this.state[this.state_id][behavior.status].indexOf(this.getElementId(element)) !== -1);\n                var exclusive = behavior.exclusive && !current_status_boolean;\n                this.setElementStatus(behavior.status, element, !current_status_boolean, exclusive);\n                break;\n\n            // Link to a dynamic URL\n            case 'link':\n                if (typeof behavior.href == 'string') {\n                    var url = LocusZoom.parseFields(element, behavior.href);\n                    if (typeof behavior.target == 'string') {\n                        window.open(url, behavior.target);\n                    } else {\n                        window.location.href = url;\n                    }\n                }\n                break;\n\n            // Action not defined, just return\n            default:\n                break;\n\n            }\n\n            return;\n\n        }.bind(this));\n\n    }.bind(this);\n\n};\n\n/**\n * Get an object with the x and y coordinates of the panel's origin in terms of the entire page\n *   Necessary for positioning any HTML elements over the panel\n * @returns {{x: Number, y: Number}}\n */\nLocusZoom.DataLayer.prototype.getPageOrigin = function() {\n    var panel_origin = this.parent.getPageOrigin();\n    return {\n        x: panel_origin.x + this.parent.layout.margin.left,\n        y: panel_origin.y + this.parent.layout.margin.top\n    };\n};\n\n/**\n * Get a data layer's current underlying data in a standard format (e.g. JSON or CSV)\n * @param {('csv'|'tsv'|'json')} format How to export the data\n * @returns {*}\n */\nLocusZoom.DataLayer.prototype.exportData = function(format) {\n    var default_format = 'json';\n    format = format || default_format;\n    format = (typeof format == 'string' ? format.toLowerCase() : default_format);\n    if (['json','csv','tsv'].indexOf(format) === -1) { format = default_format; }\n    var ret;\n    switch (format) {\n    case 'json':\n        try {\n            ret = JSON.stringify(this.data);\n        } catch (e) {\n            ret = null;\n            console.warn('Unable to export JSON data from data layer: ' + this.getBaseId());\n            console.error(e);\n        }\n        break;\n    case 'tsv':\n    case 'csv':\n        try {\n            var jsonified = JSON.parse(JSON.stringify(this.data));\n            if (typeof jsonified != 'object') {\n                ret = jsonified.toString();\n            } else if (!Array.isArray(jsonified)) {\n                ret = 'Object';\n            } else {\n                var delimiter = (format === 'tsv') ? '\\t' : ',';\n                var header = this.layout.fields.map(function(header) {\n                    return JSON.stringify(header);\n                }).join(delimiter) + '\\n';\n                ret = header + jsonified.map(function(record) {\n                    return this.layout.fields.map(function(field) {\n                        if (typeof record[field] == 'undefined') {\n                            return JSON.stringify(null);\n                        } else if (typeof record[field] == 'object' && record[field] !== null) {\n                            return Array.isArray(record[field]) ? '\"[Array(' + record[field].length + ')]\"' : '\"[Object]\"';\n                        } else {\n                            return JSON.stringify(record[field]);\n                        }\n                    }).join(delimiter);\n                }.bind(this)).join('\\n');\n            }\n        } catch (e) {\n            ret = null;\n            console.error('Unable to export CSV data from data layer: ' + this.getBaseId() + ';', e);\n        }\n        break;\n    }\n    return ret;\n};\n\n/**\n * Position the datalayer and all tooltips\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.DataLayer.prototype.draw = function() {\n    this.svg.container.attr('transform', 'translate(' + this.parent.layout.cliparea.origin.x +  ',' + this.parent.layout.cliparea.origin.y + ')');\n    this.svg.clipRect\n        .attr('width', this.parent.layout.cliparea.width)\n        .attr('height', this.parent.layout.cliparea.height);\n    this.positionAllTooltips();\n    return this;\n};\n\n\n/**\n * Re-Map a data layer to reflect changes in the state of a plot (such as viewing region/ chromosome range)\n * @return {Promise}\n */\nLocusZoom.DataLayer.prototype.reMap = function() {\n    this.destroyAllTooltips(); // hack - only non-visible tooltips should be destroyed\n    // and then recreated if returning to visibility\n\n    // Fetch new data. Datalayers are only given access to the final consolidated data from the chain (not headers or raw payloads)\n    var promise = this.parent_plot.lzd.getData(this.state, this.layout.fields);\n    promise.then(function(new_data) {\n        this.data = new_data.body;\n        this.applyDataMethods();\n        this.initialized = true;\n    }.bind(this));\n\n    return promise;\n};\n\n\n/**\n * The central registry of known data layer definitions (which may be stored in separate files due to length)\n * @namespace\n */\nLocusZoom.DataLayers = (function() {\n    var obj = {};\n    var datalayers = {};\n    /**\n     * @name LocusZoom.DataLayers.get\n     * @param {String} name The name of the datalayer\n     * @param {Object} layout The configuration object for this data layer\n     * @param {LocusZoom.DataLayer|LocusZoom.Panel} parent Where this layout is used\n     * @returns {LocusZoom.DataLayer}\n     */\n    obj.get = function(name, layout, parent) {\n        if (!name) {\n            return null;\n        } else if (datalayers[name]) {\n            if (typeof layout != 'object') {\n                throw new Error('invalid layout argument for data layer [' + name + ']');\n            } else {\n                return new datalayers[name](layout, parent);\n            }\n        } else {\n            throw new Error('data layer [' + name + '] not found');\n        }\n    };\n\n    /**\n     * @name LocusZoom.DataLayers.set\n     * @protected\n     * @param {String} name\n     * @param {Function} datalayer Constructor for the datalayer\n     */\n    obj.set = function(name, datalayer) {\n        if (datalayer) {\n            if (typeof datalayer != 'function') {\n                throw new Error('unable to set data layer [' + name + '], argument provided is not a function');\n            } else {\n                datalayers[name] = datalayer;\n                datalayers[name].prototype = new LocusZoom.DataLayer();\n            }\n        } else {\n            delete datalayers[name];\n        }\n    };\n\n    /**\n     * Add a new type of datalayer to the registry of known layer types\n     * @name LocusZoom.DataLayers.add\n     * @param {String} name The name of the data layer to register\n     * @param {Function} datalayer\n     */\n    obj.add = function(name, datalayer) {\n        if (datalayers[name]) {\n            throw new Error('data layer already exists with name: ' + name);\n        } else {\n            obj.set(name, datalayer);\n        }\n    };\n\n    /**\n     * Register a new datalayer that inherits and extends basic behaviors from a known datalayer\n     * @param {String} parent_name The name of the parent data layer whose behavior is to be extended\n     * @param {String} name The name of the new datalayer to register\n     * @param {Object} [overrides] Object of properties and methods to combine with the prototype of the parent datalayer\n     * @returns {Function} The constructor for the new child class\n     */\n    obj.extend = function(parent_name, name, overrides) {\n        // TODO: Consider exposing additional constructor argument, if there is a use case for very granular extension\n        overrides = overrides || {};\n\n        var parent = datalayers[parent_name];\n        if (!parent) {\n            throw new Error('Attempted to subclass an unknown or unregistered datalayer type');\n        }\n        if (typeof overrides !== 'object') {\n            throw new Error('Must specify an object of properties and methods');\n        }\n        var child = LocusZoom.subclass(parent, overrides);\n        // Bypass .set() because we want a layer of inheritance below `DataLayer`\n        datalayers[name] = child;\n        return child;\n    };\n\n    /**\n     * List the names of all known datalayers\n     * @name LocusZoom.DataLayers.list\n     * @returns {String[]}\n     */\n    obj.list = function() {\n        return Object.keys(datalayers);\n    };\n\n    return obj;\n})();\n","/* global LocusZoom */\n'use strict';\n\nvar LZ_SIG_THRESHOLD_LOGP = 7.301; // -log10(.05/1e6)\n\n/**\n * Manage known layouts for all parts of the LocusZoom plot\n *\n * This registry allows for layouts to be reused and customized many times on a page, using a common base pattern.\n *   It handles the work of ensuring that each new instance of the layout has no shared state with other copies.\n *\n * @class\n */\nLocusZoom.Layouts = (function () {\n    var obj = {};\n    var layouts = {\n        'plot': {},\n        'panel': {},\n        'data_layer': {},\n        'dashboard': {},\n        'tooltip': {}\n    };\n\n    /**\n     * Generate a layout configuration object\n     * @param {('plot'|'panel'|'data_layer'|'dashboard'|'tooltip')} type The type of layout to retrieve\n     * @param {string} name Identifier of the predefined layout within the specified type\n     * @param {object} [modifications] Custom properties that override default settings for this layout\n     * @returns {object} A JSON-serializable object representation\n     */\n    obj.get = function (type, name, modifications) {\n        if (typeof type != 'string' || typeof name != 'string') {\n            throw new Error('invalid arguments passed to LocusZoom.Layouts.get, requires string (layout type) and string (layout name)');\n        } else if (layouts[type][name]) {\n            // Get the base layout\n            var layout = LocusZoom.Layouts.merge(modifications || {}, layouts[type][name]);\n            // If \"unnamespaced\" is true then strike that from the layout and return the layout without namespacing\n            if (layout.unnamespaced) {\n                delete layout.unnamespaced;\n                return JSON.parse(JSON.stringify(layout));\n            }\n            // Determine the default namespace for namespaced values\n            var default_namespace = '';\n            if (typeof layout.namespace == 'string') {\n                default_namespace = layout.namespace;\n            } else if (typeof layout.namespace == 'object' && Object.keys(layout.namespace).length) {\n                if (typeof layout.namespace.default != 'undefined') {\n                    default_namespace = layout.namespace.default;\n                } else {\n                    default_namespace = layout.namespace[Object.keys(layout.namespace)[0]].toString();\n                }\n            }\n            default_namespace += default_namespace.length ? ':' : '';\n            // Apply namespaces to layout, recursively\n            var applyNamespaces = function (element, namespace) {\n                if (namespace) {\n                    if (typeof namespace == 'string') {\n                        namespace = { default: namespace };\n                    }\n                } else {\n                    namespace = { default: '' };\n                }\n                if (typeof element == 'string') {\n                    var re = /\\{\\{namespace(\\[[A-Za-z_0-9]+\\]|)\\}\\}/g;\n                    var match, base, key, resolved_namespace;\n                    var replace = [];\n                    while ((match = re.exec(element)) !== null) {\n                        base = match[0];\n                        key = match[1].length ? match[1].replace(/(\\[|\\])/g, '') : null;\n                        resolved_namespace = default_namespace;\n                        if (namespace != null && typeof namespace == 'object' && typeof namespace[key] != 'undefined') {\n                            resolved_namespace = namespace[key] + (namespace[key].length ? ':' : '');\n                        }\n                        replace.push({ base: base, namespace: resolved_namespace });\n                    }\n                    for (var r in replace) {\n                        element = element.replace(replace[r].base, replace[r].namespace);\n                    }\n                } else if (typeof element == 'object' && element != null) {\n                    if (typeof element.namespace != 'undefined') {\n                        var merge_namespace = (typeof element.namespace == 'string') ? { default: element.namespace } : element.namespace;\n                        namespace = LocusZoom.Layouts.merge(namespace, merge_namespace);\n                    }\n                    var namespaced_element, namespaced_property;\n                    for (var property in element) {\n                        if (property === 'namespace') {\n                            continue;\n                        }\n                        namespaced_element = applyNamespaces(element[property], namespace);\n                        namespaced_property = applyNamespaces(property, namespace);\n                        if (property !== namespaced_property) {\n                            delete element[property];\n                        }\n                        element[namespaced_property] = namespaced_element;\n                    }\n                }\n                return element;\n            };\n            layout = applyNamespaces(layout, layout.namespace);\n            // Return the layout as valid JSON only\n            return JSON.parse(JSON.stringify(layout));\n        } else {\n            throw new Error('layout type [' + type + '] name [' + name + '] not found');\n        }\n    };\n\n    /** @private */\n    obj.set = function (type, name, layout) {\n        if (typeof type != 'string' || typeof name != 'string' || typeof layout != 'object') {\n            throw new Error('unable to set new layout; bad arguments passed to set()');\n        }\n        if (!layouts[type]) {\n            layouts[type] = {};\n        }\n        if (layout) {\n            return (layouts[type][name] = JSON.parse(JSON.stringify(layout)));\n        } else {\n            delete layouts[type][name];\n            return null;\n        }\n    };\n\n    /**\n     * Register a new layout definition by name.\n     *\n     * @param {string} type The type of layout to add. Usually, this will be one of the predefined LocusZoom types,\n     *   but if you pass a different name, this method will automatically create the new `type` bucket\n     * @param {string} name The identifier of the newly added layout\n     * @param {object} [layout] A JSON-serializable object containing configuration properties for this layout\n     * @returns The JSON representation of the newly created layout\n     */\n    obj.add = function (type, name, layout) {\n        return obj.set(type, name, layout);\n    };\n\n    /**\n     * List all registered layouts\n     * @param [type] Optionally narrow the list to only layouts of a specific type; else return all known layouts\n     * @returns {*}\n     */\n    obj.list = function (type) {\n        if (!layouts[type]) {\n            var list = {};\n            Object.keys(layouts).forEach(function (type) {\n                list[type] = Object.keys(layouts[type]);\n            });\n            return list;\n        } else {\n            return Object.keys(layouts[type]);\n        }\n    };\n\n    /**\n     * A helper method used for merging two objects. If a key is present in both, takes the value from the first object\n     *   Values from `default_layout` will be cleanly copied over, ensuring no references or shared state.\n     *\n     * Frequently used for preparing custom layouts. Both objects should be JSON-serializable.\n     *\n     * @param {object} custom_layout An object containing configuration parameters that override or add to defaults\n     * @param {object} default_layout An object containing default settings.\n     * @returns {object} The custom layout is modified in place and also returned from this method.\n     */\n    obj.merge = function (custom_layout, default_layout) {\n        if (typeof custom_layout !== 'object' || typeof default_layout !== 'object') {\n            throw new Error('LocusZoom.Layouts.merge only accepts two layout objects; ' + (typeof custom_layout) + ', ' + (typeof default_layout) + ' given');\n        }\n        for (var property in default_layout) {\n            if (!default_layout.hasOwnProperty(property)) {\n                continue;\n            }\n            // Get types for comparison. Treat nulls in the custom layout as undefined for simplicity.\n            // (javascript treats nulls as \"object\" when we just want to overwrite them as if they're undefined)\n            // Also separate arrays from objects as a discrete type.\n            var custom_type = custom_layout[property] === null ? 'undefined' : typeof custom_layout[property];\n            var default_type = typeof default_layout[property];\n            if (custom_type === 'object' && Array.isArray(custom_layout[property])) {\n                custom_type = 'array';\n            }\n            if (default_type === 'object' && Array.isArray(default_layout[property])) {\n                default_type = 'array';\n            }\n            // Unsupported property types: throw an exception\n            if (custom_type === 'function' || default_type === 'function') {\n                throw new Error('LocusZoom.Layouts.merge encountered an unsupported property type');\n            }\n            // Undefined custom value: pull the default value\n            if (custom_type === 'undefined') {\n                custom_layout[property] = JSON.parse(JSON.stringify(default_layout[property]));\n                continue;\n            }\n            // Both values are objects: merge recursively\n            if (custom_type === 'object' && default_type === 'object') {\n                custom_layout[property] = LocusZoom.Layouts.merge(custom_layout[property], default_layout[property]);\n                continue;\n            }\n        }\n        return custom_layout;\n    };\n\n    return obj;\n})();\n\n\n/**\n * Tooltip Layouts\n * @namespace LocusZoom.Layouts.tooltips\n */\n\nLocusZoom.Layouts.add('tooltip', 'standard_association', {\n    namespace: { 'assoc': 'assoc' },\n    closable: true,\n    show: { or: ['highlighted', 'selected'] },\n    hide: { and: ['unhighlighted', 'unselected'] },\n    html: '<strong>{{{{namespace[assoc]}}variant|htmlescape}}</strong><br>'\n        + 'P Value: <strong>{{{{namespace[assoc]}}log_pvalue|logtoscinotation|htmlescape}}</strong><br>'\n        + 'Ref. Allele: <strong>{{{{namespace[assoc]}}ref_allele|htmlescape}}</strong><br>'\n        + '<a href=\"javascript:void(0);\" onclick=\"LocusZoom.getToolTipDataLayer(this).makeLDReference(LocusZoom.getToolTipData(this));\">Make LD Reference</a><br>'\n});\n\nLocusZoom.Layouts.add('tooltip', 'covariates_model_association', function () {\n    var covariates_model_association = LocusZoom.Layouts.get('tooltip', 'standard_association', { unnamespaced: true });\n    covariates_model_association.html += '<a href=\"javascript:void(0);\" onclick=\"LocusZoom.getToolTipPlot(this).CovariatesModel.add(LocusZoom.getToolTipData(this));\">Condition on Variant</a><br>';\n    return covariates_model_association;\n}());\n\nLocusZoom.Layouts.add('tooltip', 'standard_genes', {\n    closable: true,\n    show: { or: ['highlighted', 'selected'] },\n    hide: { and: ['unhighlighted', 'unselected'] },\n    html: '<h4><strong><i>{{gene_name|htmlescape}}</i></strong></h4>'\n        + '<div style=\"float: left;\">Gene ID: <strong>{{gene_id|htmlescape}}</strong></div>'\n        + '<div style=\"float: right;\">Transcript ID: <strong>{{transcript_id|htmlescape}}</strong></div>'\n        + '<div style=\"clear: both;\"></div>'\n        + '<table>'\n        + '<tr><th>Constraint</th><th>Expected variants</th><th>Observed variants</th><th>Const. Metric</th></tr>'\n        + '<tr><td>Synonymous</td><td>{{exp_syn|htmlescape}}</td><td>{{n_syn|htmlescape}}</td><td>z = {{syn_z|htmlescape}}</td></tr>'\n        + '<tr><td>Missense</td><td>{{exp_mis|htmlescape}}</td><td>{{n_mis|htmlescape}}</td><td>z = {{mis_z|htmlescape}}</td></tr>'\n        + '<tr><td>LoF</td><td>{{exp_lof|htmlescape}}</td><td>{{n_lof|htmlescape}}</td><td>pLI = {{pLI|htmlescape}}</td></tr>'\n        + '</table>'\n        + '<a href=\"http://exac.broadinstitute.org/gene/{{gene_id|htmlescape}}\" target=\"_new\">More data on ExAC</a>'\n});\n\nLocusZoom.Layouts.add('tooltip', 'standard_intervals', {\n    namespace: { 'intervals': 'intervals' },\n    closable: false,\n    show: { or: ['highlighted', 'selected'] },\n    hide: { and: ['unhighlighted', 'unselected'] },\n    html: '{{{{namespace[intervals]}}state_name|htmlescape}}<br>{{{{namespace[intervals]}}start|htmlescape}}-{{{{namespace[intervals]}}end|htmlescape}}'\n});\n\nLocusZoom.Layouts.add('tooltip', 'catalog_variant', {\n    namespace: { 'assoc': 'assoc', 'catalog': 'catalog' },\n    closable: true,\n    show: { or: ['highlighted', 'selected'] },\n    hide: { and: ['unhighlighted', 'unselected'] },\n    html: '<strong>{{{{namespace[catalog]}}variant|htmlescape}}</strong><br>'\n        + 'Catalog entries: <strong>{{n_catalog_matches|htmlescape}}</strong><br>'\n        + 'Top Trait: <strong>{{{{namespace[catalog]}}trait|htmlescape}}</strong><br>'\n        + 'Top P Value: <strong>{{{{namespace[catalog]}}log_pvalue|logtoscinotation}}</strong><br>'\n        // User note: if a different catalog is used, the tooltip will need to be replaced with a different link URL\n        + 'More: <a href=\"https://www.ebi.ac.uk/gwas/search?query={{{{namespace[catalog]}}rsid|htmlescape}}\" target=\"_new\">GWAS catalog</a> / <a href=\"https://www.ncbi.nlm.nih.gov/snp/{{{{namespace[catalog]}}rsid|htmlescape}}\" target=\"_new\">dbSNP</a>'\n});\n\n/**\n * Data Layer Layouts: represent specific information from a data source\n * @namespace Layouts.data_layer\n */\n\nLocusZoom.Layouts.add('data_layer', 'significance', {\n    id: 'significance',\n    type: 'orthogonal_line',\n    orientation: 'horizontal',\n    offset: LZ_SIG_THRESHOLD_LOGP\n});\n\nLocusZoom.Layouts.add('data_layer', 'recomb_rate', {\n    namespace: { 'recomb': 'recomb' },\n    id: 'recombrate',\n    type: 'line',\n    fields: ['{{namespace[recomb]}}position', '{{namespace[recomb]}}recomb_rate'],\n    z_index: 1,\n    style: {\n        'stroke': '#0000FF',\n        'stroke-width': '1.5px'\n    },\n    x_axis: {\n        field: '{{namespace[recomb]}}position'\n    },\n    y_axis: {\n        axis: 2,\n        field: '{{namespace[recomb]}}recomb_rate',\n        floor: 0,\n        ceiling: 100\n    }\n});\n\nLocusZoom.Layouts.add('data_layer', 'association_pvalues', {\n    namespace: { 'assoc': 'assoc', 'ld': 'ld' },\n    id: 'associationpvalues',\n    type: 'scatter',\n    point_shape: {\n        scale_function: 'if',\n        field: '{{namespace[ld]}}isrefvar',\n        parameters: {\n            field_value: 1,\n            then: 'diamond',\n            else: 'circle'\n        }\n    },\n    point_size: {\n        scale_function: 'if',\n        field: '{{namespace[ld]}}isrefvar',\n        parameters: {\n            field_value: 1,\n            then: 80,\n            else: 40\n        }\n    },\n    color: [\n        {\n            scale_function: 'if',\n            field: '{{namespace[ld]}}isrefvar',\n            parameters: {\n                field_value: 1,\n                then: '#9632b8'\n            }\n        },\n        {\n            scale_function: 'numerical_bin',\n            field: '{{namespace[ld]}}state',\n            parameters: {\n                breaks: [0, 0.2, 0.4, 0.6, 0.8],\n                values: ['#357ebd', '#46b8da', '#5cb85c', '#eea236', '#d43f3a']\n            }\n        },\n        '#B8B8B8'\n    ],\n    legend: [\n        { shape: 'diamond', color: '#9632b8', size: 40, label: 'LD Ref Var', class: 'lz-data_layer-scatter' },\n        { shape: 'circle', color: '#d43f3a', size: 40, label: '1.0 > r  0.8', class: 'lz-data_layer-scatter' },\n        { shape: 'circle', color: '#eea236', size: 40, label: '0.8 > r  0.6', class: 'lz-data_layer-scatter' },\n        { shape: 'circle', color: '#5cb85c', size: 40, label: '0.6 > r  0.4', class: 'lz-data_layer-scatter' },\n        { shape: 'circle', color: '#46b8da', size: 40, label: '0.4 > r  0.2', class: 'lz-data_layer-scatter' },\n        { shape: 'circle', color: '#357ebd', size: 40, label: '0.2 > r  0.0', class: 'lz-data_layer-scatter' },\n        { shape: 'circle', color: '#B8B8B8', size: 40, label: 'no r data', class: 'lz-data_layer-scatter' }\n    ],\n    label: null,\n    fields: ['{{namespace[assoc]}}variant', '{{namespace[assoc]}}position', '{{namespace[assoc]}}log_pvalue', '{{namespace[assoc]}}log_pvalue|logtoscinotation', '{{namespace[assoc]}}ref_allele', '{{namespace[ld]}}state', '{{namespace[ld]}}isrefvar'],\n    id_field: '{{namespace[assoc]}}variant',\n    z_index: 2,\n    x_axis: {\n        field: '{{namespace[assoc]}}position'\n    },\n    y_axis: {\n        axis: 1,\n        field: '{{namespace[assoc]}}log_pvalue',\n        floor: 0,\n        upper_buffer: 0.10,\n        min_extent: [0, 10]\n    },\n    behaviors: {\n        onmouseover: [\n            { action: 'set', status: 'highlighted' }\n        ],\n        onmouseout: [\n            { action: 'unset', status: 'highlighted' }\n        ],\n        onclick: [\n            { action: 'toggle', status: 'selected', exclusive: true }\n        ],\n        onshiftclick: [\n            { action: 'toggle', status: 'selected' }\n        ]\n    },\n    tooltip: LocusZoom.Layouts.get('tooltip', 'standard_association', { unnamespaced: true })\n});\n\nLocusZoom.Layouts.add('data_layer', 'association_pvalues_catalog', function () {\n    // Slightly modify an existing layout\n    var l = LocusZoom.Layouts.get('data_layer', 'association_pvalues', {\n        unnamespaced: true,\n        id: 'associationpvaluescatalog',\n        fill_opacity: 0.7\n    });\n    l.tooltip.html += '{{#if {{namespace[catalog]}}rsid}}<br><a href=\"https://www.ebi.ac.uk/gwas/search?query={{{{namespace[catalog]}}rsid|htmlescape}}\" target=\"_new\">See hits in GWAS catalog</a>{{/if}}';\n    l.namespace.catalog = 'catalog';\n    l.fields.push('{{namespace[catalog]}}rsid', '{{namespace[catalog]}}trait', '{{namespace[catalog]}}log_pvalue');\n    return l;\n}());\n\nLocusZoom.Layouts.add('data_layer', 'phewas_pvalues', {\n    namespace: { 'phewas': 'phewas' },\n    id: 'phewaspvalues',\n    type: 'category_scatter',\n    point_shape: 'circle',\n    point_size: 70,\n    tooltip_positioning: 'vertical',\n    id_field: '{{namespace[phewas]}}id',\n    fields: ['{{namespace[phewas]}}id', '{{namespace[phewas]}}log_pvalue', '{{namespace[phewas]}}trait_group', '{{namespace[phewas]}}trait_label'],\n    x_axis: {\n        field: '{{namespace[phewas]}}x',  // Synthetic/derived field added by `category_scatter` layer\n        category_field: '{{namespace[phewas]}}trait_group',\n        lower_buffer: 0.025,\n        upper_buffer: 0.025\n    },\n    y_axis: {\n        axis: 1,\n        field: '{{namespace[phewas]}}log_pvalue',\n        floor: 0,\n        upper_buffer: 0.15\n    },\n    color: [{\n        field: '{{namespace[phewas]}}trait_group',\n        scale_function: 'categorical_bin',\n        parameters: {\n            categories: [],\n            values: [],\n            null_value: '#B8B8B8'\n        }\n    }],\n    fill_opacity: 0.7,\n    tooltip: {\n        closable: true,\n        show: { or: ['highlighted', 'selected'] },\n        hide: { and: ['unhighlighted', 'unselected'] },\n        html: [\n            '<strong>Trait:</strong> {{{{namespace[phewas]}}trait_label|htmlescape}}<br>',\n            '<strong>Trait Category:</strong> {{{{namespace[phewas]}}trait_group|htmlescape}}<br>',\n            '<strong>P-value:</strong> {{{{namespace[phewas]}}log_pvalue|logtoscinotation|htmlescape}}<br>'\n        ].join('')\n    },\n    behaviors: {\n        onmouseover: [\n            { action: 'set', status: 'highlighted' }\n        ],\n        onmouseout: [\n            { action: 'unset', status: 'highlighted' }\n        ],\n        onclick: [\n            { action: 'toggle', status: 'selected', exclusive: true }\n        ],\n        onshiftclick: [\n            { action: 'toggle', status: 'selected' }\n        ]\n    },\n    label: {\n        text: '{{{{namespace[phewas]}}trait_label|htmlescape}}',\n        spacing: 6,\n        lines: {\n            style: {\n                'stroke-width': '2px',\n                'stroke': '#333333',\n                'stroke-dasharray': '2px 2px'\n            }\n        },\n        filters: [\n            {\n                field: '{{namespace[phewas]}}log_pvalue',\n                operator: '>=',\n                value: 20\n            }\n        ],\n        style: {\n            'font-size': '14px',\n            'font-weight': 'bold',\n            'fill': '#333333'\n        }\n    }\n});\n\nLocusZoom.Layouts.add('data_layer', 'genes', {\n    namespace: { 'gene': 'gene', 'constraint': 'constraint' },\n    id: 'genes',\n    type: 'genes',\n    fields: ['{{namespace[gene]}}all', '{{namespace[constraint]}}all'],\n    id_field: 'gene_id',\n    behaviors: {\n        onmouseover: [\n            { action: 'set', status: 'highlighted' }\n        ],\n        onmouseout: [\n            { action: 'unset', status: 'highlighted' }\n        ],\n        onclick: [\n            { action: 'toggle', status: 'selected', exclusive: true }\n        ],\n        onshiftclick: [\n            { action: 'toggle', status: 'selected' }\n        ]\n    },\n    tooltip: LocusZoom.Layouts.get('tooltip', 'standard_genes', { unnamespaced: true })\n});\n\nLocusZoom.Layouts.add('data_layer', 'genome_legend', {\n    namespace: { 'genome': 'genome' },\n    id: 'genome_legend',\n    type: 'genome_legend',\n    fields: ['{{namespace[genome]}}chr', '{{namespace[genome]}}base_pairs'],\n    x_axis: {\n        floor: 0,\n        ceiling: 2881033286\n    }\n});\n\nLocusZoom.Layouts.add('data_layer', 'intervals', {\n    namespace: { 'intervals': 'intervals' },\n    id: 'intervals',\n    type: 'intervals',\n    fields: ['{{namespace[intervals]}}start', '{{namespace[intervals]}}end', '{{namespace[intervals]}}state_id', '{{namespace[intervals]}}state_name'],\n    id_field: '{{namespace[intervals]}}start',\n    start_field: '{{namespace[intervals]}}start',\n    end_field: '{{namespace[intervals]}}end',\n    track_split_field: '{{namespace[intervals]}}state_id',\n    split_tracks: true,\n    always_hide_legend: false,\n    color: {\n        field: '{{namespace[intervals]}}state_id',\n        scale_function: 'categorical_bin',\n        parameters: {\n            categories: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],\n            values: ['rgb(212,63,58)', 'rgb(250,120,105)', 'rgb(252,168,139)', 'rgb(240,189,66)', 'rgb(250,224,105)', 'rgb(240,238,84)', 'rgb(244,252,23)', 'rgb(23,232,252)', 'rgb(32,191,17)', 'rgb(23,166,77)', 'rgb(32,191,17)', 'rgb(162,133,166)', 'rgb(212,212,212)'],\n            null_value: '#B8B8B8'\n        }\n    },\n    legend: [\n        { shape: 'rect', color: 'rgb(212,63,58)', width: 9, label: 'Active Promoter', '{{namespace[intervals]}}state_id': 1 },\n        { shape: 'rect', color: 'rgb(250,120,105)', width: 9, label: 'Weak Promoter', '{{namespace[intervals]}}state_id': 2 },\n        { shape: 'rect', color: 'rgb(252,168,139)', width: 9, label: 'Poised Promoter', '{{namespace[intervals]}}state_id': 3 },\n        { shape: 'rect', color: 'rgb(240,189,66)', width: 9, label: 'Strong enhancer', '{{namespace[intervals]}}state_id': 4 },\n        { shape: 'rect', color: 'rgb(250,224,105)', width: 9, label: 'Strong enhancer', '{{namespace[intervals]}}state_id': 5 },\n        { shape: 'rect', color: 'rgb(240,238,84)', width: 9, label: 'Weak enhancer', '{{namespace[intervals]}}state_id': 6 },\n        { shape: 'rect', color: 'rgb(244,252,23)', width: 9, label: 'Weak enhancer', '{{namespace[intervals]}}state_id': 7 },\n        { shape: 'rect', color: 'rgb(23,232,252)', width: 9, label: 'Insulator', '{{namespace[intervals]}}state_id': 8 },\n        { shape: 'rect', color: 'rgb(32,191,17)', width: 9, label: 'Transcriptional transition', '{{namespace[intervals]}}state_id': 9 },\n        { shape: 'rect', color: 'rgb(23,166,77)', width: 9, label: 'Transcriptional elongation', '{{namespace[intervals]}}state_id': 10 },\n        { shape: 'rect', color: 'rgb(136,240,129)', width: 9, label: 'Weak transcribed', '{{namespace[intervals]}}state_id': 11 },\n        { shape: 'rect', color: 'rgb(162,133,166)', width: 9, label: 'Polycomb-repressed', '{{namespace[intervals]}}state_id': 12 },\n        { shape: 'rect', color: 'rgb(212,212,212)', width: 9, label: 'Heterochromatin / low signal', '{{namespace[intervals]}}state_id': 13 }\n    ],\n    behaviors: {\n        onmouseover: [\n            { action: 'set', status: 'highlighted' }\n        ],\n        onmouseout: [\n            { action: 'unset', status: 'highlighted' }\n        ],\n        onclick: [\n            { action: 'toggle', status: 'selected', exclusive: true }\n        ],\n        onshiftclick: [\n            { action: 'toggle', status: 'selected' }\n        ]\n    },\n    tooltip: LocusZoom.Layouts.get('tooltip', 'standard_intervals', { unnamespaced: true })\n});\n\nLocusZoom.Layouts.add('data_layer', 'annotation_catalog', {\n    // Identify GWAS hits that are present in the GWAS catalog\n    namespace: { 'assoc': 'assoc', 'catalog': 'catalog' },\n    id: 'annotation_catalog',\n    type: 'annotation_track',\n    id_field: '{{namespace[catalog]}}variant',\n    x_axis: {\n        field: '{{namespace[assoc]}}position'\n    },\n    color: '#0000CC',\n    fields: [\n        '{{namespace[assoc]}}variant', '{{namespace[assoc]}}chromosome', '{{namespace[assoc]}}position',\n        '{{namespace[catalog]}}variant', '{{namespace[catalog]}}rsid', '{{namespace[catalog]}}trait',\n        '{{namespace[catalog]}}log_pvalue', '{{namespace[catalog]}}pos'\n    ],\n    filters: [\n        // Specify which points to show on the track. Any selection must satisfy ALL filters\n        ['{{namespace[catalog]}}rsid', '!=', null],\n        ['{{namespace[catalog]}}log_pvalue', '>', LZ_SIG_THRESHOLD_LOGP]\n    ],\n    behaviors: {\n        onmouseover: [\n            { action: 'set', status: 'highlighted' }\n        ],\n        onmouseout: [\n            { action: 'unset', status: 'highlighted' }\n        ],\n        onclick: [\n            { action: 'toggle', status: 'selected', exclusive: true }\n        ],\n        onshiftclick: [\n            { action: 'toggle', status: 'selected' }\n        ]\n    },\n    tooltip: LocusZoom.Layouts.get('tooltip', 'catalog_variant', { unnamespaced: true }),\n    tooltip_positioning: 'top'\n});\n\n/**\n * Dashboard Layouts: toolbar buttons etc\n * @namespace Layouts.dashboard\n */\nLocusZoom.Layouts.add('dashboard', 'standard_panel', {\n    components: [\n        {\n            type: 'remove_panel',\n            position: 'right',\n            color: 'red',\n            group_position: 'end'\n        },\n        {\n            type: 'move_panel_up',\n            position: 'right',\n            group_position: 'middle'\n        },\n        {\n            type: 'move_panel_down',\n            position: 'right',\n            group_position: 'start',\n            style: { 'margin-left': '0.75em' }\n        }\n    ]\n});\n\nLocusZoom.Layouts.add('dashboard', 'standard_plot', {\n    components: [\n        {\n            type: 'title',\n            title: 'LocusZoom',\n            subtitle: '<a href=\"https://statgen.github.io/locuszoom/\" target=\"_blank\">v' + LocusZoom.version + '</a>',\n            position: 'left'\n        },\n        {\n            type: 'download',\n            position: 'right'\n        }\n    ]\n});\n\nLocusZoom.Layouts.add('dashboard', 'covariates_model_plot', function () {\n    var covariates_model_plot_dashboard = LocusZoom.Layouts.get('dashboard', 'standard_plot', { unnamespaced: true });\n    covariates_model_plot_dashboard.components.push({\n        type: 'covariates_model',\n        button_html: 'Model',\n        button_title: 'Show and edit covariates currently in model',\n        position: 'left'\n    });\n    return covariates_model_plot_dashboard;\n}());\n\nLocusZoom.Layouts.add('dashboard', 'region_nav_plot', function () {\n    var region_nav_plot_dashboard = LocusZoom.Layouts.get('dashboard', 'standard_plot', { unnamespaced: true });\n    region_nav_plot_dashboard.components.push(\n        {\n            type: 'shift_region',\n            step: 500000,\n            button_html: '>>',\n            position: 'right',\n            group_position: 'end'\n        }, {\n            type: 'shift_region',\n            step: 50000,\n            button_html: '>',\n            position: 'right',\n            group_position: 'middle'\n        },\n        {\n            type: 'zoom_region',\n            step: 0.2,\n            position: 'right',\n            group_position: 'middle'\n        },\n        {\n            type: 'zoom_region',\n            step: -0.2,\n            position: 'right',\n            group_position: 'middle'\n        },\n        {\n            type: 'shift_region',\n            step: -50000,\n            button_html: '<',\n            position: 'right',\n            group_position: 'middle'\n        },\n        {\n            type: 'shift_region',\n            step: -500000,\n            button_html: '<<',\n            position: 'right',\n            group_position: 'start'\n        }\n    );\n    return region_nav_plot_dashboard;\n}());\n\n/**\n * Panel Layouts\n * @namespace Layouts.panel\n */\n\nLocusZoom.Layouts.add('panel', 'association', {\n    id: 'association',\n    width: 800,\n    height: 225,\n    min_width: 400,\n    min_height: 200,\n    proportional_width: 1,\n    margin: { top: 35, right: 50, bottom: 40, left: 50 },\n    inner_border: 'rgb(210, 210, 210)',\n    dashboard: (function () {\n        var l = LocusZoom.Layouts.get('dashboard', 'standard_panel', { unnamespaced: true });\n        l.components.push({\n            type: 'toggle_legend',\n            position: 'right'\n        });\n        return l;\n    })(),\n    axes: {\n        x: {\n            label: 'Chromosome {{chr}} (Mb)',\n            label_offset: 32,\n            tick_format: 'region',\n            extent: 'state'\n        },\n        y1: {\n            label: '-log10 p-value',\n            label_offset: 28\n        },\n        y2: {\n            label: 'Recombination Rate (cM/Mb)',\n            label_offset: 40\n        }\n    },\n    legend: {\n        orientation: 'vertical',\n        origin: { x: 55, y: 40 },\n        hidden: true\n    },\n    interaction: {\n        drag_background_to_pan: true,\n        drag_x_ticks_to_scale: true,\n        drag_y1_ticks_to_scale: true,\n        drag_y2_ticks_to_scale: true,\n        scroll_to_zoom: true,\n        x_linked: true\n    },\n    data_layers: [\n        LocusZoom.Layouts.get('data_layer', 'significance', { unnamespaced: true }),\n        LocusZoom.Layouts.get('data_layer', 'recomb_rate', { unnamespaced: true }),\n        LocusZoom.Layouts.get('data_layer', 'association_pvalues', { unnamespaced: true })\n    ]\n});\n\nLocusZoom.Layouts.add('panel', 'association_catalog', function () {\n    var l = LocusZoom.Layouts.get('panel', 'association', {\n        unnamespaced: true,\n        id: 'associationcatalog',\n        namespace: { 'assoc': 'assoc', 'ld': 'ld', 'catalog': 'catalog' } // Required to resolve display options\n    });\n    l.dashboard.components.push({\n        type: 'display_options',\n        position: 'right',\n        color: 'blue',\n        // Below: special config specific to this widget\n        button_html: 'Display options...',\n        button_title: 'Control how plot items are displayed',\n\n        layer_name: 'associationpvaluescatalog',\n        default_config_display_name: 'No catalog labels (default)', // display name for the default plot color option (allow user to revert to plot defaults)\n\n        options: [\n            {\n                // First dropdown menu item\n                display_name: 'Label catalog traits',  // Human readable representation of field name\n                display: {  // Specify layout directives that control display of the plot for this option\n                    label: {\n                        text: '{{{{namespace[catalog]}}trait|htmlescape}}',\n                        spacing: 6,\n                        lines: {\n                            style: {\n                                'stroke-width': '2px',\n                                'stroke': '#333333',\n                                'stroke-dasharray': '2px 2px'\n                            }\n                        },\n                        filters: [\n                            // Only label points if they are significant for some trait in the catalog, AND in high LD\n                            //  with the top hit of interest\n                            {\n                                field: '{{namespace[catalog]}}trait',\n                                operator: '!=',\n                                value: null\n                            },\n                            {\n                                field: '{{namespace[catalog]}}log_pvalue',\n                                operator: '>',\n                                value: LZ_SIG_THRESHOLD_LOGP\n                            },\n                            {\n                                field: '{{namespace[ld]}}state',\n                                operator: '>',\n                                value: 0.4\n                            },\n                        ],\n                        style: {\n                            'font-size': '10px',\n                            'font-weight': 'bold',\n                            'fill': '#333333'\n                        }\n                    }\n                }\n            }\n        ]\n    });\n    l.data_layers = [\n        LocusZoom.Layouts.get('data_layer', 'significance', { unnamespaced: true }),\n        LocusZoom.Layouts.get('data_layer', 'recomb_rate', { unnamespaced: true }),\n        LocusZoom.Layouts.get('data_layer', 'association_pvalues_catalog', { unnamespaced: true })\n    ];\n    return l;\n}());\n\nLocusZoom.Layouts.add('panel', 'genes', {\n    id: 'genes',\n    width: 800,\n    height: 225,\n    min_width: 400,\n    min_height: 112.5,\n    proportional_width: 1,\n    margin: { top: 20, right: 50, bottom: 20, left: 50 },\n    axes: {},\n    interaction: {\n        drag_background_to_pan: true,\n        scroll_to_zoom: true,\n        x_linked: true\n    },\n    dashboard: (function () {\n        var l = LocusZoom.Layouts.get('dashboard', 'standard_panel', { unnamespaced: true });\n        l.components.push({\n            type: 'resize_to_data',\n            position: 'right'\n        });\n        return l;\n    })(),\n    data_layers: [\n        LocusZoom.Layouts.get('data_layer', 'genes', { unnamespaced: true })\n    ]\n});\n\nLocusZoom.Layouts.add('panel', 'phewas', {\n    id: 'phewas',\n    width: 800,\n    height: 300,\n    min_width: 800,\n    min_height: 300,\n    proportional_width: 1,\n    margin: { top: 20, right: 50, bottom: 120, left: 50 },\n    inner_border: 'rgb(210, 210, 210)',\n    axes: {\n        x: {\n            ticks: {  // Object based config (shared defaults; allow layers to specify ticks)\n                style: {\n                    'font-weight': 'bold',\n                    'font-size': '11px',\n                    'text-anchor': 'start'\n                },\n                transform: 'rotate(50)',\n                position: 'left'  // Special param recognized by `category_scatter` layers\n            }\n        },\n        y1: {\n            label: '-log10 p-value',\n            label_offset: 28\n        }\n    },\n    data_layers: [\n        LocusZoom.Layouts.get('data_layer', 'significance', { unnamespaced: true }),\n        LocusZoom.Layouts.get('data_layer', 'phewas_pvalues', { unnamespaced: true })\n    ]\n});\n\nLocusZoom.Layouts.add('panel', 'genome_legend', {\n    id: 'genome_legend',\n    width: 800,\n    height: 50,\n    origin: { x: 0, y: 300 },\n    min_width: 800,\n    min_height: 50,\n    proportional_width: 1,\n    margin: { top: 0, right: 50, bottom: 35, left: 50 },\n    axes: {\n        x: {\n            label: 'Genomic Position (number denotes chromosome)',\n            label_offset: 35,\n            ticks: [\n                {\n                    x: 124625310,\n                    text: '1',\n                    style: {\n                        'fill': 'rgb(120, 120, 186)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 370850307,\n                    text: '2',\n                    style: {\n                        'fill': 'rgb(0, 0, 66)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 591461209,\n                    text: '3',\n                    style: {\n                        'fill': 'rgb(120, 120, 186)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 786049562,\n                    text: '4',\n                    style: {\n                        'fill': 'rgb(0, 0, 66)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 972084330,\n                    text: '5',\n                    style: {\n                        'fill': 'rgb(120, 120, 186)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 1148099493,\n                    text: '6',\n                    style: {\n                        'fill': 'rgb(0, 0, 66)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 1313226358,\n                    text: '7',\n                    style: {\n                        'fill': 'rgb(120, 120, 186)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 1465977701,\n                    text: '8',\n                    style: {\n                        'fill': 'rgb(0, 0, 66)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 1609766427,\n                    text: '9',\n                    style: {\n                        'fill': 'rgb(120, 120, 186)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 1748140516,\n                    text: '10',\n                    style: {\n                        'fill': 'rgb(0, 0, 66)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 1883411148,\n                    text: '11',\n                    style: {\n                        'fill': 'rgb(120, 120, 186)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 2017840353,\n                    text: '12',\n                    style: {\n                        'fill': 'rgb(0, 0, 66)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 2142351240,\n                    text: '13',\n                    style: {\n                        'fill': 'rgb(120, 120, 186)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 2253610949,\n                    text: '14',\n                    style: {\n                        'fill': 'rgb(0, 0, 66)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 2358551415,\n                    text: '15',\n                    style: {\n                        'fill': 'rgb(120, 120, 186)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 2454994487,\n                    text: '16',\n                    style: {\n                        'fill': 'rgb(0, 0, 66)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 2540769469,\n                    text: '17',\n                    style: {\n                        'fill': 'rgb(120, 120, 186)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 2620405698,\n                    text: '18',\n                    style: {\n                        'fill': 'rgb(0, 0, 66)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 2689008813,\n                    text: '19',\n                    style: {\n                        'fill': 'rgb(120, 120, 186)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 2750086065,\n                    text: '20',\n                    style: {\n                        'fill': 'rgb(0, 0, 66)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 2805663772,\n                    text: '21',\n                    style: {\n                        'fill': 'rgb(120, 120, 186)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                },\n                {\n                    x: 2855381003,\n                    text: '22',\n                    style: {\n                        'fill': 'rgb(0, 0, 66)',\n                        'text-anchor': 'center',\n                        'font-size': '13px',\n                        'font-weight': 'bold'\n                    },\n                    transform: 'translate(0, 2)'\n                }\n            ]\n        }\n    },\n    data_layers: [\n        LocusZoom.Layouts.get('data_layer', 'genome_legend', { unnamespaced: true })\n    ]\n});\n\nLocusZoom.Layouts.add('panel', 'intervals', {\n    id: 'intervals',\n    width: 1000,\n    height: 50,\n    min_width: 500,\n    min_height: 50,\n    margin: { top: 25, right: 150, bottom: 5, left: 50 },\n    dashboard: (function () {\n        var l = LocusZoom.Layouts.get('dashboard', 'standard_panel', { unnamespaced: true });\n        l.components.push({\n            type: 'toggle_split_tracks',\n            data_layer_id: 'intervals',\n            position: 'right'\n        });\n        return l;\n    })(),\n    axes: {},\n    interaction: {\n        drag_background_to_pan: true,\n        scroll_to_zoom: true,\n        x_linked: true\n    },\n    legend: {\n        hidden: true,\n        orientation: 'horizontal',\n        origin: { x: 50, y: 0 },\n        pad_from_bottom: 5\n    },\n    data_layers: [\n        LocusZoom.Layouts.get('data_layer', 'intervals', { unnamespaced: true })\n    ]\n});\n\nLocusZoom.Layouts.add('panel', 'annotation_catalog', {\n    id: 'annotationcatalog',\n    width: 800,\n    height: 50,\n    min_height: 50,\n    proportional_width: 1,\n    margin: { top: 25, right: 50, bottom: 0, left: 50 },\n    inner_border: 'rgb(210, 210, 210)',\n    dashboard: LocusZoom.Layouts.get('dashboard', 'standard_panel', { unnamespaced: true }),\n    interaction: {\n        drag_background_to_pan: true,\n        scroll_to_zoom: true,\n        x_linked: true\n    },\n    data_layers: [\n        LocusZoom.Layouts.get('data_layer', 'annotation_catalog', { unnamespaced: true })\n    ]\n});\n\n/**\n * Plot Layouts\n * @namespace Layouts.plot\n */\n\nLocusZoom.Layouts.add('plot', 'standard_association', {\n    state: {},\n    width: 800,\n    height: 450,\n    responsive_resize: 'both',\n    min_region_scale: 20000,\n    max_region_scale: 1000000,\n    dashboard: LocusZoom.Layouts.get('dashboard', 'standard_plot', { unnamespaced: true }),\n    panels: [\n        LocusZoom.Layouts.get('panel', 'association', { unnamespaced: true, proportional_height: 0.5 }),\n        LocusZoom.Layouts.get('panel', 'genes', { unnamespaced: true, proportional_height: 0.5 })\n    ]\n});\n\nLocusZoom.Layouts.add('plot', 'association_catalog', {\n    state: {},\n    width: 800,\n    height: 500,\n    responsive_resize: 'width_only',\n    min_region_scale: 20000,\n    max_region_scale: 1000000,\n    dashboard: LocusZoom.Layouts.get('dashboard', 'standard_plot', { unnamespaced: true }),\n    panels: [\n        LocusZoom.Layouts.get('panel', 'annotation_catalog', { unnamespaced: true }),\n        LocusZoom.Layouts.get('panel', 'association_catalog', { unnamespaced: true }),\n        LocusZoom.Layouts.get('panel', 'genes', { unnamespaced: true })\n    ]\n});\n\n// Shortcut to \"StandardLayout\" for backward compatibility\nLocusZoom.StandardLayout = LocusZoom.Layouts.get('plot', 'standard_association');\n\nLocusZoom.Layouts.add('plot', 'standard_phewas', {\n    width: 800,\n    height: 600,\n    min_width: 800,\n    min_height: 600,\n    responsive_resize: 'both',\n    dashboard: LocusZoom.Layouts.get('dashboard', 'standard_plot', { unnamespaced: true }),\n    panels: [\n        LocusZoom.Layouts.get('panel', 'phewas', { unnamespaced: true, proportional_height: 0.45 }),\n        LocusZoom.Layouts.get('panel', 'genome_legend', { unnamespaced: true, proportional_height: 0.1 }),\n        LocusZoom.Layouts.get('panel', 'genes', {\n            unnamespaced: true, proportional_height: 0.45,\n            margin: { bottom: 40 },\n            axes: {\n                x: {\n                    label: 'Chromosome {{chr}} (Mb)',\n                    label_offset: 32,\n                    tick_format: 'region',\n                    extent: 'state'\n                }\n            }\n        })\n    ],\n    mouse_guide: false\n});\n\nLocusZoom.Layouts.add('plot', 'interval_association', {\n    state: {},\n    width: 800,\n    height: 550,\n    responsive_resize: 'both',\n    min_region_scale: 20000,\n    max_region_scale: 1000000,\n    dashboard: LocusZoom.Layouts.get('dashboard', 'standard_plot', { unnamespaced: true }),\n    panels: [\n        LocusZoom.Layouts.get('panel', 'association', { unnamespaced: true, width: 800, proportional_height: (225 / 570) }),\n        LocusZoom.Layouts.get('panel', 'intervals', { unnamespaced: true, proportional_height: (120 / 570) }),\n        LocusZoom.Layouts.get('panel', 'genes', { unnamespaced: true, width: 800, proportional_height: (225 / 570) })\n    ]\n});\n","/**\n * @namespace\n */\nvar LocusZoom = {\n    version: '0.10.0-beta.1'\n};\n\n/**\n * Populate a single element with a LocusZoom plot.\n * selector can be a string for a DOM Query or a d3 selector.\n * @param {String} selector CSS selector for the container element where the plot will be mounted. Any pre-existing\n *   content in the container will be completely replaced.\n * @param {LocusZoom.DataSources} datasource Ensemble of data providers used by the plot\n * @param {Object} layout A JSON-serializable object of layout configuration parameters\n * @returns {LocusZoom.Plot} The newly created plot instance\n */\nLocusZoom.populate = function(selector, datasource, layout) {\n    if (typeof selector == 'undefined') {\n        throw new Error('LocusZoom.populate selector not defined');\n    }\n    // Empty the selector of any existing content\n    d3.select(selector).html('');\n    var plot;\n    d3.select(selector).call(function() {\n        // Require each containing element have an ID. If one isn't present, create one.\n        if (typeof this.node().id == 'undefined') {\n            var iterator = 0;\n            while (!d3.select('#lz-' + iterator).empty()) { iterator++; }\n            this.attr('id', '#lz-' + iterator);\n        }\n        // Create the plot\n        plot = new LocusZoom.Plot(this.node().id, datasource, layout);\n        plot.container = this.node();\n        // Detect data-region and fill in state values if present\n        if (typeof this.node().dataset !== 'undefined' && typeof this.node().dataset.region !== 'undefined') {\n            var parsed_state = LocusZoom.parsePositionQuery(this.node().dataset.region);\n            Object.keys(parsed_state).forEach(function(key) {\n                plot.state[key] = parsed_state[key];\n            });\n        }\n        // Add an SVG to the div and set its dimensions\n        plot.svg = d3.select('div#' + plot.id)\n            .append('svg')\n            .attr('version', '1.1')\n            .attr('xmlns', 'http://www.w3.org/2000/svg')\n            .attr('id', plot.id + '_svg').attr('class', 'lz-locuszoom')\n            .style(plot.layout.style);\n        plot.setDimensions();\n        plot.positionPanels();\n        // Initialize the plot\n        plot.initialize();\n        // If the plot has defined data sources then trigger its first mapping based on state values\n        if (typeof datasource == 'object' && Object.keys(datasource).length) {\n            plot.refresh();\n        }\n    });\n    return plot;\n};\n\n/**\n * Populate arbitrarily many elements each with a LocusZoom plot\n *   using a common datasource and layout\n * @param {String} selector CSS selector for the container element where the plot will be mounted. Any pre-existing\n *   content in the container will be completely replaced.\n * @param {LocusZoom.DataSources} datasource Ensemble of data providers used by the plot\n * @param {Object} layout A JSON-serializable object of layout configuration parameters\n * @returns {LocusZoom.Plot[]}\n */\nLocusZoom.populateAll = function(selector, datasource, layout) {\n    var plots = [];\n    d3.selectAll(selector).each(function(d,i) {\n        plots[i] = LocusZoom.populate(this, datasource, layout);\n    });\n    return plots;\n};\n\n/**\n * Convert an integer chromosome position to an SI string representation (e.g. 23423456 => \"23.42\" (Mb))\n * @param {Number} pos Position\n * @param {Number} [exp] Exponent to use for the returned string, eg 6=> MB. If not specified, will attempt to guess\n *   the most appropriate SI prefix based on the number provided.\n * @param {Boolean} [suffix=false] Whether or not to append a suffix (e.g. \"Mb\") to the end of the returned string\n * @returns {string}\n */\nLocusZoom.positionIntToString = function(pos, exp, suffix) {\n    var exp_symbols = { 0: '', 3: 'K', 6: 'M', 9: 'G' };\n    suffix = suffix || false;\n    if (isNaN(exp) || exp === null) {\n        var log = Math.log(pos) / Math.LN10;\n        exp = Math.min(Math.max(log - (log % 3), 0), 9);\n    }\n    var places_exp = exp - Math.floor((Math.log(pos) / Math.LN10).toFixed(exp + 3));\n    var min_exp = Math.min(Math.max(exp, 0), 2);\n    var places = Math.min(Math.max(places_exp, min_exp), 12);\n    var ret = '' + (pos / Math.pow(10, exp)).toFixed(places);\n    if (suffix && typeof exp_symbols[exp] !== 'undefined') {\n        ret += ' ' + exp_symbols[exp] + 'b';\n    }\n    return ret;\n};\n\n/**\n * Convert an SI string chromosome position to an integer representation (e.g. \"5.8 Mb\" => 58000000)\n * @param {String} p The chromosome position\n * @returns {Number}\n */\nLocusZoom.positionStringToInt = function(p) {\n    var val = p.toUpperCase();\n    val = val.replace(/,/g, '');\n    var suffixre = /([KMG])[B]*$/;\n    var suffix = suffixre.exec(val);\n    var mult = 1;\n    if (suffix) {\n        if (suffix[1] === 'M') {\n            mult = 1e6;\n        } else if (suffix[1] === 'G') {\n            mult = 1e9;\n        } else {\n            mult = 1e3; //K\n        }\n        val = val.replace(suffixre,'');\n    }\n    val = Number(val) * mult;\n    return val;\n};\n\n/**\n * Parse region queries into their constituent parts\n * TODO: handle genes (or send off to API)\n * @param {String} x A chromosome position query. May be any of the forms `chr:start-end`, `chr:center+offset`,\n *   or `chr:pos`\n * @returns {{chr:*, start: *, end:*} | {chr:*, position:*}}\n */\nLocusZoom.parsePositionQuery = function(x) {\n    var chrposoff = /^(\\w+):([\\d,.]+[kmgbKMGB]*)([-+])([\\d,.]+[kmgbKMGB]*)$/;\n    var chrpos = /^(\\w+):([\\d,.]+[kmgbKMGB]*)$/;\n    var match = chrposoff.exec(x);\n    if (match) {\n        if (match[3] === '+') {\n            var center = LocusZoom.positionStringToInt(match[2]);\n            var offset = LocusZoom.positionStringToInt(match[4]);\n            return {\n                chr:match[1],\n                start: center - offset,\n                end: center + offset\n            };\n        } else {\n            return {\n                chr: match[1],\n                start: LocusZoom.positionStringToInt(match[2]),\n                end: LocusZoom.positionStringToInt(match[4])\n            };\n        }\n    }\n    match = chrpos.exec(x);\n    if (match) {\n        return {\n            chr:match[1],\n            position: LocusZoom.positionStringToInt(match[2])\n        };\n    }\n    return null;\n};\n\n/**\n * Generate a \"pretty\" set of ticks (multiples of 1, 2, or 5 on the same order of magnitude for the range)\n *   Based on R's \"pretty\" function: https://github.com/wch/r-source/blob/b156e3a711967f58131e23c1b1dc1ea90e2f0c43/src/appl/pretty.c\n * @param {Number[]} range A two-item array specifying [low, high] values for the axis range\n * @param {('low'|'high'|'both'|'neither')} [clip_range='neither'] What to do if first and last generated ticks extend\n *   beyond the range. Set this to \"low\", \"high\", \"both\", or \"neither\" to clip the first (low) or last (high) tick to\n *   be inside the range or allow them to extend beyond.\n *   e.g. \"low\" will clip the first (low) tick if it extends beyond the low end of the range but allow the\n *  last (high) tick to extend beyond the range. \"both\" clips both ends, \"neither\" allows both to extend beyond.\n * @param {Number} [target_tick_count=5] The approximate number of ticks you would like to be returned; may not be exact\n * @returns {Number[]}\n */\nLocusZoom.prettyTicks = function(range, clip_range, target_tick_count) {\n    if (typeof target_tick_count == 'undefined' || isNaN(parseInt(target_tick_count))) {\n        target_tick_count = 5;\n    }\n    target_tick_count = parseInt(target_tick_count);\n\n    var min_n = target_tick_count / 3;\n    var shrink_sml = 0.75;\n    var high_u_bias = 1.5;\n    var u5_bias = 0.5 + 1.5 * high_u_bias;\n\n    var d = Math.abs(range[0] - range[1]);\n    var c = d / target_tick_count;\n    if ((Math.log(d) / Math.LN10) < -2) {\n        c = (Math.max(Math.abs(d)) * shrink_sml) / min_n;\n    }\n\n    var base = Math.pow(10, Math.floor(Math.log(c) / Math.LN10));\n    var base_toFixed = 0;\n    if (base < 1 && base !== 0) {\n        base_toFixed = Math.abs(Math.round(Math.log(base) / Math.LN10));\n    }\n\n    var unit = base;\n    if ( ((2 * base) - c) < (high_u_bias * (c - unit)) ) {\n        unit = 2 * base;\n        if ( ((5 * base) - c) < (u5_bias * (c - unit)) ) {\n            unit = 5 * base;\n            if ( ((10 * base) - c) < (high_u_bias * (c - unit)) ) {\n                unit = 10 * base;\n            }\n        }\n    }\n\n    var ticks = [];\n    var i = parseFloat( (Math.floor(range[0] / unit) * unit).toFixed(base_toFixed) );\n    while (i < range[1]) {\n        ticks.push(i);\n        i += unit;\n        if (base_toFixed > 0) {\n            i = parseFloat(i.toFixed(base_toFixed));\n        }\n    }\n    ticks.push(i);\n\n    if (typeof clip_range == 'undefined' || ['low', 'high', 'both', 'neither'].indexOf(clip_range) === -1) {\n        clip_range = 'neither';\n    }\n    if (clip_range === 'low' || clip_range === 'both') {\n        if (ticks[0] < range[0]) { ticks = ticks.slice(1); }\n    }\n    if (clip_range === 'high' || clip_range === 'both') {\n        if (ticks[ticks.length - 1] > range[1]) { ticks.pop(); }\n    }\n\n    return ticks;\n};\n\n/**\n * Make an AJAX request and return a promise.\n * From http://www.html5rocks.com/en/tutorials/cors/\n *   and with promises from https://gist.github.com/kriskowal/593076\n *\n * @param {String} method The HTTP verb\n * @param {String} url\n * @param {String} [body] The request body to send to the server\n * @param {Object} [headers] Object of custom request headers\n * @param {Number} [timeout] If provided, wait this long (in ms) before timing out\n * @returns {Promise}\n */\nLocusZoom.createCORSPromise = function (method, url, body, headers, timeout) {\n    return new Promise(function (resolve, reject) {\n        var xhr = new XMLHttpRequest();\n        if ('withCredentials' in xhr) {\n            // Check if the XMLHttpRequest object has a \"withCredentials\" property.\n            // \"withCredentials\" only exists on XMLHTTPRequest2 objects.\n            xhr.open(method, url, true);\n        } else if (typeof XDomainRequest != 'undefined') {\n            // Otherwise, check if XDomainRequest.\n            // XDomainRequest only exists in IE, and is IE's way of making CORS requests.\n            xhr = new XDomainRequest();\n            xhr.open(method, url);\n        } else {\n            // Otherwise, CORS is not supported by the browser.\n            xhr = null;\n        }\n        if (xhr) {\n            xhr.onreadystatechange = function() {\n                if (xhr.readyState === 4) {\n                    if (xhr.status === 200 || xhr.status === 0 ) {\n                        resolve(xhr.response);\n                    } else {\n                        reject('HTTP ' + xhr.status + ' for ' + url);\n                    }\n                }\n            };\n            timeout && setTimeout(reject, timeout);\n            body = typeof body !== 'undefined' ? body : '';\n            if (typeof headers !== 'undefined') {\n                for (var header in headers) {\n                    xhr.setRequestHeader(header, headers[header]);\n                }\n            }\n            // Send the request\n            xhr.send(body);\n        }\n    });\n};\n\n/**\n * Validate a (presumed complete) plot state object against internal rules for consistency, and ensure the plot fits\n *   within any constraints imposed by the layout.\n * @param {Object} new_state\n * @param {Number} new_state.start\n * @param {Number} new_state.end\n * @param {Object} layout\n * @returns {*|{}}\n */\nLocusZoom.validateState = function(new_state, layout) {\n\n    new_state = new_state || {};\n    layout = layout || {};\n\n    // If a \"chr\", \"start\", and \"end\" are present then resolve start and end\n    // to numeric values that are not decimal, negative, or flipped\n    var validated_region = false;\n    if (typeof new_state.chr != 'undefined' && typeof new_state.start != 'undefined' && typeof new_state.end != 'undefined') {\n        // Determine a numeric scale and midpoint for the attempted region,\n        var attempted_midpoint = null; var attempted_scale;\n        new_state.start = Math.max(parseInt(new_state.start), 1);\n        new_state.end = Math.max(parseInt(new_state.end), 1);\n        if (isNaN(new_state.start) && isNaN(new_state.end)) {\n            new_state.start = 1;\n            new_state.end = 1;\n            attempted_midpoint = 0.5;\n            attempted_scale = 0;\n        } else if (isNaN(new_state.start) || isNaN(new_state.end)) {\n            attempted_midpoint = new_state.start || new_state.end;\n            attempted_scale = 0;\n            new_state.start = (isNaN(new_state.start) ? new_state.end : new_state.start);\n            new_state.end = (isNaN(new_state.end) ? new_state.start : new_state.end);\n        } else {\n            attempted_midpoint = Math.round((new_state.start + new_state.end) / 2);\n            attempted_scale = new_state.end - new_state.start;\n            if (attempted_scale < 0) {\n                var temp = new_state.start;\n                new_state.end = new_state.start;\n                new_state.start = temp;\n                attempted_scale = new_state.end - new_state.start;\n            }\n            if (attempted_midpoint < 0) {\n                new_state.start = 1;\n                new_state.end = 1;\n                attempted_scale = 0;\n            }\n        }\n        validated_region = true;\n    }\n\n    // Constrain w/r/t layout-defined minimum region scale\n    if (!isNaN(layout.min_region_scale) && validated_region && attempted_scale < layout.min_region_scale) {\n        new_state.start = Math.max(attempted_midpoint - Math.floor(layout.min_region_scale / 2), 1);\n        new_state.end = new_state.start + layout.min_region_scale;\n    }\n\n    // Constrain w/r/t layout-defined maximum region scale\n    if (!isNaN(layout.max_region_scale) && validated_region && attempted_scale > layout.max_region_scale) {\n        new_state.start = Math.max(attempted_midpoint - Math.floor(layout.max_region_scale / 2), 1);\n        new_state.end = new_state.start + layout.max_region_scale;\n    }\n\n    return new_state;\n};\n\n//\n/**\n * Replace placeholders in an html string with field values defined in a data object\n *  Only works on scalar values! Will ignore non-scalars.\n *\n *  NOTE: Trusts content exactly as given. XSS prevention is the responsibility of the implementer.\n * @param {Object} data\n * @param {String} html A placeholder string in which to substitute fields. Supports several template options:\n *   `{{field_name}}` is a variable placeholder for the value of `field_name` from the provided data\n *   `{{#if field_name}} Conditional text {{/if}}` will insert the contents of the tag only if the value exists.\n *     Since this is only an existence check, **variables with a value of 0 will be evaluated as true**.\n *     This can be used with namespaced values, `{{#if assoc:field}}`; any dynamic namespacing will be applied when the\n *     layout is first retrieved.\n * @returns {string}\n */\nLocusZoom.parseFields = function (data, html) {\n    if (typeof data != 'object') {\n        throw new Error('LocusZoom.parseFields invalid arguments: data is not an object');\n    }\n    if (typeof html != 'string') {\n        throw new Error('LocusZoom.parseFields invalid arguments: html is not a string');\n    }\n    // `tokens` is like [token,...]\n    // `token` is like {text: '...'} or {variable: 'foo|bar'} or {condition: 'foo|bar'} or {close: 'if'}\n    var tokens = [];\n    var regex = /\\{\\{(?:(#if )?([A-Za-z0-9_:|]+)|(\\/if))\\}\\}/;\n    while (html.length > 0) {\n        var m = regex.exec(html);\n        if (!m) { tokens.push({text: html}); html = ''; }\n        else if (m.index !== 0) { tokens.push({text: html.slice(0, m.index)}); html = html.slice(m.index); }\n        else if (m[1] === '#if ') { tokens.push({condition: m[2]}); html = html.slice(m[0].length); }\n        else if (m[2]) { tokens.push({variable: m[2]}); html = html.slice(m[0].length); }\n        else if (m[3] === '/if') { tokens.push({close: 'if'}); html = html.slice(m[0].length); }\n        else {\n            console.error('Error tokenizing tooltip when remaining template is ' + JSON.stringify(html) +\n                          ' and previous tokens are ' + JSON.stringify(tokens) +\n                          ' and current regex match is ' + JSON.stringify([m[1], m[2], m[3]]));\n            html = html.slice(m[0].length);\n        }\n    }\n    var astify = function() {\n        var token = tokens.shift();\n        if (typeof token.text !== 'undefined' || token.variable) {\n            return token;\n        } else if (token.condition) {\n            token.then = [];\n            while(tokens.length > 0) {\n                if (tokens[0].close === 'if') { tokens.shift(); break; }\n                token.then.push(astify());\n            }\n            return token;\n        } else {\n            console.error('Error making tooltip AST due to unknown token ' + JSON.stringify(token));\n            return { text: '' };\n        }\n    };\n    // `ast` is like [thing,...]\n    // `thing` is like {text: \"...\"} or {variable:\"foo|bar\"} or {condition: \"foo|bar\", then:[thing,...]}\n    var ast = [];\n    while (tokens.length > 0) {\n        ast.push(astify());\n    }\n\n    var resolve = function(variable) {\n        if (!resolve.cache.hasOwnProperty(variable)) {\n            resolve.cache[variable] = (new LocusZoom.Data.Field(variable)).resolve(data);\n        }\n        return resolve.cache[variable];\n    };\n    resolve.cache = {};\n    var render_node = function(node) {\n        if (typeof node.text !== 'undefined') {\n            return node.text;\n        } else if (node.variable) {\n            try {\n                var value = resolve(node.variable);\n                if (['string','number','boolean'].indexOf(typeof value) !== -1) { return value; }\n                if (value === null) { return ''; }\n            } catch (error) { console.error('Error while processing variable ' + JSON.stringify(node.variable)); }\n            return '{{' + node.variable + '}}';\n        } else if (node.condition) {\n            try {\n                var condition = resolve(node.condition);\n                if (condition || condition === 0) {\n                    return node.then.map(render_node).join('');\n                }\n            } catch (error) { console.error('Error while processing condition ' + JSON.stringify(node.variable)); }\n            return '';\n        } else { console.error('Error rendering tooltip due to unknown AST node ' + JSON.stringify(node)); }\n    };\n    return ast.map(render_node).join('');\n};\n\n/**\n * Shortcut method for getting the data bound to a tool tip.\n * @param {Element} node\n * @returns {*} The first element of data bound to the tooltip\n */\nLocusZoom.getToolTipData = function(node) {\n    if (typeof node != 'object' || typeof node.parentNode == 'undefined') {\n        throw new Error('Invalid node object');\n    }\n    // If this node is a locuszoom tool tip then return its data\n    var selector = d3.select(node);\n    if (selector.classed('lz-data_layer-tooltip') && typeof selector.data()[0] != 'undefined') {\n        return selector.data()[0];\n    } else {\n        return LocusZoom.getToolTipData(node.parentNode);\n    }\n};\n\n/**\n * Shortcut method for getting a reference to the data layer that generated a tool tip.\n * @param {Element} node The element associated with the tooltip, or any element contained inside the tooltip\n * @returns {LocusZoom.DataLayer}\n */\nLocusZoom.getToolTipDataLayer = function(node) {\n    var data = LocusZoom.getToolTipData(node);\n    if (data.getDataLayer) { return data.getDataLayer(); }\n    return null;\n};\n\n/**\n * Shortcut method for getting a reference to the panel that generated a tool tip.\n * @param {Element} node The element associated with the tooltip, or any element contained inside the tooltip\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.getToolTipPanel = function(node) {\n    var data_layer = LocusZoom.getToolTipDataLayer(node);\n    if (data_layer) { return data_layer.parent; }\n    return null;\n};\n\n/**\n * Shortcut method for getting a reference to the plot that generated a tool tip.\n * @param {Element} node The element associated with the tooltip, or any element contained inside the tooltip\n * @returns {LocusZoom.Plot}\n */\nLocusZoom.getToolTipPlot = function(node) {\n    var panel = LocusZoom.getToolTipPanel(node);\n    if (panel) { return panel.parent; }\n    return null;\n};\n\n/**\n * Generate a curtain object for a plot, panel, or any other subdivision of a layout\n * The panel curtain, like the plot curtain is an HTML overlay that obscures the entire panel. It can be styled\n *   arbitrarily and display arbitrary messages. It is useful for reporting error messages visually to an end user\n *   when the error renders the panel unusable.\n *   TODO: Improve type doc here\n * @returns {object}\n */\nLocusZoom.generateCurtain = function() {\n    var curtain = {\n        showing: false,\n        selector: null,\n        content_selector: null,\n        hide_delay: null,\n\n        /**\n         * Generate the curtain. Any content (string) argument passed will be displayed in the curtain as raw HTML.\n         *   CSS (object) can be passed which will apply styles to the curtain and its content.\n         * @param {string} content Content to be displayed on the curtain (as raw HTML)\n         * @param {object} css Apply the specified styles to the curtain and its contents\n         */\n        show: function(content, css) {\n            if (!this.curtain.showing) {\n                this.curtain.selector = d3.select(this.parent_plot.svg.node().parentNode).insert('div')\n                    .attr('class', 'lz-curtain').attr('id', this.id + '.curtain');\n                this.curtain.content_selector = this.curtain.selector.append('div').attr('class', 'lz-curtain-content');\n                this.curtain.selector.append('div').attr('class', 'lz-curtain-dismiss').html('Dismiss')\n                    .on('click', function() {\n                        this.curtain.hide();\n                    }.bind(this));\n                this.curtain.showing = true;\n            }\n            return this.curtain.update(content, css);\n        }.bind(this),\n\n        /**\n         * Update the content and css of the curtain that's currently being shown. This method also adjusts the size\n         *   and positioning of the curtain to ensure it still covers the entire panel with no overlap.\n         * @param {string} content Content to be displayed on the curtain (as raw HTML)\n         * @param {object} css Apply the specified styles to the curtain and its contents\n         */\n        update: function(content, css) {\n            if (!this.curtain.showing) { return this.curtain; }\n            clearTimeout(this.curtain.hide_delay);\n            // Apply CSS if provided\n            if (typeof css == 'object') {\n                this.curtain.selector.style(css);\n            }\n            // Update size and position\n            var page_origin = this.getPageOrigin();\n            this.curtain.selector.style({\n                top: page_origin.y + 'px',\n                left: page_origin.x + 'px',\n                width: this.layout.width + 'px',\n                height: this.layout.height + 'px'\n            });\n            this.curtain.content_selector.style({\n                'max-width': (this.layout.width - 40) + 'px',\n                'max-height': (this.layout.height - 40) + 'px'\n            });\n            // Apply content if provided\n            if (typeof content == 'string') {\n                this.curtain.content_selector.html(content);\n            }\n            return this.curtain;\n        }.bind(this),\n\n        /**\n         * Remove the curtain\n         * @param {number} delay Time to wait (in ms)\n         */\n        hide: function(delay) {\n            if (!this.curtain.showing) { return this.curtain; }\n            // If a delay was passed then defer to a timeout\n            if (typeof delay == 'number') {\n                clearTimeout(this.curtain.hide_delay);\n                this.curtain.hide_delay = setTimeout(this.curtain.hide, delay);\n                return this.curtain;\n            }\n            // Remove curtain\n            this.curtain.selector.remove();\n            this.curtain.selector = null;\n            this.curtain.content_selector = null;\n            this.curtain.showing = false;\n            return this.curtain;\n        }.bind(this)\n    };\n    return curtain;\n};\n\n/**\n * Generate a loader object for a plot, panel, or any other subdivision of a layout\n *\n * The panel loader is a small HTML overlay that appears in the lower left corner of the panel. It cannot be styled\n *   arbitrarily, but can show a custom message and show a minimalist loading bar that can be updated to specific\n *   completion percentages or be animated.\n * TODO Improve type documentation\n * @returns {object}\n */\nLocusZoom.generateLoader = function() {\n    var loader = {\n        showing: false,\n        selector: null,\n        content_selector: null,\n        progress_selector: null,\n        cancel_selector: null,\n\n        /**\n         * Show a loading indicator\n         * @param {string} [content='Loading...'] Loading message (displayed as raw HTML)\n         */\n        show: function(content) {\n            // Generate loader\n            if (!this.loader.showing) {\n                this.loader.selector = d3.select(this.parent_plot.svg.node().parentNode).insert('div')\n                    .attr('class', 'lz-loader').attr('id', this.id + '.loader');\n                this.loader.content_selector = this.loader.selector.append('div')\n                    .attr('class', 'lz-loader-content');\n                this.loader.progress_selector = this.loader.selector\n                    .append('div').attr('class', 'lz-loader-progress-container')\n                    .append('div').attr('class', 'lz-loader-progress');\n                /* TODO: figure out how to make this cancel button work\n                this.loader.cancel_selector = this.loader.selector.append(\"div\")\n                    .attr(\"class\", \"lz-loader-cancel\").html(\"Cancel\")\n                    .on(\"click\", function(){\n                        this.loader.hide();\n                    }.bind(this));\n                */\n                this.loader.showing = true;\n                if (typeof content == 'undefined') { content = 'Loading...'; }\n            }\n            return this.loader.update(content);\n        }.bind(this),\n\n        /**\n         * Update the currently displayed loader and ensure the new content is positioned correctly.\n         * @param {string} content The text to display (as raw HTML). If not a string, will be ignored.\n         * @param {number} [percent] A number from 1-100. If a value is specified, it will stop all animations\n         *   in progress.\n         */\n        update: function(content, percent) {\n            if (!this.loader.showing) { return this.loader; }\n            clearTimeout(this.loader.hide_delay);\n            // Apply content if provided\n            if (typeof content == 'string') {\n                this.loader.content_selector.html(content);\n            }\n            // Update size and position\n            var padding = 6; // is there a better place to store/define this?\n            var page_origin = this.getPageOrigin();\n            var loader_boundrect = this.loader.selector.node().getBoundingClientRect();\n            this.loader.selector.style({\n                top: (page_origin.y + this.layout.height - loader_boundrect.height - padding) + 'px',\n                left: (page_origin.x + padding) + 'px'\n            });\n            /* Uncomment this code when a functional cancel button can be shown\n            var cancel_boundrect = this.loader.cancel_selector.node().getBoundingClientRect();\n            this.loader.content_selector.style({\n                \"padding-right\": (cancel_boundrect.width + padding) + \"px\"\n            });\n            */\n            // Apply percent if provided\n            if (typeof percent == 'number') {\n                this.loader.progress_selector.style({\n                    width: (Math.min(Math.max(percent, 1), 100)) + '%'\n                });\n            }\n            return this.loader;\n        }.bind(this),\n\n        /**\n         * Adds a class to the loading bar that makes it loop infinitely in a loading animation. Useful when exact\n         *   percent progress is not available.\n         */\n        animate: function() {\n            this.loader.progress_selector.classed('lz-loader-progress-animated', true);\n            return this.loader;\n        }.bind(this),\n\n        /**\n         *  Sets the loading bar in the loader to percentage width equal to the percent (number) value passed. Percents\n         *    will automatically be limited to a range of 1 to 100. Will stop all animations in progress.\n         */\n        setPercentCompleted: function(percent) {\n            this.loader.progress_selector.classed('lz-loader-progress-animated', false);\n            return this.loader.update(null, percent);\n        }.bind(this),\n\n        /**\n         * Remove the loader\n         * @param {number} delay Time to wait (in ms)\n         */\n        hide: function(delay) {\n            if (!this.loader.showing) { return this.loader; }\n            // If a delay was passed then defer to a timeout\n            if (typeof delay == 'number') {\n                clearTimeout(this.loader.hide_delay);\n                this.loader.hide_delay = setTimeout(this.loader.hide, delay);\n                return this.loader;\n            }\n            // Remove loader\n            this.loader.selector.remove();\n            this.loader.selector = null;\n            this.loader.content_selector = null;\n            this.loader.progress_selector = null;\n            this.loader.cancel_selector = null;\n            this.loader.showing = false;\n            return this.loader;\n        }.bind(this)\n    };\n    return loader;\n};\n\n/**\n * Create a new subclass following classical inheritance patterns. Some registry singletons use this internally to\n *   enable code reuse and customization of known LZ core functionality.\n *\n * @param {Function} parent A parent class constructor that will be extended by the child class\n * @param {Object} extra An object of additional properties and methods to add/override behavior for the child class.\n *   The special \"constructor\" property can be used to specify a custom constructor, or it will call parent by default.\n *   Implementer must manage super calls when overriding the constructor.\n * @returns {Function} The constructor for the new child class\n */\nLocusZoom.subclass = function(parent, extra) {\n    if (typeof parent !== 'function' ) {\n        throw new Error('Parent must be a callable constructor');\n    }\n\n    extra = extra || {};\n    var Sub = extra.hasOwnProperty('constructor') ? extra.constructor : function() {\n        parent.apply(this, arguments);\n    };\n\n    Sub.prototype = Object.create(parent.prototype);\n    Object.keys(extra).forEach(function(k) {\n        Sub.prototype[k] = extra[k];\n    });\n    return Sub;\n};\n\n\n/**\n * LocusZoom optional extensions will live under this namespace.\n *\n * Extension code is not part of the core LocusZoom app.js bundle.\n * @namespace\n * @public\n */\nLocusZoom.ext = {};\n","/* global LocusZoom */\n'use strict';\n\nfunction validateBuildSource(class_name, build, source) {\n    // Build OR Source, not both\n    if ((build && source) || !(build || source)) {\n        throw new Error(class_name + ' must provide a parameter specifying either \"build\" or \"source\". It should not specify both.');\n    }\n    // If the build isn't recognized, our APIs can't transparently select a source to match\n    if (build && ['GRCh37', 'GRCh38'].indexOf(build) === -1) {\n        throw new Error(class_name + ' must specify a valid genome build number');\n    }\n}\n\n/**\n * LocusZoom functionality used for data parsing and retrieval\n * @namespace\n * @public\n */\nLocusZoom.Data = LocusZoom.Data ||  {};\n\n/**\n * Create and coordinate an ensemble of (namespaced) data source instances\n * @public\n * @class\n */\nLocusZoom.DataSources = function() {\n    /** @member {Object.<string, LocusZoom.Data.Source>} */\n    this.sources = {};\n};\n\n/** @deprecated */\nLocusZoom.DataSources.prototype.addSource = function(ns, x) {\n    console.warn('Warning: .addSource() is deprecated. Use .add() instead');\n    return this.add(ns, x);\n};\n\n/**\n * Add a (namespaced) datasource to the plot\n * @public\n * @param {String} ns A namespace used for fields from this data source\n * @param {LocusZoom.Data.Source|Array|null} x An instantiated datasource, or an array of arguments that can be used to\n *   create a known datasource type.\n */\nLocusZoom.DataSources.prototype.add = function(ns, x) {\n    // FIXME: Some existing sites create sources with arbitrary names. This leads to subtle breakage\n    //    of namespaced fields in layouts. To avoid breaking existing usages outright, issue a deprecation warning.\n    if (ns.match(/[^A-Za-z0-9_]/)) {\n        console.warn(\"Deprecation warning: source name '\" + ns + \"' should contain only alphanumeric characters or underscores. Use of other characters may break layouts, and will be disallowed in the future.\");\n    }\n    return this.set(ns, x);\n};\n\n/** @protected */\nLocusZoom.DataSources.prototype.set = function(ns, x) {\n    if (Array.isArray(x)) {\n        // If passed array of source name and options, make the source\n        var dsobj = LocusZoom.KnownDataSources.create.apply(null, x);\n        // Each datasource in the chain should be aware of its assigned namespace\n        dsobj.source_id = ns;\n        this.sources[ns] = dsobj;\n    } else {\n        // If passed the already-created source object\n        if (x !== null) {\n            x.source_id = ns;\n            this.sources[ns] = x;\n        } else {\n            delete this.sources[ns];\n        }\n    }\n    return this;\n};\n\n/** @deprecated */\nLocusZoom.DataSources.prototype.getSource = function(ns) {\n    console.warn('Warning: .getSource() is deprecated. Use .get() instead');\n    return this.get(ns);\n};\n\n/**\n * Return the datasource associated with a given namespace\n * @public\n * @param {String} ns Namespace\n * @returns {LocusZoom.Data.Source}\n */\nLocusZoom.DataSources.prototype.get = function(ns) {\n    return this.sources[ns];\n};\n\n/** @deprecated */\nLocusZoom.DataSources.prototype.removeSource = function(ns) {\n    console.warn('Warning: .removeSource() is deprecated. Use .remove() instead');\n    return this.remove(ns);\n};\n\n/**\n * Remove the datasource associated with a given namespace\n * @public\n * @param {String} ns Namespace\n */\nLocusZoom.DataSources.prototype.remove = function(ns) {\n    return this.set(ns, null);\n};\n\n/**\n * Populate a list of datasources specified as a JSON object\n * @public\n * @param {String|Object} x An object or JSON representation containing {ns: configArray} entries\n * @returns {LocusZoom.DataSources}\n */\nLocusZoom.DataSources.prototype.fromJSON = function(x) {\n    if (typeof x === 'string') {\n        x = JSON.parse(x);\n    }\n    var ds = this;\n    Object.keys(x).forEach(function(ns) {\n        ds.set(ns, x[ns]);\n    });\n    return ds;\n};\n\n/**\n * Return the names of all currently recognized datasources\n * @public\n * @returns {Array}\n */\nLocusZoom.DataSources.prototype.keys = function() {\n    return Object.keys(this.sources);\n};\n\n/**\n * Datasources can be instantiated from a JSON object instead of code. This represents existing sources in that format.\n *   For example, this can be helpful when sharing plots, or to share settings with others when debugging\n * @public\n */\nLocusZoom.DataSources.prototype.toJSON = function() {\n    return this.sources;\n};\n\n/**\n * Represents an addressable unit of data from a namespaced datasource, subject to specified value transformations.\n *\n * When used by a data layer, fields will automatically be re-fetched from the appropriate data source whenever the\n *   state of a plot fetches, eg pan or zoom operations that would affect what data is displayed.\n *\n * @public\n * @class\n * @param {String} field A string representing the namespace of the datasource, the name of the desired field to fetch\n *   from that datasource, and arbitrarily many transformations to apply to the value. The namespace and\n *   transformation(s) are optional and information is delimited according to the general syntax\n *   `[namespace:]name[|transformation][|transformation]`. For example, `association:pvalue|neglog10`\n */\nLocusZoom.Data.Field = function(field) {\n\n    var parts = /^(?:([^:]+):)?([^:|]*)(\\|.+)*$/.exec(field);\n    /** @member {String} */\n    this.full_name = field;\n    /** @member {String} */\n    this.namespace = parts[1] || null;\n    /** @member {String} */\n    this.name = parts[2] || null;\n    /** @member {Array} */\n    this.transformations = [];\n\n    if (typeof parts[3] == 'string' && parts[3].length > 1) {\n        this.transformations = parts[3].substring(1).split('|');\n        this.transformations.forEach(function(transform, i) {\n            this.transformations[i] = LocusZoom.TransformationFunctions.get(transform);\n        }.bind(this));\n    }\n\n    this.applyTransformations = function(val) {\n        this.transformations.forEach(function(transform) {\n            val = transform(val);\n        });\n        return val;\n    };\n\n    // Resolve the field for a given data element.\n    // First look for a full match with transformations already applied by the data requester.\n    // Otherwise prefer a namespace match and fall back to just a name match, applying transformations on the fly.\n    this.resolve = function(d) {\n        if (typeof d[this.full_name] == 'undefined') {\n            var val = null;\n            if (typeof (d[this.namespace + ':' + this.name]) != 'undefined') { val = d[this.namespace + ':' + this.name]; }\n            else if (typeof d[this.name] != 'undefined') { val = d[this.name]; }\n            d[this.full_name] = this.applyTransformations(val);\n        }\n        return d[this.full_name];\n    };\n\n};\n\n/**\n * The Requester manages fetching of data across multiple data sources. It is used internally by LocusZoom data layers.\n *   It passes state information and ensures that data is formatted in the manner expected by the plot.\n *\n * It is also responsible for constructing a \"chain\" of dependent requests, by requesting each datasource\n *   sequentially in the order specified in the datalayer `fields` array. Data sources are only chained within a\n *   data layer, and only if that layer requests more than one kind of data source.\n * @param {LocusZoom.DataSources} sources An object of {ns: LocusZoom.Data.Source} instances\n * @class\n */\nLocusZoom.Data.Requester = function(sources) {\n\n    function split_requests(fields) {\n        // Given a fields array, return an object specifying what datasource names the data layer should make requests\n        //  to, and how to handle the returned data\n        var requests = {};\n        // Regular expression finds namespace:field|trans\n        var re = /^(?:([^:]+):)?([^:|]*)(\\|.+)*$/;\n        fields.forEach(function(raw) {\n            var parts = re.exec(raw);\n            var ns = parts[1] || 'base';\n            var field = parts[2];\n            var trans = LocusZoom.TransformationFunctions.get(parts[3]);\n            if (typeof requests[ns] == 'undefined') {\n                requests[ns] = {outnames:[], fields:[], trans:[]};\n            }\n            requests[ns].outnames.push(raw);\n            requests[ns].fields.push(field);\n            requests[ns].trans.push(trans);\n        });\n        return requests;\n    }\n\n    /**\n     * Fetch data, and create a chain that only connects two data sources if they depend on each other\n     * @param {Object} state The current \"state\" of the plot, such as chromosome and start/end positions\n     * @param {String[]} fields The list of data fields specified in the `layout` for a specific data layer\n     * @returns {Promise}\n     */\n    this.getData = function(state, fields) {\n        var requests = split_requests(fields);\n        // Create an array of functions that, when called, will trigger the request to the specified datasource\n        var request_handles = Object.keys(requests).map(function(key) {\n            if (!sources.get(key)) {\n                throw new Error('Datasource for namespace ' + key + ' not found');\n            }\n            return sources.get(key).getData(state, requests[key].fields,\n                                            requests[key].outnames, requests[key].trans);\n        });\n        //assume the fields are requested in dependent order\n        //TODO: better manage dependencies\n        var ret = Promise.resolve({header:{}, body: [], discrete: {}});\n        for(var i = 0; i < request_handles.length; i++) {\n            // If a single datalayer uses multiple sources, perform the next request when the previous one completes\n            ret = ret.then(request_handles[i]);\n        }\n        return ret;\n    };\n};\n\n/**\n * Base class for LocusZoom data sources\n * This can be extended with .extend() to create custom data sources\n * @class\n * @public\n */\nLocusZoom.Data.Source = function() {\n    /**\n     * Whether this source should enable caching\n     * @member {Boolean}\n     */\n    this.enableCache = true;\n    /**\n     * Whether this data source type is dependent on previous requests- for example, the LD source cannot annotate\n     *  association data if no data was found for that region.\n     * @member {boolean}\n     */\n    this.dependentSource = false;\n};\n\n/**\n * A default constructor that can be used when creating new data sources\n * @param {String|Object} init Basic configuration- either a url, or a config object\n * @param {String} [init.url] The datasource URL\n * @param {String} [init.params] Initial config params for the datasource\n */\nLocusZoom.Data.Source.prototype.parseInit = function(init) {\n    if (typeof init === 'string') {\n        /** @member {String} */\n        this.url = init;\n        /** @member {String} */\n        this.params = {};\n    } else {\n        this.url = init.url;\n        this.params = init.params || {};\n    }\n    if (!this.url) {\n        throw new Error('Source not initialized with required URL');\n    }\n\n};\n\n/**\n * A unique identifier that indicates whether cached data is valid for this request\n * @protected\n * @param state\n * @param chain\n * @param fields\n * @returns {String|undefined}\n */\nLocusZoom.Data.Source.prototype.getCacheKey = function(state, chain, fields) {\n    return this.getURL && this.getURL(state, chain, fields);\n};\n\n/**\n * Stub: build the URL for any requests made by this source.\n */\nLocusZoom.Data.Source.prototype.getURL = function(state, chain, fields) { return this.url; };\n\n/**\n * Perform a network request to fetch data for this source\n * @protected\n * @param {Object} state The state of the parent plot\n * @param chain\n * @param fields\n * @returns {Promise}\n */\nLocusZoom.Data.Source.prototype.fetchRequest = function(state, chain, fields) {\n    var url = this.getURL(state, chain, fields);\n    return LocusZoom.createCORSPromise('GET', url);\n};\n\n/**\n * Gets the data for just this source, typically via a network request (caching where possible)\n * @protected\n */\nLocusZoom.Data.Source.prototype.getRequest = function(state, chain, fields) {\n    var req;\n    var cacheKey = this.getCacheKey(state, chain, fields);\n    if (this.enableCache && typeof(cacheKey) !== 'undefined' && cacheKey === this._cachedKey) {\n        req = Promise.resolve(this._cachedResponse);  // Resolve to the value of the current promise\n    } else {\n        req = this.fetchRequest(state, chain, fields);\n        if (this.enableCache) {\n            this._cachedKey = cacheKey;\n            this._cachedResponse = req;\n        }\n    }\n    return req;\n};\n\n/**\n * Fetch the data from the specified data source, and apply transformations requested by an external consumer.\n * This is the public-facing datasource method that will most commonly be called by external code.\n *\n * @public\n * @param {Object} state The current \"state\" of the plot, such as chromosome and start/end positions\n * @param {String[]} fields Array of field names that the plot has requested from this data source. (without the \"namespace\" prefix)\n * @param {String[]} outnames  Array describing how the output data should refer to this field. This represents the\n *     originally requested field name, including the namespace. This must be an array with the same length as `fields`\n * @param {Function[]} trans The collection of transformation functions to be run on selected fields.\n *     This must be an array with the same length as `fields`\n * @returns {function} A callable operation that can be used as part of the data chain\n */\nLocusZoom.Data.Source.prototype.getData = function(state, fields, outnames, trans) {\n    if (this.preGetData) {\n        var pre = this.preGetData(state, fields, outnames, trans);\n        if(this.pre) {\n            state = pre.state || state;\n            fields = pre.fields || fields;\n            outnames = pre.outnames || outnames;\n            trans = pre.trans || trans;\n        }\n    }\n\n    var self = this;\n    return function (chain) {\n        if (self.dependentSource && chain && chain.body && !chain.body.length) {\n            // A \"dependent\" source should not attempt to fire a request if there is no data for it to act on.\n            // Therefore, it should simply return the previous data chain.\n            return Promise.resolve(chain);\n        }\n\n        return self.getRequest(state, chain, fields).then(function(resp) {\n            return self.parseResponse(resp, chain, fields, outnames, trans);\n        });\n    };\n};\n\n/**\n * Ensure the server response is in a canonical form, an array of one object per record. [ {field: oneval} ].\n * If the server response contains columns, reformats the response from {column1: [], column2: []} to the above.\n *\n * Does not apply namespacing, transformations, or field extraction.\n *\n * May be overridden by data sources that inherently return more complex payloads, or that exist to annotate other\n *  sources (eg, if the payload provides extra data rather than a series of records).\n *\n * @param {Object[]|Object} data The original parsed server response\n * @protected\n */\nLocusZoom.Data.Source.prototype.normalizeResponse = function (data) {\n    if (Array.isArray(data)) {\n        // Already in the desired form\n        return data;\n    }\n\n    // Otherwise, assume the server response is an object representing columns of data.\n    // Each array should have the same length (verify), and a given array index corresponds to a single row.\n    var keys = Object.keys(data);\n    var N = data[keys[0]].length;\n    var sameLength = keys.every(function(key) {\n        var item = data[key];\n        return item.length === N;\n    });\n    if (!sameLength) {\n        throw new Error(this.constructor.SOURCE_NAME + ' expects a response in which all arrays of data are the same length');\n    }\n\n    // Go down the rows, and create an object for each record\n    var records = [];\n    var fields = Object.keys(data);\n    for(var i = 0; i < N; i++) {\n        var record = {};\n        for(var j = 0; j < fields.length; j++) {\n            record[fields[j]] = data[fields[j]][i];\n        }\n        records.push(record);\n    }\n    return records;\n};\n\n/** @deprecated */\nLocusZoom.Data.Source.prototype.prepareData = function (records) {\n    console.warn('Warning: .prepareData() is deprecated. Use .annotateData() instead');\n    return this.annotateData(records);\n};\n\n/**\n * Hook to post-process the data returned by this source with new, additional behavior.\n *   (eg cleaning up API values or performing complex calculations on the returned data)\n *\n * @param {Object[]} records The parsed data from the source (eg standardized api response)\n * @param {Object} chain The data chain object. For example, chain.headers may provide useful annotation metadata\n * @returns {Object[]|Promise} The modified set of records\n */\nLocusZoom.Data.Source.prototype.annotateData = function(records, chain) {\n    // Default behavior: no transformations\n    return records;\n};\n\n/**\n * Clean up the server records for use by datalayers: extract only certain fields, with the specified names.\n *   Apply per-field transformations as appropriate.\n *\n * This hook can be overridden, eg to create a source that always returns all records and ignores the \"fields\" array.\n *  This is particularly common for sources at the end of a chain- many \"dependent\" sources do not allow\n *  cherry-picking individual fields, in which case by **convention** the fields array specifies \"last_source_name:all\"\n *\n * @param {Object[]} data One record object per element\n * @param {String[]} fields The names of fields to extract (as named in the source data). Eg \"afield\"\n * @param {String[]} outnames How to represent the source fields in the output. Eg \"namespace:afield|atransform\"\n * @param {function[]} trans An array of transformation functions (if any). One function per data element, or null.\n * @protected\n */\nLocusZoom.Data.Source.prototype.extractFields = function (data, fields, outnames, trans) {\n    //intended for an array of objects\n    //  [ {\"id\":1, \"val\":5}, {\"id\":2, \"val\":10}]\n    // Since a number of sources exist that do not obey this format, we will provide a convenient pass-through\n    if (!Array.isArray(data)) {\n        return data;\n    }\n\n    if (!data.length) {\n        // Sometimes there are regions that just don't have data- this should not trigger a missing field error message!\n        return data;\n    }\n\n    var fieldFound = [];\n    for (var k = 0; k < fields.length; k++) {\n        fieldFound[k] = 0;\n    }\n\n    var records = data.map(function (item) {\n        var output_record = {};\n        for (var j = 0; j < fields.length; j++) {\n            var val = item[fields[j]];\n            if (typeof val != 'undefined') {\n                fieldFound[j] = 1;\n            }\n            if (trans && trans[j]) {\n                val = trans[j](val);\n            }\n            output_record[outnames[j]] = val;\n        }\n        return output_record;\n    });\n    fieldFound.forEach(function(v, i) {\n        if (!v) {throw new Error('field ' + fields[i] + ' not found in response for ' + outnames[i]);}\n    });\n    return records;\n};\n\n/**\n * Combine records from this source with others in the chain to yield final chain body.\n *   Handles merging this data with other sources (if applicable).\n *\n * @param {Object[]} data The data That would be returned from this source alone\n * @param {Object} chain The data chain built up during previous requests\n * @param {String[]} fields\n * @param {String[]} outnames\n * @return {Promise|Object[]} The new chain body\n * @protected\n */\nLocusZoom.Data.Source.prototype.combineChainBody = function (data, chain, fields, outnames, trans) {\n    return data;\n};\n\n/**\n * Coordinates the work of parsing a response and returning records. This is broken into 4 steps, which may be\n *  overridden separately for fine-grained control. Each step can return either raw data or a promise.\n *\n * @public\n * @param {String|Object} resp The raw data associated with the response\n * @param {Object} chain The combined parsed response data from this and all other requests made in the chain\n * @param {String[]} fields Array of requested field names (as they would appear in the response payload)\n * @param {String[]} outnames  Array of field names as they will be represented in the data returned by this source,\n *  including the namespace. This must be an array with the same length as `fields`\n * @param {Function[]} trans The collection of transformation functions to be run on selected fields.\n *     This must be an array with the same length as `fields`\n * @returns {Promise|{header: ({}|*), discrete: {}, body: []}} A promise that resolves to an object containing\n *   request metadata (headers), the consolidated data for plotting (body), and the individual responses that would be\n *   returned by each source in the chain in isolation (discrete)\n */\nLocusZoom.Data.Source.prototype.parseResponse = function(resp, chain, fields, outnames, trans) {\n    var source_id = this.source_id || this.constructor.SOURCE_NAME;\n    if (!chain.discrete) {\n        chain.discrete = {};\n    }\n\n    if (!resp) {\n        // FIXME: Hack. Certain browser issues (such as mixed content warnings) are reported as a successful promise\n        //  resolution, even though the request was aborted. This is difficult to reliably detect, and is most likely\n        // to occur for annotation sources (such as from ExAC). If empty response is received, skip parsing and log.\n        // FIXME: Throw an error after pending, eg https://github.com/konradjk/exac_browser/issues/345\n        console.error(\"No usable response was returned for source: '\" + source_id + \"'. Parsing will be skipped.\");\n        return Promise.resolve(chain);\n    }\n\n    var json = typeof resp == 'string' ? JSON.parse(resp) : resp;\n\n    var self = this;\n    // Perform the 4 steps of parsing the payload and return a combined chain object\n    return Promise.resolve(self.normalizeResponse(json.data || json))\n        .then(function(standardized) {\n            // Perform calculations on the data from just this source\n            return Promise.resolve(self.annotateData(standardized, chain));\n        }).then(function (data) {\n            return Promise.resolve(self.extractFields(data, fields, outnames, trans));\n        }).then(function (one_source_body) {\n            // Store a copy of the data that would be returned by parsing this source in isolation (and taking the\n            //   fields array into account). This is useful when we want to re-use the source output in many ways.\n            chain.discrete[source_id] = one_source_body;\n            return Promise.resolve(self.combineChainBody(one_source_body, chain, fields, outnames, trans));\n        }).then(function (new_body) {\n            return { header: chain.header || {}, discrete: chain.discrete, body: new_body };\n        });\n};\n\n/** @deprecated */\nLocusZoom.Data.Source.prototype.parseArraysToObjects = function(data, fields, outnames, trans) {\n    console.warn('Warning: .parseArraysToObjects() is no longer used. A stub is provided for legacy use');\n    var standard = this.normalizeResponse(data);\n    return this.extractFields(standard, fields, outnames, trans);\n};\n\n/** @deprecated */\nLocusZoom.Data.Source.prototype.parseObjectsToObjects = function(data, fields, outnames, trans) {\n    console.warn('Warning: .parseObjectsToObjects() is deprecated. Use .extractFields() instead');\n    return this.extractFields(data, fields, outnames, trans);\n};\n\n/** @deprecated */\nLocusZoom.Data.Source.prototype.parseData = function(data, fields, outnames, trans) {\n    console.warn('Warning: .parseData() is no longer used. A stub is provided for legacy use');\n    var standard = this.normalizeResponse(data);\n    return this.extractFields(standard, fields, outnames, trans);\n};\n\n/**\n * Method to define new custom datasources based on a provided constructor. (does not allow registering any additional methods)\n * @public\n * @param {Function} constructorFun Constructor function that is used to create the specified class\n * @param {String} [uniqueName] The name by which the class should be listed in `KnownDataSources`\n * @param {String|Function} [base=LocusZoomData.Source] The name or constructor of a base class to use\n * @returns {*|Function}\n */\nLocusZoom.Data.Source.extend = function(constructorFun, uniqueName, base) {\n    if (base) {\n        if (Array.isArray(base)) {\n            base = LocusZoom.KnownDataSources.create.apply(null, base);\n        } else if (typeof base === 'string') {\n            base = LocusZoom.KnownDataSources.get(base).prototype;\n        } else if (typeof base === 'function') {\n            base = base.prototype;\n        }\n    } else {\n        base =  new LocusZoom.Data.Source();\n    }\n    constructorFun = constructorFun || function() {};\n    constructorFun.prototype = base;\n    constructorFun.prototype.constructor = constructorFun;\n    if (uniqueName) {\n        /** @member {String} LocusZoom.Data.Source.SOURCENAME */\n        constructorFun.SOURCE_NAME = uniqueName;\n        LocusZoom.KnownDataSources.add(constructorFun);\n    }\n    return constructorFun;\n};\n\n/**\n * Datasources can be instantiated from a JSON object instead of code. This represents an existing source in that data format.\n *   For example, this can be helpful when sharing plots, or to share settings with others when debugging\n *\n * Custom sources with their own parameters may need to re-implement this method\n *\n * @public\n * @returns {Object}\n */\nLocusZoom.Data.Source.prototype.toJSON = function() {\n    return [Object.getPrototypeOf(this).constructor.SOURCE_NAME,\n        {url:this.url, params:this.params}];\n};\n\n/**\n * Data Source for Association Data, as fetched from the LocusZoom API server (or compatible)\n * @class\n * @public\n * @augments LocusZoom.Data.Source\n */\nLocusZoom.Data.AssociationSource = LocusZoom.Data.Source.extend(function(init) {\n    this.parseInit(init);\n}, 'AssociationLZ');\n\nLocusZoom.Data.AssociationSource.prototype.preGetData = function(state, fields, outnames, trans) {\n    var id_field = this.params.id_field || 'id';\n    [id_field, 'position'].forEach(function(x) {\n        if (fields.indexOf(x) === -1) {\n            fields.unshift(x);\n            outnames.unshift(x);\n            trans.unshift(null);\n        }\n    });\n    return {fields: fields, outnames:outnames, trans:trans};\n};\n\nLocusZoom.Data.AssociationSource.prototype.getURL = function(state, chain, fields) {\n    var analysis = chain.header.analysis || this.params.source || this.params.analysis;  // Old usages called this param \"analysis\"\n    if (typeof analysis == 'undefined') {\n        throw new Error('Association source must specify an analysis ID to plot');\n    }\n    return this.url + 'results/?filter=analysis in ' + analysis  +\n        \" and chromosome in  '\" + state.chr + \"'\" +\n        ' and position ge ' + state.start +\n        ' and position le ' + state.end;\n};\n\nLocusZoom.Data.AssociationSource.prototype.normalizeResponse = function (data) {\n    // Some association sources do not sort their data in a predictable order, which makes it hard to reliably\n    //  align with other sources (such as LD). For performance reasons, sorting is an opt-in argument.\n    // TODO: Consider more fine grained sorting control in the future\n    data = LocusZoom.Data.Source.prototype.normalizeResponse.call(this, data);\n    if (this.params && this.params.sort && data.length && data[0]['position']) {\n        data.sort(function (a, b) { return a['position'] - b['position']; });\n    }\n    return data;\n};\n\n/**\n * Data Source for LD Data, as fetched from the LocusZoom API server (or compatible)\n * This source is designed to connect its results to association data, and therefore depends on association data having\n *  been loaded by a previous request in the data chain.\n *\n *  This source is deprecated in favor of a new, standalone LD server. For new usages, see LDLZ2.\n *\n * @class\n * @deprecated\n * @public\n * @augments LocusZoom.Data.Source\n */\nLocusZoom.Data.LDSource = LocusZoom.Data.Source.extend(function(init) {\n    this.parseInit(init);\n    this.dependentSource = true;\n}, 'LDLZ');\n\nLocusZoom.Data.LDSource.prototype.preGetData = function(state, fields) {\n    if (fields.length > 1) {\n        if (fields.length !== 2 || fields.indexOf('isrefvar') === -1) {\n            throw new Error('LD does not know how to get all fields: ' + fields.join(', '));\n        }\n    }\n};\n\nLocusZoom.Data.LDSource.prototype.findMergeFields = function(chain) {\n    // Find the fields (as provided by a previous step in the chain) that are needed to combine with LD data\n\n    // Since LD information may be shared across multiple assoc sources with different namespaces,\n    //   we use regex to find columns to join on, rather than requiring exact matches\n    var exactMatch = function(arr) {return function() {\n        var regexes = arguments;\n        for(var i = 0; i < regexes.length; i++) {\n            var regex = regexes[i];\n            var m = arr.filter(function(x) {return x.match(regex);});\n            if (m.length) {\n                return m[0];\n            }\n        }\n        return null;\n    };};\n    var dataFields = {\n        id: this.params.id_field,\n        position: this.params.position_field,\n        pvalue: this.params.pvalue_field,\n        _names_:null\n    };\n    if (chain && chain.body && chain.body.length > 0) {\n        var names = Object.keys(chain.body[0]);\n        var nameMatch = exactMatch(names);\n        dataFields.id = dataFields.id || nameMatch(/\\bvariant\\b/) || nameMatch(/\\bid\\b/);\n        dataFields.position = dataFields.position || nameMatch(/\\bposition\\b/i, /\\bpos\\b/i);\n        dataFields.pvalue = dataFields.pvalue || nameMatch(/\\bpvalue\\b/i, /\\blog_pvalue\\b/i);\n        dataFields._names_ = names;\n    }\n    return dataFields;\n};\n\nLocusZoom.Data.LDSource.prototype.findRequestedFields = function(fields, outnames) {\n    // Assumption: all usages of this source will only ever ask for \"isrefvar\" or \"state\". This maps to output names.\n    var obj = {};\n    for(var i = 0; i < fields.length; i++) {\n        if(fields[i] === 'isrefvar') {\n            obj.isrefvarin = fields[i];\n            obj.isrefvarout = outnames && outnames[i];\n        } else {\n            obj.ldin = fields[i];\n            obj.ldout = outnames && outnames[i];\n        }\n    }\n    return obj;\n};\n\nLocusZoom.Data.LDSource.prototype.normalizeResponse = function (data) { return data; };\n\n\nLocusZoom.Data.LDSource.prototype.getRefvar = function (state, chain, fields) {\n    var findExtremeValue = function(records, pval_field) {\n        // Finds the most significant hit (smallest pvalue, or largest -log10p). Will try to auto-detect the appropriate comparison.\n        pval_field = pval_field || 'log_pvalue';  // The official LZ API returns log_pvalue\n        var is_log = /log/.test(pval_field);\n        var cmp;\n        if (is_log) {\n            cmp = function(a, b) { return a > b; };\n        } else {\n            cmp = function(a, b) { return a < b; };\n        }\n        var extremeVal = records[0][pval_field], extremeIdx = 0;\n        for(var i = 1; i < records.length; i++) {\n            if (cmp(records[i][pval_field], extremeVal)) {\n                extremeVal = records[i][pval_field];\n                extremeIdx = i;\n            }\n        }\n        return extremeIdx;\n    };\n\n    var reqFields = this.findRequestedFields(fields);\n    var refVar = reqFields.ldin;\n    if (refVar === 'state') {\n        refVar = state.ldrefvar || chain.header.ldrefvar || 'best';\n    }\n    if (refVar === 'best') {\n        if (!chain.body) {\n            throw new Error('No association data found to find best pvalue');\n        }\n        var keys = this.findMergeFields(chain);\n        if (!keys.pvalue || !keys.id) {\n            var columns = '';\n            if (!keys.id) { columns += (columns.length ? ', ' : '') + 'id'; }\n            if (!keys.pvalue) { columns += (columns.length ? ', ' : '') + 'pvalue'; }\n            throw new Error('Unable to find necessary column(s) for merge: ' + columns + ' (available: ' + keys._names_ + ')');\n        }\n        refVar = chain.body[findExtremeValue(chain.body, keys.pvalue)][keys.id];\n    }\n    return refVar;\n};\n\nLocusZoom.Data.LDSource.prototype.getURL = function(state, chain, fields) {\n    var refSource = state.ldrefsource || chain.header.ldrefsource || 1;\n    var refVar = this.getRefvar(state, chain, fields);\n    chain.header.ldrefvar = refVar;\n    return this.url + 'results/?filter=reference eq ' + refSource +\n        \" and chromosome2 eq '\" + state.chr + \"'\" +\n        ' and position2 ge ' + state.start +\n        ' and position2 le ' + state.end +\n        \" and variant1 eq '\" + refVar + \"'\" +\n        '&fields=chr,pos,rsquare';\n};\n\nLocusZoom.Data.LDSource.prototype.combineChainBody = function (data, chain, fields, outnames, trans) {\n    var keys = this.findMergeFields(chain);\n    var reqFields = this.findRequestedFields(fields, outnames);\n    if (!keys.position) {\n        throw new Error('Unable to find position field for merge: ' + keys._names_);\n    }\n    var leftJoin = function(left, right, lfield, rfield) {\n        var i = 0, j = 0;\n        while (i < left.length && j < right.position2.length) {\n            if (left[i][keys.position] === right.position2[j]) {\n                left[i][lfield] = right[rfield][j];\n                i++;\n                j++;\n            } else if (left[i][keys.position] < right.position2[j]) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n    };\n    var tagRefVariant = function(data, refvar, idfield, outrefname, outldname) {\n        for(var i = 0; i < data.length; i++) {\n            if (data[i][idfield] && data[i][idfield] === refvar) {\n                data[i][outrefname] = 1;\n                data[i][outldname] = 1; // For label/filter purposes, implicitly mark the ref var as LD=1 to itself\n            } else {\n                data[i][outrefname] = 0;\n            }\n        }\n    };\n\n    // LD servers vary slightly. Some report corr as \"rsquare\", others as \"correlation\"\n    var corrField = data.rsquare ? 'rsquare' : 'correlation';\n    leftJoin(chain.body, data, reqFields.ldout, corrField);\n    if(reqFields.isrefvarin && chain.header.ldrefvar) {\n        tagRefVariant(chain.body, chain.header.ldrefvar, keys.id, reqFields.isrefvarout, reqFields.ldout);\n    }\n    return chain.body;\n};\n\n/**\n * Fetch LD directly from the standalone Portal LD server\n *\n * @class\n * @public\n * @augments LocusZoom.Data.LDSource\n */\nLocusZoom.Data.LDSource2 = LocusZoom.KnownDataSources.extend('LDLZ', 'LDLZ2', {\n    getURL: function(state, chain, fields) {\n        // Accept the following params in this.params:\n        // - method (r, rsquare, cov)\n        // - source (aka panel)\n        // - population (ALL, AFR, EUR, etc)\n        // - build\n        // The LD source/pop can be overridden from plot.state for dynamic layouts\n        var build = state.genome_build || this.params.build || 'GRCh37';\n        var source = state.ld_source || this.params.source || '1000G';\n        var population = state.ld_pop || this.params.population || 'ALL';  // LDServer panels will always have an ALL\n        var method = this.params.method || 'rsquare';\n\n        validateBuildSource(this.constructor.SOURCE_NAME, build, null);  // LD doesn't need to validate `source` option\n\n        var refVar = this.getRefvar(state, chain, fields);\n        chain.header.ldrefvar = refVar;\n\n        return  [\n            this.url, 'genome_builds/', build, '/references/', source, '/populations/', population, '/variants',\n            '?correlation=', method,\n            '&variant=', encodeURIComponent(refVar),\n            '&chrom=', encodeURIComponent(state.chr),\n            '&start=', encodeURIComponent(state.start),\n            '&stop=', encodeURIComponent(state.end)\n        ].join('');\n    },\n    fetchRequest: function(state, chain, fields) {\n        // The API is paginated, but we need all of the data to render a plot. Depaginate and combine where appropriate.\n        var url = this.getURL(state, chain, fields);\n        var combined = { data: {} };\n        var chainRequests = function (url) {\n            return LocusZoom.createCORSPromise('GET', url)\n                .then(function(payload) {\n                    payload = JSON.parse(payload);\n                    Object.keys(payload.data).forEach(function (key) {\n                        combined.data[key] = (combined.data[key] || []).concat(payload.data[key]);\n                    });\n                    if (payload.next) {\n                        return chainRequests(payload.next);\n                    }\n                    return combined;\n                });\n        };\n\n        return chainRequests(url);\n    }\n});\n\n/**\n * Data source for GWAS catalogs of known variants\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n * @param {Object|String} init Configuration (URL or object)\n * @param {Object} [init.params] Optional configuration parameters\n * @param {Number} [init.params.source=2] The ID of the chosen catalog. Defaults to EBI GWAS catalog, GRCh37\n * @param {('strict'|'loose')} [init.params.match_type='strict'] Whether to match on exact variant, or just position.\n */\nLocusZoom.Data.GwasCatalog = LocusZoom.Data.Source.extend(function(init) {\n    this.parseInit(init);\n    this.dependentSource = true;\n}, 'GwasCatalogLZ');\n\nLocusZoom.Data.GwasCatalog.prototype.getURL = function(state, chain, fields) {\n    // This is intended to be aligned with another source- we will assume they are always ordered by position, asc\n    //  (regardless of the actual match field)\n    var build_option = state.genome_build || this.params.build;\n    validateBuildSource(this.constructor.SOURCE_NAME, build_option, null); // Source can override build- not mutually exclusive\n\n    // Most of our annotations will respect genome build before any other option.\n    //   But there can be more than one GWAS catalog for the same build, so an explicit config option will always take\n    //   precedence.\n    var default_source = (build_option === 'GRCh38') ? 1 : 2;  // EBI GWAS catalog\n    var source = this.params.source || default_source;\n    return this.url + '?format=objects&sort=pos&filter=id eq ' + source +\n        \" and chrom eq '\" + state.chr + \"'\" +\n        ' and pos ge ' + state.start +\n        ' and pos le ' + state.end;\n};\n\nLocusZoom.Data.GwasCatalog.prototype.findMergeFields = function (records) {\n    // Data from previous sources is already namespaced. Find the alignment field by matching.\n    var knownFields = Object.keys(records);\n    // Note: All API endoints involved only give results for 1 chromosome at a time; match is implied\n    var posMatch = knownFields.find(function (item) { return item.match(/\\b(position|pos)\\b/i); });\n\n    if (!posMatch) {\n        throw new Error('Could not find data to align with GWAS catalog results');\n    }\n    return { 'pos': posMatch };\n};\n\n// Skip the \"individual field extraction\" step; extraction will be handled when building chain body instead\nLocusZoom.Data.GwasCatalog.prototype.extractFields = function (data, fields, outnames, trans) { return data; };\n\nLocusZoom.Data.GwasCatalog.prototype.combineChainBody = function (data, chain, fields, outnames, trans) {\n    if (!data.length) {\n        return chain.body;\n    }\n\n    var decider = 'log_pvalue'; //  TODO: Better reuse options in the future\n    var decider_out = outnames[fields.indexOf(decider)];\n\n    function leftJoin(left, right, fields, outnames, trans) { // Add `fields` from `right` to `left`\n        // Add a synthetic, un-namespaced field to all matching records\n        var n_matches = left['n_catalog_matches'] || 0;\n        left['n_catalog_matches'] = n_matches + 1;\n        if (decider && left[decider_out] && left[decider_out] > right[decider]) {\n            // There may be more than one GWAS catalog entry for the same SNP. This source is intended for a 1:1\n            //  annotation scenario, so for now it only joins the catalog entry that has the best -log10 pvalue\n            return;\n        }\n\n        for (var j = 0; j < fields.length; j++) {\n            var fn = fields[j];\n            var outn = outnames[j];\n\n            var val = right[fn];\n            if (trans && trans[j]) {\n                val = trans[j](val);\n            }\n            left[outn] = val;\n        }\n    }\n\n    var chainNames = this.findMergeFields(chain.body[0]);\n    var catNames = this.findMergeFields(data[0]);\n\n    var i = 0, j = 0;\n    while (i < chain.body.length && j < data.length) {\n        var left = chain.body[i];\n        var right = data[j];\n\n        if (left[chainNames.pos] === right[catNames.pos]) {\n            // There may be multiple catalog entries for each matching SNP; evaluate match one at a time\n            leftJoin(left, right, fields, outnames, trans);\n            j += 1;\n        } else if (left[chainNames.pos] < right[catNames.pos]) {\n            i += 1;\n        } else {\n            j += 1;\n        }\n    }\n    return chain.body;\n};\n\n\n/**\n * Data Source for Gene Data, as fetched from the LocusZoom API server (or compatible)\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n */\nLocusZoom.Data.GeneSource = LocusZoom.Data.Source.extend(function(init) {\n    this.parseInit(init);\n}, 'GeneLZ');\n\nLocusZoom.Data.GeneSource.prototype.getURL = function(state, chain, fields) {\n    var build = state.genome_build || this.params.build;\n    var source = this.params.source;\n    validateBuildSource(this.constructor.SOURCE_NAME, build, source);\n\n    if (build) { // If build specified, choose a known Portal API dataset IDs (build 37/38)\n        source = (build === 'GRCh38') ? 1 : 3;\n    }\n    return this.url + '?filter=source in ' + source +\n        \" and chrom eq '\" + state.chr + \"'\" +\n        ' and start le ' + state.end +\n        ' and end ge ' + state.start;\n};\n\n// Genes have a very complex internal data format. Bypass any record parsing, and provide the data layer with the\n// exact information returned by the API. (ignoring the fields array in the layout)\nLocusZoom.Data.GeneSource.prototype.normalizeResponse = function (data) { return data; };\nLocusZoom.Data.GeneSource.prototype.extractFields = function (data, fields, outnames, trans) { return data; };\n\n/**\n * Data Source for Gene Constraint Data, as fetched from the LocusZoom API server (or compatible)\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n*/\nLocusZoom.Data.GeneConstraintSource = LocusZoom.Data.Source.extend(function(init) {\n    this.parseInit(init);\n}, 'GeneConstraintLZ');\n\nLocusZoom.Data.GeneConstraintSource.prototype.getURL = function() {\n    return this.url;\n};\n\nLocusZoom.Data.GeneConstraintSource.prototype.normalizeResponse = function (data) { return data; };\n\nLocusZoom.Data.GeneConstraintSource.prototype.getCacheKey = function(state, chain, fields) {\n    return this.url + JSON.stringify(state);\n};\n\nLocusZoom.Data.GeneConstraintSource.prototype.fetchRequest = function(state, chain, fields) {\n    var geneids = [];\n    chain.body.forEach(function(gene) {\n        var gene_id = gene.gene_id;\n        if (gene_id.indexOf('.')) {\n            gene_id = gene_id.substr(0, gene_id.indexOf('.'));\n        }\n        geneids.push(gene_id);\n    });\n    var url = this.getURL(state, chain, fields);\n    var body = 'geneids=' + encodeURIComponent(JSON.stringify(geneids));\n    var headers = {\n        'Content-Type': 'application/x-www-form-urlencoded'\n    };\n    return LocusZoom.createCORSPromise('POST', url, body, headers);\n};\n\nLocusZoom.Data.GeneConstraintSource.prototype.combineChainBody = function (data, chain, fields, outnames, trans) {\n    if (!data) {\n        return chain;\n    }\n    var constraint_fields = ['bp', 'exp_lof', 'exp_mis', 'exp_syn', 'lof_z', 'mis_z', 'mu_lof', 'mu_mis','mu_syn', 'n_exons', 'n_lof', 'n_mis', 'n_syn', 'pLI', 'syn_z'];\n    chain.body.forEach(function(gene, i) {\n        var gene_id = gene.gene_id;\n        if (gene_id.indexOf('.')) {\n            gene_id = gene_id.substr(0, gene_id.indexOf('.'));\n        }\n        constraint_fields.forEach(function(field) {\n            // Do not overwrite any fields defined in the original gene source\n            if (typeof chain.body[i][field] != 'undefined') { return; }\n            if (data[gene_id]) {\n                var val = data[gene_id][field];\n                if (typeof val == 'number' && val.toString().indexOf('.') !== -1) {\n                    val = parseFloat(val.toFixed(2));\n                }\n                chain.body[i][field] = val;\n            } else {\n                // If the gene did not come back in the response then set the same field with a null values\n                chain.body[i][field] = null;\n            }\n        });\n    });\n    return chain.body;\n};\n\n/**\n * Data Source for Recombination Rate Data, as fetched from the LocusZoom API server (or compatible)\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n */\nLocusZoom.Data.RecombinationRateSource = LocusZoom.Data.Source.extend(function(init) {\n    this.parseInit(init);\n}, 'RecombLZ');\n\nLocusZoom.Data.RecombinationRateSource.prototype.getURL = function(state, chain, fields) {\n    var build = state.genome_build || this.params.build;\n    var source = this.params.source;\n    validateBuildSource(this.constructor.SOURCE_NAME, build, source);\n\n    if (build) { // If build specified, choose a known Portal API dataset IDs (build 37/38)\n        source = (build === 'GRCh38') ? 16 : 15;\n    }\n    return this.url + '?filter=id in ' + source +\n        \" and chromosome eq '\" + state.chr + \"'\" +\n        ' and position le ' + state.end +\n        ' and position ge ' + state.start;\n};\n\n/**\n * Data Source for Interval Annotation Data (e.g. BED Tracks), as fetched from the LocusZoom API server (or compatible)\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n */\nLocusZoom.Data.IntervalSource = LocusZoom.Data.Source.extend(function(init) {\n    this.parseInit(init);\n}, 'IntervalLZ');\n\nLocusZoom.Data.IntervalSource.prototype.getURL = function(state, chain, fields) {\n    var source = chain.header.bedtracksource || this.params.source;\n    return this.url + '?filter=id in ' + source +\n        \" and chromosome eq '\" + state.chr + \"'\" +\n        ' and start le ' + state.end +\n        ' and end ge ' + state.start;\n};\n\n/**\n * Data Source for static blobs of JSON Data. This does not perform additional parsing, and therefore it is the\n * responsibility of the user to pass information in a format that can be read and understood by the chosen plot.\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n */\nLocusZoom.Data.StaticSource = LocusZoom.Data.Source.extend(function(data) {\n    /** @member {Object} */\n    this._data = data;\n},'StaticJSON');\n\nLocusZoom.Data.StaticSource.prototype.getRequest = function(state, chain, fields) {\n    return Promise.resolve(this._data);\n};\n\nLocusZoom.Data.StaticSource.prototype.toJSON = function() {\n    return [Object.getPrototypeOf(this).constructor.SOURCE_NAME, this._data];\n};\n\n/**\n * Data source for PheWAS data\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n * @param {String[]} init.params.build This datasource expects to be provided the name of the genome build that will\n *   be used to provide pheWAS results for this position. Note positions may not translate between builds.\n */\nLocusZoom.Data.PheWASSource = LocusZoom.Data.Source.extend(function(init) {\n    this.parseInit(init);\n}, 'PheWASLZ');\nLocusZoom.Data.PheWASSource.prototype.getURL = function(state, chain, fields) {\n    var build = (state.genome_build ? [state.genome_build] : null) || this.params.build;\n    if (!build || !Array.isArray(build) || !build.length) {\n        throw new Error(['Data source', this.constructor.SOURCE_NAME, 'requires that you specify array of one or more desired genome build names'].join(' '));\n    }\n    var url = [\n        this.url,\n        \"?filter=variant eq '\", encodeURIComponent(state.variant), \"'&format=objects&\",\n        build.map(function(item) {return 'build=' + encodeURIComponent(item);}).join('&')\n    ];\n    return url.join('');\n};\n\n/**\n * Base class for \"connectors\"- this is meant to be subclassed, rather than used directly.\n *\n * A connector is a source that makes no server requests and caches no data of its own. Instead, it decides how to\n *  combine data from other sources in the chain. Connectors are useful when we want to request (or calculate) some\n *  useful piece of information once, but apply it to many different kinds of record types.\n *\n * Typically, a subclass will implement the field merging logic in `combineChainBody`.\n *\n * @public\n * @class\n * @augments LocusZoom.Data.Source\n * @param {Object} init Configuration for this source\n * @param {Object} init.sources Specify how the hard-coded logic should find the data it relies on in the chain,\n *  as {internal_name: chain_source_id} pairs. This allows writing a reusable connector that does not need to make\n *  assumptions about what namespaces a source is using.\n * @type {*|Function}\n */\nLocusZoom.Data.ConnectorSource = LocusZoom.Data.Source.extend(function(init) {\n    if (!init || !init.sources) {\n        throw new Error('Connectors must specify the data they require as init.sources = {internal_name: chain_source_id}} pairs');\n    }\n\n    /**\n     * Tells the connector how to find the data it relies on\n     *\n     * For example, a connector that applies burden test information to the genes layer might specify:\n     *  {gene_ns: \"gene\", aggregation_ns: \"aggregation\"}\n     *\n     * @member {Object}\n     */\n    this._source_name_mapping = init.sources;\n\n    // Validate that this source has been told how to find the required information\n    var specified_ids = Object.keys(init.sources);\n    var self = this;\n    this.REQUIRED_SOURCES.forEach(function (k) {\n        if (specified_ids.indexOf(k) === -1) {\n            throw new Error('Configuration for ' + self.constructor.SOURCE_NAME + ' must specify a source ID corresponding to ' + k);\n        }\n    });\n    this.parseInit(init);\n}, 'ConnectorSource');\n\n/** @property {String[]} Specifies the sources that must be provided in the original config object */\nLocusZoom.Data.ConnectorSource.prototype.REQUIRED_SOURCES = [];\n\nLocusZoom.Data.ConnectorSource.prototype.parseInit = function(init) {};  // Stub\n\nLocusZoom.Data.ConnectorSource.prototype.getRequest = function(state, chain, fields) {\n    // Connectors do not request their own data by definition, but they *do* depend on other sources having been loaded\n    //  first. This method performs basic validation, and preserves the accumulated body from the chain so far.\n    var self = this;\n    Object.keys(this._source_name_mapping).forEach(function(ns) {\n        var chain_source_id = self._source_name_mapping[ns];\n        if (chain.discrete && !chain.discrete[chain_source_id]) {\n            throw new Error(self.constructor.SOURCE_NAME + ' cannot be used before loading required data for: ' + chain_source_id);\n        }\n    });\n    return Promise.resolve(chain.body || []);\n};\n\nLocusZoom.Data.ConnectorSource.prototype.parseResponse = function(data, chain, fields, outnames, trans) {\n    // A connector source does not update chain.discrete, but it may use it. It bypasses data formatting\n    //  and field selection (both are assumed to have been done already, by the previous sources this draws from)\n\n    // Because of how the chain works, connectors are not very good at applying new transformations or namespacing.\n    // Typically connectors are called with `connector_name:all` in the fields array.\n    return Promise.resolve(this.combineChainBody(data, chain, fields, outnames, trans))\n        .then(function(new_body) {\n            return {header: chain.header || {}, discrete: chain.discrete || {}, body: new_body};\n        });\n};\n\nLocusZoom.Data.ConnectorSource.prototype.combineChainBody = function(records, chain) {\n    // Stub method: specifies how to combine the data\n    throw new Error('This method must be implemented in a subclass');\n};\n","'use strict';\n\n/**\n * Create a single continuous 2D track that provides information about each datapoint\n *\n * For example, this can be used to color by membership in a group, alongside information in other panels\n *\n * @class LocusZoom.DataLayers.annotation_track\n * @augments LocusZoom.DataLayer\n * @param {Object} layout\n * @param {Object|String} [layout.color]\n * @param {Array[]} An array of filter entries specifying which points to draw annotations for.\n *  See `LocusZoom.DataLayer.filter` for details\n */\nLocusZoom.DataLayers.add('annotation_track', function(layout) {\n    // In the future we may add additional options for controlling marker size/ shape, based on user feedback\n    this.DefaultLayout = {\n        color: '#000000',\n        filters: [],\n        tooltip_positioning: 'middle', // Allowed values: top, middle, bottom\n        hit_area_width: 8,\n    };\n\n    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n\n    if (!Array.isArray(layout.filters)) {\n        throw new Error('Annotation track must specify array of filters for selecting points to annotate');\n    }\n\n    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n    LocusZoom.DataLayer.apply(this, arguments);\n\n    this.render = function() {\n        var self = this;\n        // Only render points that currently satisfy all provided filter conditions.\n        var trackData = this.filter(this.layout.filters, 'elements');\n\n        // Put the <g> containing visible lines before the one containing hit areas, so that the hit areas will be on top.\n        var visible_lines_group = this.svg.group.select('g.lz-data_layer-' + self.layout.type + '-visible_lines');\n        if (visible_lines_group.size() === 0) {\n            visible_lines_group = this.svg.group.append('g').attr('class', 'lz-data_layer-' + self.layout.type + '-visible_lines');\n        }\n        var selection = visible_lines_group.selectAll('rect.lz-data_layer-' + self.layout.type)\n            .data(trackData, function (d) { return d[self.layout.id_field]; });\n\n        // Draw rectangles (visual and tooltip positioning)\n        selection.enter()\n            .append('rect')\n            .attr('class', 'lz-data_layer-' + this.layout.type)\n            .attr('id', function (d) { return self.getElementId(d); });\n\n        var width = 1;\n        selection\n            .attr('x', function (d) {return self.parent['x_scale'](d[self.layout.x_axis.field]) - width / 2; })\n            .attr('width', width)\n            .attr('height', self.parent.layout.height)\n            .attr('fill', function(d) { return self.resolveScalableParameter(self.layout.color, d); });\n\n        // Remove unused elements\n        selection.exit()\n            .remove();\n\n        var hit_areas_group = this.svg.group.select('g.lz-data_layer-' + self.layout.type + '-hit_areas');\n        if (hit_areas_group.size() === 0) {\n            hit_areas_group = this.svg.group.append('g').attr('class', 'lz-data_layer-' + self.layout.type + '-hit_areas');\n        }\n        var hit_areas_selection = hit_areas_group.selectAll('rect.lz-data_layer-' + self.layout.type)\n            .data(trackData, function (d) { return d[self.layout.id_field]; });\n\n        // Add new elements as needed\n        hit_areas_selection.enter()\n            .append('rect')\n            .attr('class', 'lz-data_layer-' + this.layout.type)\n            .attr('id', function (d) { return self.getElementId(d); });\n\n        // Update the set of elements to reflect new data\n\n        var _getX = function (d, i) { // Helper for position calcs below\n            var x_center = self.parent['x_scale'](d[self.layout.x_axis.field]);\n            var x_left = x_center - self.layout.hit_area_width / 2;\n            if (i >= 1) {\n                // This assumes that the data are in sorted order.\n                var left_node = trackData[i - 1];\n                var left_node_x_center = self.parent['x_scale'](left_node[self.layout.x_axis.field]);\n                x_left = Math.max(x_left, (x_center + left_node_x_center) / 2);\n            }\n            return [x_left, x_center];\n        };\n        hit_areas_selection\n            .attr('height', self.parent.layout.height)\n            .attr('opacity', 0)\n            .attr('x', function (d, i) {\n                var crds = _getX(d,i);\n                return crds[0];\n            }).attr('width', function (d, i) {\n                var crds = _getX(d,i);\n                return (crds[1] - crds[0]) + self.layout.hit_area_width / 2;\n            });\n\n        // Remove unused elements\n        hit_areas_selection.exit().remove();\n\n        // Set up tooltips and mouse interaction\n        this.applyBehaviors(hit_areas_selection);\n    };\n\n    // Reimplement the positionTooltip() method to be annotation-specific\n    this.positionTooltip = function(id) {\n        if (typeof id != 'string') {\n            throw new Error('Unable to position tooltip: id is not a string');\n        }\n        if (!this.tooltips[id]) {\n            throw new Error('Unable to position tooltip: id does not point to a valid tooltip');\n        }\n        var top, left, arrow_type, arrow_top, arrow_left;\n        var tooltip = this.tooltips[id];\n        var arrow_width = 7; // as defined in the default stylesheet\n        var stroke_width = 1; // as defined in the default stylesheet\n        var offset = stroke_width / 2;\n        var page_origin = this.getPageOrigin();\n\n        var tooltip_box = tooltip.selector.node().getBoundingClientRect();\n        var data_layer_height = this.parent.layout.height - (this.parent.layout.margin.top + this.parent.layout.margin.bottom);\n        var data_layer_width = this.parent.layout.width - (this.parent.layout.margin.left + this.parent.layout.margin.right);\n\n        var x_center = this.parent.x_scale(tooltip.data[this.layout.x_axis.field]);\n        var y_center = data_layer_height / 2;\n\n        // Tooltip should be horizontally centered above the point to be annotated. (or below if space is limited)\n        var offset_right = Math.max((tooltip_box.width / 2) - x_center, 0);\n        var offset_left = Math.max((tooltip_box.width / 2) + x_center - data_layer_width, 0);\n        left = page_origin.x + x_center - (tooltip_box.width / 2) - offset_left + offset_right;\n        arrow_left = (tooltip_box.width / 2) - (arrow_width) + offset_left - offset_right - offset;\n\n        var top_offset = 0;\n        switch(this.layout.tooltip_positioning) {\n        case 'top':\n            arrow_type = 'down';\n            break;\n        case 'bottom':\n            top_offset = data_layer_height;\n            arrow_type = 'up';\n            break;\n        case 'middle':\n        default:\n            var position = d3.mouse(this.svg.container.node());\n            // Position the tooltip so that it does not overlap the mouse pointer\n            top_offset = y_center;\n            if (position[1] > (data_layer_height / 2)) {\n                arrow_type = 'down';\n            } else {\n                arrow_type = 'up';\n            }\n        }\n\n        if (arrow_type === 'up') {\n            top = page_origin.y + top_offset + stroke_width + arrow_width;\n            arrow_top = 0 - stroke_width - arrow_width;\n        } else if (arrow_type === 'down') {\n            top = page_origin.y + top_offset - (tooltip_box.height + stroke_width + arrow_width);\n            arrow_top = tooltip_box.height - stroke_width;\n        }\n\n        // Apply positions to the main div\n        tooltip.selector.style('left', left + 'px').style('top', top + 'px');\n        // Create / update position on arrow connecting tooltip to data\n        if (!tooltip.arrow) {\n            tooltip.arrow = tooltip.selector.append('div').style('position', 'absolute');\n        }\n        tooltip.arrow\n            .attr('class', 'lz-data_layer-tooltip-arrow_' + arrow_type)\n            .style('left', arrow_left + 'px')\n            .style('top', arrow_top + 'px');\n    };\n\n    return this;\n});\n","'use strict';\n\n/**\n * Forest Data Layer\n * Implements a standard forest plot. In order to space out points, any layout using this must specify axis ticks\n *  and extent in advance.\n *\n * If you are using dynamically fetched data, consider using `category_forest` instead.\n *\n * @class LocusZoom.DataLayers.forest\n */\nLocusZoom.DataLayers.add('forest', function(layout) {\n\n    // Define a default layout for this DataLayer type and merge it with the passed argument\n    this.DefaultLayout = {\n        point_size: 40,\n        point_shape: 'square',\n        color: '#888888',\n        fill_opacity: 1,\n        y_axis: {\n            axis: 2\n        },\n        id_field: 'id',\n        confidence_intervals: {\n            start_field: 'ci_start',\n            end_field: 'ci_end'\n        },\n        show_no_significance_line: true\n    };\n    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n\n    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n    LocusZoom.DataLayer.apply(this, arguments);\n\n    // Reimplement the positionTooltip() method to be forest-specific\n    this.positionTooltip = function(id) {\n        if (typeof id != 'string') {\n            throw new Error('Unable to position tooltip: id is not a string');\n        }\n        if (!this.tooltips[id]) {\n            throw new Error('Unable to position tooltip: id does not point to a valid tooltip');\n        }\n        var tooltip = this.tooltips[id];\n        var point_size = this.resolveScalableParameter(this.layout.point_size, tooltip.data);\n        var arrow_width = 7; // as defined in the default stylesheet\n        var stroke_width = 1; // as defined in the default stylesheet\n        var border_radius = 6; // as defined in the default stylesheet\n        var page_origin = this.getPageOrigin();\n        var x_center = this.parent.x_scale(tooltip.data[this.layout.x_axis.field]);\n        var y_scale  = 'y' + this.layout.y_axis.axis + '_scale';\n        var y_center = this.parent[y_scale](tooltip.data[this.layout.y_axis.field]);\n        var tooltip_box = tooltip.selector.node().getBoundingClientRect();\n        // Position horizontally on the left or the right depending on which side of the plot the point is on\n        var offset = Math.sqrt(point_size / Math.PI);\n        var left, arrow_type, arrow_left;\n        if (x_center <= this.parent.layout.width / 2) {\n            left = page_origin.x + x_center + offset + arrow_width + stroke_width;\n            arrow_type = 'left';\n            arrow_left = -1 * (arrow_width + stroke_width);\n        } else {\n            left = page_origin.x + x_center - tooltip_box.width - offset - arrow_width - stroke_width;\n            arrow_type = 'right';\n            arrow_left = tooltip_box.width - stroke_width;\n        }\n        // Position vertically centered unless we're at the top or bottom of the plot\n        var data_layer_height = this.parent.layout.height - (this.parent.layout.margin.top + this.parent.layout.margin.bottom);\n        var top, arrow_top;\n        if (y_center - (tooltip_box.height / 2) <= 0) { // Too close to the top, push it down\n            top = page_origin.y + y_center - (1.5 * arrow_width) - border_radius;\n            arrow_top = border_radius;\n        } else if (y_center + (tooltip_box.height / 2) >= data_layer_height) { // Too close to the bottom, pull it up\n            top = page_origin.y + y_center + arrow_width + border_radius - tooltip_box.height;\n            arrow_top = tooltip_box.height - (2 * arrow_width) - border_radius;\n        } else { // vertically centered\n            top = page_origin.y + y_center - (tooltip_box.height / 2);\n            arrow_top = (tooltip_box.height / 2) - arrow_width;\n        }\n        // Apply positions to the main div\n        tooltip.selector.style('left', left + 'px').style('top', top + 'px');\n        // Create / update position on arrow connecting tooltip to data\n        if (!tooltip.arrow) {\n            tooltip.arrow = tooltip.selector.append('div').style('position', 'absolute');\n        }\n        tooltip.arrow\n            .attr('class', 'lz-data_layer-tooltip-arrow_' + arrow_type)\n            .style('left', arrow_left + 'px')\n            .style('top', arrow_top + 'px');\n    };\n\n    // Implement the main render function\n    this.render = function() {\n\n        var x_scale = 'x_scale';\n        var y_scale = 'y' + this.layout.y_axis.axis + '_scale';\n\n        // Generate confidence interval paths if fields are defined\n        if (this.layout.confidence_intervals\n            && this.layout.fields.indexOf(this.layout.confidence_intervals.start_field) !== -1\n            && this.layout.fields.indexOf(this.layout.confidence_intervals.end_field) !== -1) {\n            // Generate a selection for all forest plot confidence intervals\n            var ci_selection = this.svg.group\n                .selectAll('rect.lz-data_layer-forest.lz-data_layer-forest-ci')\n                .data(this.data, function(d) { return d[this.layout.id_field]; }.bind(this));\n            // Create confidence interval rect elements\n            ci_selection.enter()\n                .append('rect')\n                .attr('class', 'lz-data_layer-forest lz-data_layer-forest-ci')\n                .attr('id', function(d) { return this.getElementId(d) + '_ci'; }.bind(this))\n                .attr('transform', 'translate(0,' + (isNaN(this.parent.layout.height) ? 0 : this.parent.layout.height) + ')');\n            // Apply position and size parameters using transition if necessary\n            var ci_transform = function(d) {\n                var x = this.parent[x_scale](d[this.layout.confidence_intervals.start_field]);\n                var y = this.parent[y_scale](d[this.layout.y_axis.field]);\n                if (isNaN(x)) { x = -1000; }\n                if (isNaN(y)) { y = -1000; }\n                return 'translate(' + x + ',' + y + ')';\n            }.bind(this);\n            var ci_width = function(d) {\n                return this.parent[x_scale](d[this.layout.confidence_intervals.end_field])\n                     - this.parent[x_scale](d[this.layout.confidence_intervals.start_field]);\n            }.bind(this);\n            var ci_height = 1;\n            if (this.canTransition()) {\n                ci_selection\n                    .transition()\n                    .duration(this.layout.transition.duration || 0)\n                    .ease(this.layout.transition.ease || 'cubic-in-out')\n                    .attr('transform', ci_transform)\n                    .attr('width', ci_width).attr('height', ci_height);\n            } else {\n                ci_selection\n                    .attr('transform', ci_transform)\n                    .attr('width', ci_width).attr('height', ci_height);\n            }\n            // Remove old elements as needed\n            ci_selection.exit().remove();\n        }\n\n        // Generate a selection for all forest plot points\n        var points_selection = this.svg.group\n            .selectAll('path.lz-data_layer-forest.lz-data_layer-forest-point')\n            .data(this.data, function(d) { return d[this.layout.id_field]; }.bind(this));\n\n        // Create elements, apply class, ID, and initial position\n        var initial_y = isNaN(this.parent.layout.height) ? 0 : this.parent.layout.height;\n        points_selection.enter()\n            .append('path')\n            .attr('class', 'lz-data_layer-forest lz-data_layer-forest-point')\n            .attr('id', function(d) { return this.getElementId(d); }.bind(this))\n            .attr('transform', 'translate(0,' + initial_y + ')');\n\n        // Generate new values (or functions for them) for position, color, size, and shape\n        var transform = function(d) {\n            var x = this.parent[x_scale](d[this.layout.x_axis.field]);\n            var y = this.parent[y_scale](d[this.layout.y_axis.field]);\n            if (isNaN(x)) { x = -1000; }\n            if (isNaN(y)) { y = -1000; }\n            return 'translate(' + x + ',' + y + ')';\n        }.bind(this);\n\n        var fill = function(d) { return this.resolveScalableParameter(this.layout.color, d); }.bind(this);\n        var fill_opacity = function(d) { return this.resolveScalableParameter(this.layout.fill_opacity, d); }.bind(this);\n\n        var shape = d3.svg.symbol()\n            .size(function(d) { return this.resolveScalableParameter(this.layout.point_size, d); }.bind(this))\n            .type(function(d) { return this.resolveScalableParameter(this.layout.point_shape, d); }.bind(this));\n\n        // Apply position and color, using a transition if necessary\n        if (this.canTransition()) {\n            points_selection\n                .transition()\n                .duration(this.layout.transition.duration || 0)\n                .ease(this.layout.transition.ease || 'cubic-in-out')\n                .attr('transform', transform)\n                .attr('fill', fill)\n                .attr('fill-opacity', fill_opacity)\n                .attr('d', shape);\n        } else {\n            points_selection\n                .attr('transform', transform)\n                .attr('fill', fill)\n                .attr('fill-opacity', fill_opacity)\n                .attr('d', shape);\n        }\n\n        // Remove old elements as needed\n        points_selection.exit().remove();\n\n        // Apply default event emitters to selection\n        points_selection.on('click.event_emitter', function(element_data) {\n            this.parent.emit('element_clicked', element_data, true);\n        }.bind(this));\n\n        // Apply behaviors to points\n        this.applyBehaviors(points_selection);\n    };\n    return this;\n\n});\n\n/**\n * A y-aligned forest plot in which the y-axis represents item labels, which are dynamically chosen when data is loaded.\n *   Each item is assumed to include both data and confidence intervals.\n *   This allows generating forest plots without defining the layout in advance.\n *\n * @class LocusZoom.DataLayers.category_forest\n * @augments LocusZoom.DataLayers.forest\n */\nLocusZoom.DataLayers.extend('forest', 'category_forest', {\n    _getDataExtent: function(data, axis_config) {\n        // In a forest plot, the data range is determined by *three* fields (beta + CI start/end)\n        var ci_config = this.layout.confidence_intervals;\n        if (ci_config\n            && this.layout.fields.indexOf(ci_config.start_field) !== -1\n            && this.layout.fields.indexOf(ci_config.end_field) !== -1) {\n            var min = function(d) {\n                var f = new LocusZoom.Data.Field(ci_config.start_field);\n                return +f.resolve(d);\n            };\n\n            var max = function(d) {\n                var f = new LocusZoom.Data.Field(ci_config.end_field);\n                return +f.resolve(d);\n            };\n\n            return [d3.min(data, min), d3.max(data, max)];\n        }\n\n        // If there are no confidence intervals set, then range must depend only on a single field\n        return LocusZoom.DataLayer.prototype._getDataExtent.call(this, data, axis_config);\n    },\n\n    getTicks: function(dimension, config) { // Overrides parent method\n        if (['x', 'y1', 'y2'].indexOf(dimension) === -1) {\n            throw new Error('Invalid dimension identifier' + dimension);\n        }\n\n        // Design assumption: one axis (y1 or y2) has the ticks, and the layout says which to use\n        // Also assumes that every tick gets assigned a unique matching label\n        var axis_num = this.layout.y_axis.axis;\n        if (dimension === ('y' + axis_num)) {\n            var category_field = this.layout.y_axis.category_field;\n            if (!category_field) {\n                throw new Error('Layout for ' + this.layout.id + ' must specify category_field');\n            }\n\n            return this.data.map(function (item, index) {\n                return {\n                    y: index + 1,\n                    text: item[category_field]\n                };\n            });\n        } else {\n            return [];\n        }\n    },\n\n    applyCustomDataMethods: function () {\n        // Add a synthetic yaxis field to ensure data is spread out on plot. Then, set axis floor and ceiling to\n        //  correct extents.\n        var field_to_add = this.layout.y_axis.field;\n        if (!field_to_add) {\n            throw new Error('Layout for ' + this.layout.id + ' must specify yaxis.field');\n        }\n\n        this.data = this.data.map(function (item, index) {\n            item[field_to_add] = index + 1;\n            return item;\n        });\n        // Update axis extents based on one label for every point (with a bit of padding above and below)\n        this.layout.y_axis.floor = 0;\n        this.layout.y_axis.ceiling = this.data.length + 1;\n        return this;\n    }\n});\n","'use strict';\n\n/*********************\n * Genes Data Layer\n * Implements a data layer that will render gene tracks\n * @class\n * @augments LocusZoom.DataLayer\n*/\nLocusZoom.DataLayers.add('genes', function(layout) {\n    /**\n     * Define a default layout for this DataLayer type and merge it with the passed argument\n     * @protected\n     * @member {Object}\n     * */\n    this.DefaultLayout = {\n        // Optionally specify different fill and stroke properties\n        stroke: 'rgb(54, 54, 150)',\n        color: '#363696',\n        label_font_size: 12,\n        label_exon_spacing: 4,\n        exon_height: 16,\n        bounding_box_padding: 6,\n        track_vertical_spacing: 10\n    };\n    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n\n    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n    LocusZoom.DataLayer.apply(this, arguments);\n\n    /**\n     * Generate a statusnode ID for a given element\n     * @override\n     * @returns {String}\n     */\n    this.getElementStatusNodeId = function(element) {\n        return this.getElementId(element) + '-statusnode';\n    };\n\n    /**\n     * Helper function to sum layout values to derive total height for a single gene track\n     * @returns {number}\n     */\n    this.getTrackHeight = function() {\n        return 2 * this.layout.bounding_box_padding\n            + this.layout.label_font_size\n            + this.layout.label_exon_spacing\n            + this.layout.exon_height\n            + this.layout.track_vertical_spacing;\n    };\n\n    /**\n     * A gene may have arbitrarily many transcripts, but this data layer isn't set up to render them yet.\n     * Stash a transcript_idx to point to the first transcript and use that for all transcript refs.\n     * @member {number}\n     * @type {number}\n     */\n    this.transcript_idx = 0;\n\n    /**\n     * An internal counter for the number of tracks in the data layer. Used as an internal counter for looping\n     *   over positions / assignments\n     * @protected\n     * @member {number}\n     */\n    this.tracks = 1;\n\n    /**\n     * Store information about genes in dataset, in a hash indexed by track number: {track_number: [gene_indices]}\n     * @member {Object.<Number, Array>}\n     */\n    this.gene_track_index = { 1: [] };\n\n    /**\n     * Ensure that genes in overlapping chromosome regions are positioned so that parts of different genes do not\n     *   overlap in the view. A track is a row used to vertically separate overlapping genes.\n     * @returns {LocusZoom.DataLayer}\n     */\n    this.assignTracks = function() {\n        /**\n         * Function to get the width in pixels of a label given the text and layout attributes\n         *      TODO: Move to outer scope?\n         * @param {String} gene_name\n         * @param {number|string} font_size\n         * @returns {number}\n         */\n        this.getLabelWidth = function(gene_name, font_size) {\n            try {\n                var temp_text = this.svg.group.append('text')\n                    .attr('x', 0).attr('y', 0).attr('class', 'lz-data_layer-genes lz-label')\n                    .style('font-size', font_size)\n                    .text(gene_name + '');\n                var label_width = temp_text.node().getBBox().width;\n                temp_text.remove();\n                return label_width;\n            } catch (e) {\n                return 0;\n            }\n        };\n\n        // Reinitialize some metadata\n        this.tracks = 1;\n        this.gene_track_index = { 1: [] };\n\n        this.data.map(function(d, g) {\n\n            // If necessary, split combined gene id / version fields into discrete fields.\n            // NOTE: this may be an issue with CSG's genes data source that may eventually be solved upstream.\n            if (this.data[g].gene_id && this.data[g].gene_id.indexOf('.')) {\n                var split = this.data[g].gene_id.split('.');\n                this.data[g].gene_id = split[0];\n                this.data[g].gene_version = split[1];\n            }\n\n            // Stash the transcript ID on the parent gene\n            this.data[g].transcript_id = this.data[g].transcripts[this.transcript_idx].transcript_id;\n\n            // Determine display range start and end, based on minimum allowable gene display width, bounded by what we can see\n            // (range: values in terms of pixels on the screen)\n            this.data[g].display_range = {\n                start: this.parent.x_scale(Math.max(d.start, this.state.start)),\n                end:   this.parent.x_scale(Math.min(d.end, this.state.end))\n            };\n            this.data[g].display_range.label_width = this.getLabelWidth(this.data[g].gene_name, this.layout.label_font_size);\n            this.data[g].display_range.width = this.data[g].display_range.end - this.data[g].display_range.start;\n            // Determine label text anchor (default to middle)\n            this.data[g].display_range.text_anchor = 'middle';\n            if (this.data[g].display_range.width < this.data[g].display_range.label_width) {\n                if (d.start < this.state.start) {\n                    this.data[g].display_range.end = this.data[g].display_range.start\n                        + this.data[g].display_range.label_width\n                        + this.layout.label_font_size;\n                    this.data[g].display_range.text_anchor = 'start';\n                } else if (d.end > this.state.end) {\n                    this.data[g].display_range.start = this.data[g].display_range.end\n                        - this.data[g].display_range.label_width\n                        - this.layout.label_font_size;\n                    this.data[g].display_range.text_anchor = 'end';\n                } else {\n                    var centered_margin = ((this.data[g].display_range.label_width - this.data[g].display_range.width) / 2)\n                        + this.layout.label_font_size;\n                    if ((this.data[g].display_range.start - centered_margin) < this.parent.x_scale(this.state.start)) {\n                        this.data[g].display_range.start = this.parent.x_scale(this.state.start);\n                        this.data[g].display_range.end = this.data[g].display_range.start + this.data[g].display_range.label_width;\n                        this.data[g].display_range.text_anchor = 'start';\n                    } else if ((this.data[g].display_range.end + centered_margin) > this.parent.x_scale(this.state.end)) {\n                        this.data[g].display_range.end = this.parent.x_scale(this.state.end);\n                        this.data[g].display_range.start = this.data[g].display_range.end - this.data[g].display_range.label_width;\n                        this.data[g].display_range.text_anchor = 'end';\n                    } else {\n                        this.data[g].display_range.start -= centered_margin;\n                        this.data[g].display_range.end += centered_margin;\n                    }\n                }\n                this.data[g].display_range.width = this.data[g].display_range.end - this.data[g].display_range.start;\n            }\n            // Add bounding box padding to the calculated display range start, end, and width\n            this.data[g].display_range.start -= this.layout.bounding_box_padding;\n            this.data[g].display_range.end   += this.layout.bounding_box_padding;\n            this.data[g].display_range.width += 2 * this.layout.bounding_box_padding;\n            // Convert and stash display range values into domain values\n            // (domain: values in terms of the data set, e.g. megabases)\n            this.data[g].display_domain = {\n                start: this.parent.x_scale.invert(this.data[g].display_range.start),\n                end:   this.parent.x_scale.invert(this.data[g].display_range.end)\n            };\n            this.data[g].display_domain.width = this.data[g].display_domain.end - this.data[g].display_domain.start;\n\n            // Using display range/domain data generated above cast each gene to tracks such that none overlap\n            this.data[g].track = null;\n            var potential_track = 1;\n            while (this.data[g].track === null) {\n                var collision_on_potential_track = false;\n                this.gene_track_index[potential_track].map(function(placed_gene) {\n                    if (!collision_on_potential_track) {\n                        var min_start = Math.min(placed_gene.display_range.start, this.display_range.start);\n                        var max_end = Math.max(placed_gene.display_range.end, this.display_range.end);\n                        if ((max_end - min_start) < (placed_gene.display_range.width + this.display_range.width)) {\n                            collision_on_potential_track = true;\n                        }\n                    }\n                }.bind(this.data[g]));\n                if (!collision_on_potential_track) {\n                    this.data[g].track = potential_track;\n                    this.gene_track_index[potential_track].push(this.data[g]);\n                } else {\n                    potential_track++;\n                    if (potential_track > this.tracks) {\n                        this.tracks = potential_track;\n                        this.gene_track_index[potential_track] = [];\n                    }\n                }\n            }\n\n            // Stash parent references on all genes, trascripts, and exons\n            this.data[g].parent = this;\n            this.data[g].transcripts.map(function(d, t) {\n                this.data[g].transcripts[t].parent = this.data[g];\n                this.data[g].transcripts[t].exons.map(function(d, e) {\n                    this.data[g].transcripts[t].exons[e].parent = this.data[g].transcripts[t];\n                }.bind(this));\n            }.bind(this));\n\n        }.bind(this));\n        return this;\n    };\n\n    /**\n     * Main render function\n     */\n    this.render = function() {\n\n        var self = this;\n        this.assignTracks();\n\n        var width, height, x, y;\n\n        // Render gene groups\n        var selection = this.svg.group.selectAll('g.lz-data_layer-genes')\n            .data(this.data, function(d) { return d.gene_name; });\n\n        selection.enter().append('g')\n            .attr('class', 'lz-data_layer-genes');\n\n        selection.attr('id', function(d) { return this.getElementId(d); }.bind(this))\n            .each(function(gene) {\n\n                var data_layer = gene.parent;\n\n                // Render gene bounding boxes (status nodes to show selected/highlighted)\n                var bboxes = d3.select(this).selectAll('rect.lz-data_layer-genes.lz-data_layer-genes-statusnode')\n                    .data([gene], function(d) { return data_layer.getElementStatusNodeId(d); });\n\n                bboxes.enter().append('rect')\n                    .attr('class', 'lz-data_layer-genes lz-data_layer-genes-statusnode');\n\n                bboxes\n                    .attr('id', function(d) {\n                        return data_layer.getElementStatusNodeId(d);\n                    })\n                    .attr('rx', function() {\n                        return data_layer.layout.bounding_box_padding;\n                    })\n                    .attr('ry', function() {\n                        return data_layer.layout.bounding_box_padding;\n                    });\n\n                width = function(d) {\n                    return d.display_range.width;\n                };\n                height = function() {\n                    return data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing;\n                };\n                x = function(d) {\n                    return d.display_range.start;\n                };\n                y = function(d) {\n                    return ((d.track - 1) * data_layer.getTrackHeight());\n                };\n                if (data_layer.canTransition()) {\n                    bboxes\n                        .transition()\n                        .duration(data_layer.layout.transition.duration || 0)\n                        .ease(data_layer.layout.transition.ease || 'cubic-in-out')\n                        .attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                } else {\n                    bboxes\n                        .attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                }\n\n                bboxes.exit().remove();\n\n                // Render gene boundaries\n                var boundary_fill = function(d) { return self.resolveScalableParameter(self.layout.color, d); };\n                var boundary_stroke = function(d) { return self.resolveScalableParameter(self.layout.stroke, d); };\n                var boundaries = d3.select(this).selectAll('rect.lz-data_layer-genes.lz-boundary')\n                    .data([gene], function(d) { return d.gene_name + '_boundary'; })\n                    .style({ fill: boundary_fill, stroke: boundary_stroke });\n\n                boundaries.enter().append('rect')\n                    .attr('class', 'lz-data_layer-genes lz-boundary');\n\n                width = function(d) {\n                    return data_layer.parent.x_scale(d.end) - data_layer.parent.x_scale(d.start);\n                };\n                height = function() {\n                    return 1; // TODO: scale dynamically?\n                };\n                x = function(d) {\n                    return data_layer.parent.x_scale(d.start);\n                };\n                y = function(d) {\n                    return ((d.track - 1) * data_layer.getTrackHeight())\n                        + data_layer.layout.bounding_box_padding\n                        + data_layer.layout.label_font_size\n                        + data_layer.layout.label_exon_spacing\n                        + (Math.max(data_layer.layout.exon_height, 3) / 2);\n                };\n                if (data_layer.canTransition()) {\n                    boundaries\n                        .transition()\n                        .duration(data_layer.layout.transition.duration || 0)\n                        .ease(data_layer.layout.transition.ease || 'cubic-in-out')\n                        .attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                } else {\n                    boundaries\n                        .attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                }\n\n                boundaries.exit().remove();\n\n                // Render gene labels\n                var labels = d3.select(this).selectAll('text.lz-data_layer-genes.lz-label')\n                    .data([gene], function(d) { return d.gene_name + '_label'; });\n\n                labels.enter().append('text')\n                    .attr('class', 'lz-data_layer-genes lz-label');\n\n                labels\n                    .attr('text-anchor', function(d) {\n                        return d.display_range.text_anchor;\n                    })\n                    .text(function(d) {\n                        return (d.strand === '+') ? d.gene_name + '' : '' + d.gene_name;\n                    })\n                    .style('font-size', gene.parent.layout.label_font_size);\n\n                x = function(d) {\n                    if (d.display_range.text_anchor === 'middle') {\n                        return d.display_range.start + (d.display_range.width / 2);\n                    } else if (d.display_range.text_anchor === 'start') {\n                        return d.display_range.start + data_layer.layout.bounding_box_padding;\n                    } else if (d.display_range.text_anchor === 'end') {\n                        return d.display_range.end - data_layer.layout.bounding_box_padding;\n                    }\n                };\n                y = function(d) {\n                    return ((d.track - 1) * data_layer.getTrackHeight())\n                        + data_layer.layout.bounding_box_padding\n                        + data_layer.layout.label_font_size;\n                };\n                if (data_layer.canTransition()) {\n                    labels\n                        .transition()\n                        .duration(data_layer.layout.transition.duration || 0)\n                        .ease(data_layer.layout.transition.ease || 'cubic-in-out')\n                        .attr('x', x).attr('y', y);\n                } else {\n                    labels\n                        .attr('x', x).attr('y', y);\n                }\n\n                labels.exit().remove();\n\n                // Render exon rects (first transcript only, for now)\n                // Exons: by default color on gene properties for consistency with the gene boundary track- hence color uses d.parent.parent\n                var exon_fill = function(d) { return self.resolveScalableParameter(self.layout.color, d.parent.parent); };\n                var exon_stroke = function(d) { return self.resolveScalableParameter(self.layout.stroke, d.parent.parent); };\n\n                var exons = d3.select(this).selectAll('rect.lz-data_layer-genes.lz-exon')\n                    .data(gene.transcripts[gene.parent.transcript_idx].exons, function(d) { return d.exon_id; });\n\n                exons.enter().append('rect')\n                    .attr('class', 'lz-data_layer-genes lz-exon');\n\n                exons\n                    .style({ fill: exon_fill, stroke: exon_stroke });\n\n                width = function(d) {\n                    return data_layer.parent.x_scale(d.end) - data_layer.parent.x_scale(d.start);\n                };\n                height = function() {\n                    return data_layer.layout.exon_height;\n                };\n                x = function(d) {\n                    return data_layer.parent.x_scale(d.start);\n                };\n                y = function() {\n                    return ((gene.track - 1) * data_layer.getTrackHeight())\n                        + data_layer.layout.bounding_box_padding\n                        + data_layer.layout.label_font_size\n                        + data_layer.layout.label_exon_spacing;\n                };\n                if (data_layer.canTransition()) {\n                    exons\n                        .transition()\n                        .duration(data_layer.layout.transition.duration || 0)\n                        .ease(data_layer.layout.transition.ease || 'cubic-in-out')\n                        .attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                } else {\n                    exons\n                        .attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                }\n\n                exons.exit().remove();\n\n                // Render gene click area\n                var clickareas = d3.select(this).selectAll('rect.lz-data_layer-genes.lz-clickarea')\n                    .data([gene], function(d) { return d.gene_name + '_clickarea'; });\n\n                clickareas.enter().append('rect')\n                    .attr('class', 'lz-data_layer-genes lz-clickarea');\n\n                clickareas\n                    .attr('id', function(d) {\n                        return data_layer.getElementId(d) + '_clickarea';\n                    })\n                    .attr('rx', function() {\n                        return data_layer.layout.bounding_box_padding;\n                    })\n                    .attr('ry', function() {\n                        return data_layer.layout.bounding_box_padding;\n                    });\n\n                width = function(d) {\n                    return d.display_range.width;\n                };\n                height = function() {\n                    return data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing;\n                };\n                x = function(d) {\n                    return d.display_range.start;\n                };\n                y = function(d) {\n                    return ((d.track - 1) * data_layer.getTrackHeight());\n                };\n                if (data_layer.canTransition()) {\n                    clickareas\n                        .transition()\n                        .duration(data_layer.layout.transition.duration || 0)\n                        .ease(data_layer.layout.transition.ease || 'cubic-in-out')\n                        .attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                } else {\n                    clickareas\n                        .attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                }\n\n                // Remove old clickareas as needed\n                clickareas.exit().remove();\n\n                // Apply default event emitters to clickareas\n                clickareas.on('click.event_emitter', function(element) {\n                    element.parent.parent.emit('element_clicked', element, true);\n                });\n\n                // Apply mouse behaviors to clickareas\n                data_layer.applyBehaviors(clickareas);\n\n            });\n\n        // Remove old elements as needed\n        selection.exit().remove();\n\n    };\n\n    /**\n     * Reimplement the positionTooltip() method to be gene-specific\n     * @param {String} id\n     */\n    this.positionTooltip = function(id) {\n        if (typeof id != 'string') {\n            throw new Error('Unable to position tooltip: id is not a string');\n        }\n        if (!this.tooltips[id]) {\n            throw new Error('Unable to position tooltip: id does not point to a valid tooltip');\n        }\n        var tooltip = this.tooltips[id];\n        var arrow_width = 7; // as defined in the default stylesheet\n        var stroke_width = 1; // as defined in the default stylesheet\n        var page_origin = this.getPageOrigin();\n        var tooltip_box = tooltip.selector.node().getBoundingClientRect();\n        var gene_bbox_id = this.getElementStatusNodeId(tooltip.data);\n        var gene_bbox = d3.select('#' + gene_bbox_id).node().getBBox();\n        var data_layer_height = this.parent.layout.height - (this.parent.layout.margin.top + this.parent.layout.margin.bottom);\n        var data_layer_width = this.parent.layout.width - (this.parent.layout.margin.left + this.parent.layout.margin.right);\n        // Position horizontally: attempt to center on the portion of the gene that's visible,\n        // pad to either side if bumping up against the edge of the data layer\n        var gene_center_x = ((tooltip.data.display_range.start + tooltip.data.display_range.end) / 2) - (this.layout.bounding_box_padding / 2);\n        var offset_right = Math.max((tooltip_box.width / 2) - gene_center_x, 0);\n        var offset_left = Math.max((tooltip_box.width / 2) + gene_center_x - data_layer_width, 0);\n        var left = page_origin.x + gene_center_x - (tooltip_box.width / 2) - offset_left + offset_right;\n        var arrow_left = (tooltip_box.width / 2) - (arrow_width / 2) + offset_left - offset_right;\n        // Position vertically below the gene unless there's insufficient space\n        var top, arrow_type, arrow_top;\n        if (tooltip_box.height + stroke_width + arrow_width > data_layer_height - (gene_bbox.y + gene_bbox.height)) {\n            top = page_origin.y + gene_bbox.y - (tooltip_box.height + stroke_width + arrow_width);\n            arrow_type = 'down';\n            arrow_top = tooltip_box.height - stroke_width;\n        } else {\n            top = page_origin.y + gene_bbox.y + gene_bbox.height + stroke_width + arrow_width;\n            arrow_type = 'up';\n            arrow_top = 0 - stroke_width - arrow_width;\n        }\n        // Apply positions to the main div\n        tooltip.selector.style('left', left + 'px').style('top', top + 'px');\n        // Create / update position on arrow connecting tooltip to data\n        if (!tooltip.arrow) {\n            tooltip.arrow = tooltip.selector.append('div').style('position', 'absolute');\n        }\n        tooltip.arrow\n            .attr('class', 'lz-data_layer-tooltip-arrow_' + arrow_type)\n            .style('left', arrow_left + 'px')\n            .style('top', arrow_top + 'px');\n    };\n\n    return this;\n\n});\n","'use strict';\n\n/*********************\n  Genome Legend Data Layer\n  Implements a data layer that will render a genome legend\n*/\n\n// Build a custom data layer for a genome legend\nLocusZoom.DataLayers.add('genome_legend', function(layout) {\n\n    // Define a default layout for this DataLayer type and merge it with the passed argument\n    this.DefaultLayout = {\n        chromosome_fill_colors: {\n            light: 'rgb(155, 155, 188)',\n            dark: 'rgb(95, 95, 128)'\n        },\n        chromosome_label_colors: {\n            light: 'rgb(120, 120, 186)',\n            dark: 'rgb(0, 0, 66)'\n        }\n    };\n    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n\n    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n    LocusZoom.DataLayer.apply(this, arguments);\n\n    // Implement the main render function\n    this.render = function() {\n\n        // Iterate over data to generate genome-wide start/end values for each chromosome\n        var position = 0;\n        this.data.forEach(function(d, i) {\n            this.data[i].genome_start = position;\n            this.data[i].genome_end = position + d['genome:base_pairs'];\n            position += d['genome:base_pairs'];\n        }.bind(this));\n\n        var chromosomes = this.svg.group\n            .selectAll('rect.lz-data_layer-genome_legend')\n            .data(this.data, function(d) { return d['genome:chr']; });\n\n        // Create chromosome elements, apply class\n        chromosomes.enter()\n            .append('rect')\n            .attr('class', 'lz-data_layer-genome_legend');\n\n        // Position and fill chromosome rects\n        var data_layer = this;\n        var panel = this.parent;\n\n        chromosomes\n            .attr('fill', function(d) { return (d['genome:chr'] % 2 ? data_layer.layout.chromosome_fill_colors.light : data_layer.layout.chromosome_fill_colors.dark); })\n            .attr('x', function(d) { return panel.x_scale(d.genome_start); })\n            .attr('y', 0)\n            .attr('width', function(d) { return panel.x_scale(d['genome:base_pairs']); })\n            .attr('height', panel.layout.cliparea.height);\n\n        // Remove old elements as needed\n        chromosomes.exit().remove();\n\n        // Parse current state variant into a position\n        // Assumes that variant string is of the format 10:123352136_C/T or 10:123352136\n        var variant_parts = /([^:]+):(\\d+)(?:_.*)?/.exec(this.state.variant);\n        if (!variant_parts) {\n            throw new Error('Genome legend cannot understand the specified variant position');\n        }\n        var chr = variant_parts[1];\n        var offset = variant_parts[2];\n        // TODO: How does this handle representation of X or Y chromosomes?\n        position = +this.data[chr - 1].genome_start + +offset;\n\n        // Render the position\n        var region = this.svg.group\n            .selectAll('rect.lz-data_layer-genome_legend-marker')\n            .data([{ start: position, end: position + 1 }]);\n\n        region.enter()\n            .append('rect')\n            .attr('class', 'lz-data_layer-genome_legend-marker');\n\n        region\n            .transition()\n            .duration(500)\n            .style({\n                'fill': 'rgba(255, 250, 50, 0.8)',\n                'stroke': 'rgba(255, 250, 50, 0.8)',\n                'stroke-width': '3px'\n            })\n            .attr('x', function(d) { return panel.x_scale(d.start); })\n            .attr('y', 0)\n            .attr('width', function(d) { return panel.x_scale(d.end - d.start); })\n            .attr('height', panel.layout.cliparea.height);\n\n        region.exit().remove();\n\n    };\n\n    return this;\n\n});\n","'use strict';\n\n/**\n * Intervals Data Layer\n * Implements a data layer that will render interval annotation tracks (intervals must provide start and end values)\n * @class LocusZoom.DataLayers.intervals\n * @augments LocusZoom.DataLayer\n */\nLocusZoom.DataLayers.add('intervals', function(layout) {\n\n    // Define a default layout for this DataLayer type and merge it with the passed argument\n    this.DefaultLayout = {\n        start_field: 'start',\n        end_field: 'end',\n        track_split_field: 'state_id',\n        track_split_order: 'DESC',\n        track_split_legend_to_y_axis: 2,\n        split_tracks: true,\n        track_height: 15,\n        track_vertical_spacing: 3,\n        bounding_box_padding: 2,\n        always_hide_legend: false,\n        color: '#B8B8B8',\n        fill_opacity: 1\n    };\n    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n\n    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n    LocusZoom.DataLayer.apply(this, arguments);\n\n    /**\n     * To define shared highlighting on the track split field define the status node id override\n     * to generate an ID common to the track when we're actively splitting data out to separate tracks\n     * @override\n     * @returns {String}\n     */\n    this.getElementStatusNodeId = function(element) {\n        if (this.layout.split_tracks) {\n            return (this.getBaseId() + '-statusnode-' + element[this.layout.track_split_field]).replace(/[:.[\\],]/g, '_');\n        }\n        return this.getElementId(element) + '-statusnode';\n    }.bind(this);\n\n    // Helper function to sum layout values to derive total height for a single interval track\n    this.getTrackHeight = function() {\n        return this.layout.track_height\n            + this.layout.track_vertical_spacing\n            + (2 * this.layout.bounding_box_padding);\n    };\n\n    this.tracks = 1;\n    this.previous_tracks = 1;\n\n    // track-number-indexed object with arrays of interval indexes in the dataset\n    this.interval_track_index = { 1: [] };\n\n    // After we've loaded interval data interpret it to assign\n    // each to a track so that they do not overlap in the view\n    this.assignTracks = function() {\n\n        // Reinitialize some metadata\n        this.previous_tracks = this.tracks;\n        this.tracks = 0;\n        this.interval_track_index = { 1: [] };\n        this.track_split_field_index = {};\n\n        // If splitting tracks by a field's value then do a first pass determine\n        // a value/track mapping that preserves the order of possible values\n        if (this.layout.track_split_field && this.layout.split_tracks) {\n            this.data.map(function(d) {\n                this.track_split_field_index[d[this.layout.track_split_field]] = null;\n            }.bind(this));\n            var index = Object.keys(this.track_split_field_index);\n            if (this.layout.track_split_order === 'DESC') { index.reverse(); }\n            index.forEach(function(val) {\n                this.track_split_field_index[val] = this.tracks + 1;\n                this.interval_track_index[this.tracks + 1] = [];\n                this.tracks++;\n            }.bind(this));\n        }\n\n        this.data.map(function(d, i) {\n\n            // Stash a parent reference on the interval\n            this.data[i].parent = this;\n\n            // Determine display range start and end, based on minimum allowable interval display width,\n            // bounded by what we can see (range: values in terms of pixels on the screen)\n            this.data[i].display_range = {\n                start: this.parent.x_scale(Math.max(d[this.layout.start_field], this.state.start)),\n                end:   this.parent.x_scale(Math.min(d[this.layout.end_field], this.state.end))\n            };\n            this.data[i].display_range.width = this.data[i].display_range.end - this.data[i].display_range.start;\n\n            // Convert and stash display range values into domain values\n            // (domain: values in terms of the data set, e.g. megabases)\n            this.data[i].display_domain = {\n                start: this.parent.x_scale.invert(this.data[i].display_range.start),\n                end:   this.parent.x_scale.invert(this.data[i].display_range.end)\n            };\n            this.data[i].display_domain.width = this.data[i].display_domain.end - this.data[i].display_domain.start;\n\n            // If splitting to tracks based on the value of the designated track split field\n            // then don't bother with collision detection (intervals will be grouped on tracks\n            // solely by the value of track_split_field)\n            if (this.layout.track_split_field && this.layout.split_tracks) {\n                var val = this.data[i][this.layout.track_split_field];\n                this.data[i].track = this.track_split_field_index[val];\n                this.interval_track_index[this.data[i].track].push(i);\n            } else {\n                // If not splitting to tracks based on a field value then do so based on collision\n                // detection (as how it's done for genes). Use display range/domain data generated\n                // above and cast each interval to tracks such that none overlap\n                this.tracks = 1;\n                this.data[i].track = null;\n                var potential_track = 1;\n                while (this.data[i].track === null) {\n                    var collision_on_potential_track = false;\n                    this.interval_track_index[potential_track].map(function(placed_interval) {\n                        if (!collision_on_potential_track) {\n                            var min_start = Math.min(placed_interval.display_range.start, this.display_range.start);\n                            var max_end = Math.max(placed_interval.display_range.end, this.display_range.end);\n                            if ((max_end - min_start) < (placed_interval.display_range.width + this.display_range.width)) {\n                                collision_on_potential_track = true;\n                            }\n                        }\n                    }.bind(this.data[i]));\n                    if (!collision_on_potential_track) {\n                        this.data[i].track = potential_track;\n                        this.interval_track_index[potential_track].push(this.data[i]);\n                    } else {\n                        potential_track++;\n                        if (potential_track > this.tracks) {\n                            this.tracks = potential_track;\n                            this.interval_track_index[potential_track] = [];\n                        }\n                    }\n                }\n\n            }\n\n        }.bind(this));\n\n        return this;\n    };\n\n    // Implement the main render function\n    this.render = function() {\n\n        this.assignTracks();\n\n        // Remove any shared highlight nodes and re-render them if we're splitting on tracks\n        // At most there will only be dozen or so nodes here (one per track) and each time\n        // we render data we may have new tracks, so wiping/redrawing all is reasonable.\n        this.svg.group.selectAll('.lz-data_layer-intervals-statusnode.lz-data_layer-intervals-shared').remove();\n        Object.keys(this.track_split_field_index).forEach(function(key) {\n            // Make a psuedo-element so that we can generate an id for the shared node\n            var psuedoElement = {};\n            psuedoElement[this.layout.track_split_field] = key;\n            // Insert the shared node\n            var sharedstatusnode_style = {display: (this.layout.split_tracks ? null : 'none')};\n            this.svg.group.insert('rect', ':first-child')\n                .attr('id', this.getElementStatusNodeId(psuedoElement))\n                .attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-shared')\n                .attr('rx', this.layout.bounding_box_padding).attr('ry', this.layout.bounding_box_padding)\n                .attr('width', this.parent.layout.cliparea.width)\n                .attr('height', this.getTrackHeight() - this.layout.track_vertical_spacing)\n                .attr('x', 0)\n                .attr('y', (this.track_split_field_index[key] - 1) * this.getTrackHeight())\n                .style(sharedstatusnode_style);\n        }.bind(this));\n\n        var width, height, x, y, fill, fill_opacity;\n\n        // Render interval groups\n        var selection = this.svg.group.selectAll('g.lz-data_layer-intervals')\n            .data(this.data, function(d) { return d[this.layout.id_field]; }.bind(this));\n\n        selection.enter().append('g')\n            .attr('class', 'lz-data_layer-intervals');\n\n        selection.attr('id', function(d) { return this.getElementId(d); }.bind(this))\n            .each(function(interval) {\n\n                var data_layer = interval.parent;\n\n                // Render interval status nodes (displayed behind intervals to show highlight\n                // without needing to modify interval display element(s))\n                var statusnode_style = {display: (data_layer.layout.split_tracks ? 'none' : null)};\n                var statusnodes = d3.select(this).selectAll('rect.lz-data_layer-intervals.lz-data_layer-intervals-statusnode.lz-data_layer-intervals-statusnode-discrete')\n                    .data([interval], function(d) { return data_layer.getElementId(d) + '-statusnode'; });\n                statusnodes.enter().insert('rect', ':first-child')\n                    .attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-statusnode-discrete');\n                statusnodes\n                    .attr('id', function(d) {\n                        return data_layer.getElementId(d) + '-statusnode';\n                    })\n                    .attr('rx', function() {\n                        return data_layer.layout.bounding_box_padding;\n                    })\n                    .attr('ry', function() {\n                        return data_layer.layout.bounding_box_padding;\n                    })\n                    .style(statusnode_style);\n                width = function(d) {\n                    return d.display_range.width + (2 * data_layer.layout.bounding_box_padding);\n                };\n                height = function() {\n                    return data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing;\n                };\n                x = function(d) {\n                    return d.display_range.start - data_layer.layout.bounding_box_padding;\n                };\n                y = function(d) {\n                    return ((d.track - 1) * data_layer.getTrackHeight());\n                };\n                if (data_layer.canTransition()) {\n                    statusnodes\n                        .transition()\n                        .duration(data_layer.layout.transition.duration || 0)\n                        .ease(data_layer.layout.transition.ease || 'cubic-in-out')\n                        .attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                } else {\n                    statusnodes\n                        .attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                }\n                statusnodes.exit().remove();\n\n                // Render primary interval rects\n                var rects = d3.select(this).selectAll('rect.lz-data_layer-intervals.lz-interval_rect')\n                    .data([interval], function(d) { return d[data_layer.layout.id_field] + '_interval_rect'; });\n\n                rects.enter().append('rect')\n                    .attr('class', 'lz-data_layer-intervals lz-interval_rect');\n\n                height = data_layer.layout.track_height;\n                width = function(d) {\n                    return d.display_range.width;\n                };\n                x = function(d) {\n                    return d.display_range.start;\n                };\n                y = function(d) {\n                    return ((d.track - 1) * data_layer.getTrackHeight())\n                        + data_layer.layout.bounding_box_padding;\n                };\n                fill = function(d) {\n                    return data_layer.resolveScalableParameter(data_layer.layout.color, d);\n                };\n                fill_opacity = function(d) {\n                    return data_layer.resolveScalableParameter(data_layer.layout.fill_opacity, d);\n                };\n\n\n                if (data_layer.canTransition()) {\n                    rects\n                        .transition()\n                        .duration(data_layer.layout.transition.duration || 0)\n                        .ease(data_layer.layout.transition.ease || 'cubic-in-out')\n                        .attr('width', width).attr('height', height)\n                        .attr('x', x).attr('y', y)\n                        .attr('fill', fill)\n                        .attr('fill-opacity', fill_opacity);\n                } else {\n                    rects\n                        .attr('width', width).attr('height', height)\n                        .attr('x', x).attr('y', y)\n                        .attr('fill', fill)\n                        .attr('fill-opacity', fill_opacity);\n                }\n\n                rects.exit().remove();\n\n                // Render interval click areas\n                var clickareas = d3.select(this).selectAll('rect.lz-data_layer-intervals.lz-clickarea')\n                    .data([interval], function(d) { return d.interval_name + '_clickarea'; });\n\n                clickareas.enter().append('rect')\n                    .attr('class', 'lz-data_layer-intervals lz-clickarea');\n\n                clickareas\n                    .attr('id', function(d) {\n                        return data_layer.getElementId(d) + '_clickarea';\n                    })\n                    .attr('rx', function() {\n                        return data_layer.layout.bounding_box_padding;\n                    })\n                    .attr('ry', function() {\n                        return data_layer.layout.bounding_box_padding;\n                    });\n\n                width = function(d) {\n                    return d.display_range.width;\n                };\n                height = function() {\n                    return data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing;\n                };\n                x = function(d) {\n                    return d.display_range.start;\n                };\n                y = function(d) {\n                    return ((d.track - 1) * data_layer.getTrackHeight());\n                };\n                if (data_layer.canTransition()) {\n                    clickareas\n                        .transition()\n                        .duration(data_layer.layout.transition.duration || 0)\n                        .ease(data_layer.layout.transition.ease || 'cubic-in-out')\n                        .attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                } else {\n                    clickareas\n                        .attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n                }\n\n                // Remove old clickareas as needed\n                clickareas.exit().remove();\n\n                // Apply default event emitters to clickareas\n                clickareas.on('click', function(element_data) {\n                    element_data.parent.parent.emit('element_clicked', element_data, true);\n                }.bind(this));\n\n                // Apply mouse behaviors to clickareas\n                data_layer.applyBehaviors(clickareas);\n\n            });\n\n        // Remove old elements as needed\n        selection.exit().remove();\n\n        // Update the legend axis if the number of ticks changed\n        if (this.previous_tracks !== this.tracks) {\n            this.updateSplitTrackAxis();\n        }\n\n        return this;\n\n    };\n\n    // Reimplement the positionTooltip() method to be interval-specific\n    this.positionTooltip = function(id) {\n        if (typeof id != 'string') {\n            throw new Error('Unable to position tooltip: id is not a string');\n        }\n        if (!this.tooltips[id]) {\n            throw new Error('Unable to position tooltip: id does not point to a valid tooltip');\n        }\n        var tooltip = this.tooltips[id];\n        var arrow_width = 7; // as defined in the default stylesheet\n        var stroke_width = 1; // as defined in the default stylesheet\n        var page_origin = this.getPageOrigin();\n        var tooltip_box = tooltip.selector.node().getBoundingClientRect();\n        var interval_bbox = d3.select('#' + this.getElementStatusNodeId(tooltip.data)).node().getBBox();\n        var data_layer_height = this.parent.layout.height - (this.parent.layout.margin.top + this.parent.layout.margin.bottom);\n        var data_layer_width = this.parent.layout.width - (this.parent.layout.margin.left + this.parent.layout.margin.right);\n        // Position horizontally: attempt to center on the portion of the interval that's visible,\n        // pad to either side if bumping up against the edge of the data layer\n        var interval_center_x = ((tooltip.data.display_range.start + tooltip.data.display_range.end) / 2) - (this.layout.bounding_box_padding / 2);\n        var offset_right = Math.max((tooltip_box.width / 2) - interval_center_x, 0);\n        var offset_left = Math.max((tooltip_box.width / 2) + interval_center_x - data_layer_width, 0);\n        var left = page_origin.x + interval_center_x - (tooltip_box.width / 2) - offset_left + offset_right;\n        var arrow_left = (tooltip_box.width / 2) - (arrow_width / 2) + offset_left - offset_right;\n        // Position vertically below the interval unless there's insufficient space\n        var top, arrow_type, arrow_top;\n        if (tooltip_box.height + stroke_width + arrow_width > data_layer_height - (interval_bbox.y + interval_bbox.height)) {\n            top = page_origin.y + interval_bbox.y - (tooltip_box.height + stroke_width + arrow_width);\n            arrow_type = 'down';\n            arrow_top = tooltip_box.height - stroke_width;\n        } else {\n            top = page_origin.y + interval_bbox.y + interval_bbox.height + stroke_width + arrow_width;\n            arrow_type = 'up';\n            arrow_top = 0 - stroke_width - arrow_width;\n        }\n        // Apply positions to the main div\n        tooltip.selector.style('left', left + 'px').style('top', top + 'px');\n        // Create / update position on arrow connecting tooltip to data\n        if (!tooltip.arrow) {\n            tooltip.arrow = tooltip.selector.append('div').style('position', 'absolute');\n        }\n        tooltip.arrow\n            .attr('class', 'lz-data_layer-tooltip-arrow_' + arrow_type)\n            .style('left', arrow_left + 'px')\n            .style('top', arrow_top + 'px');\n    };\n\n    // Redraw split track axis or hide it, and show/hide the legend, as determined\n    // by current layout parameters and data\n    this.updateSplitTrackAxis = function() {\n        var legend_axis = this.layout.track_split_legend_to_y_axis ? 'y' + this.layout.track_split_legend_to_y_axis : false;\n        if (this.layout.split_tracks) {\n            var tracks = +this.tracks || 0;\n            var track_height = +this.layout.track_height || 0;\n            var track_spacing =  2 * (+this.layout.bounding_box_padding || 0) + (+this.layout.track_vertical_spacing || 0);\n            var target_height = (tracks * track_height) + ((tracks - 1) * track_spacing);\n            this.parent.scaleHeightToData(target_height);\n            if (legend_axis && this.parent.legend) {\n                this.parent.legend.hide();\n                this.parent.layout.axes[legend_axis] = {\n                    render: true,\n                    ticks: [],\n                    range: {\n                        start: (target_height - (this.layout.track_height / 2)),\n                        end: (this.layout.track_height / 2)\n                    }\n                };\n                this.layout.legend.forEach(function(element) {\n                    var key = element[this.layout.track_split_field];\n                    var track = this.track_split_field_index[key];\n                    if (track) {\n                        if (this.layout.track_split_order === 'DESC') {\n                            track = Math.abs(track - tracks - 1);\n                        }\n                        this.parent.layout.axes[legend_axis].ticks.push({\n                            y: track,\n                            text: element.label\n                        });\n                    }\n                }.bind(this));\n                this.layout.y_axis = {\n                    axis: this.layout.track_split_legend_to_y_axis,\n                    floor: 1,\n                    ceiling: tracks\n                };\n                this.parent.render();\n            }\n            this.parent_plot.positionPanels();\n        } else {\n            if (legend_axis && this.parent.legend) {\n                if (!this.layout.always_hide_legend) { this.parent.legend.show(); }\n                this.parent.layout.axes[legend_axis] = { render: false };\n                this.parent.render();\n            }\n        }\n        return this;\n    };\n\n    // Method to not only toggle the split tracks boolean but also update\n    // necessary display values to animate a complete merge/split\n    this.toggleSplitTracks = function() {\n        this.layout.split_tracks = !this.layout.split_tracks;\n        if (this.parent.legend && !this.layout.always_hide_legend) {\n            this.parent.layout.margin.bottom = 5 + (this.layout.split_tracks ? 0 : this.parent.legend.layout.height + 5);\n        }\n        this.render();\n        this.updateSplitTrackAxis();\n        return this;\n    };\n\n    return this;\n\n});\n","'use strict';\n\n/*********************\n * Line Data Layer\n * Implements a standard line plot, representing either a trace or a filled curve.\n * @class\n * @augments LocusZoom.DataLayer\n*/\nLocusZoom.DataLayers.add('line', function(layout) {\n\n    // Define a default layout for this DataLayer type and merge it with the passed argument\n    /** @member {Object} */\n    this.DefaultLayout = {\n        style: {\n            fill: 'none',\n            'stroke-width': '2px'\n        },\n        interpolate: 'linear',\n        x_axis: { field: 'x' },\n        y_axis: { field: 'y', axis: 1 },\n        hitarea_width: 5\n    };\n    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n\n    // Var for storing mouse events for use in tool tip positioning\n    /** @member {String} */\n    this.mouse_event = null;\n\n    /**\n     * Var for storing the generated line function itself\n     * @member {d3.svg.line}\n     * */\n    this.line = null;\n\n    /**\n     * The timeout identifier returned by setTimeout\n     * @member {Number}\n     */\n    this.tooltip_timeout = null;\n\n    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n    LocusZoom.DataLayer.apply(this, arguments);\n\n\n    /**\n     * Helper function to get display and data objects representing\n     *   the x/y coordinates of the current mouse event with respect to the line in terms of the display\n     *   and the interpolated values of the x/y fields with respect to the line\n     * @returns {{display: {x: *, y: null}, data: {}, slope: null}}\n     */\n    this.getMouseDisplayAndData = function() {\n        var ret = {\n            display: {\n                x: d3.mouse(this.mouse_event)[0],\n                y: null\n            },\n            data: {},\n            slope: null\n        };\n        var x_field = this.layout.x_axis.field;\n        var y_field = this.layout.y_axis.field;\n        var x_scale = 'x_scale';\n        var y_scale = 'y' + this.layout.y_axis.axis + '_scale';\n        ret.data[x_field] = this.parent[x_scale].invert(ret.display.x);\n        var bisect = d3.bisector(function(datum) { return +datum[x_field]; }).left;\n        var index = bisect(this.data, ret.data[x_field]) - 1;\n        var startDatum = this.data[index];\n        var endDatum = this.data[index + 1];\n        var interpolate = d3.interpolateNumber(+startDatum[y_field], +endDatum[y_field]);\n        var range = +endDatum[x_field] - +startDatum[x_field];\n        ret.data[y_field] = interpolate((ret.data[x_field] % range) / range);\n        ret.display.y = this.parent[y_scale](ret.data[y_field]);\n        if (this.layout.tooltip.x_precision) {\n            ret.data[x_field] = ret.data[x_field].toPrecision(this.layout.tooltip.x_precision);\n        }\n        if (this.layout.tooltip.y_precision) {\n            ret.data[y_field] = ret.data[y_field].toPrecision(this.layout.tooltip.y_precision);\n        }\n        ret.slope = (this.parent[y_scale](endDatum[y_field]) - this.parent[y_scale](startDatum[y_field]))\n                  / (this.parent[x_scale](endDatum[x_field]) - this.parent[x_scale](startDatum[x_field]));\n        return ret;\n    };\n\n    /**\n     * Reimplement the positionTooltip() method to be line-specific\n     * @param {String} id Identify the tooltip to be positioned\n     */\n    this.positionTooltip = function(id) {\n        if (typeof id != 'string') {\n            throw new Error('Unable to position tooltip: id is not a string');\n        }\n        if (!this.tooltips[id]) {\n            throw new Error('Unable to position tooltip: id does not point to a valid tooltip');\n        }\n        var tooltip = this.tooltips[id];\n        var tooltip_box = tooltip.selector.node().getBoundingClientRect();\n        var arrow_width = 7; // as defined in the default stylesheet\n        var border_radius = 6; // as defined in the default stylesheet\n        var stroke_width = parseFloat(this.layout.style['stroke-width']) || 1;\n        var page_origin = this.getPageOrigin();\n        var data_layer_height = this.parent.layout.height - (this.parent.layout.margin.top + this.parent.layout.margin.bottom);\n        var data_layer_width = this.parent.layout.width - (this.parent.layout.margin.left + this.parent.layout.margin.right);\n        var top, left, arrow_top, arrow_left, arrow_type;\n\n        // Determine x/y coordinates for display and data\n        var dd = this.getMouseDisplayAndData();\n\n        // If the absolute value of the slope of the line at this point is above 1 (including Infinity)\n        // then position the tool tip left/right. Otherwise position top/bottom.\n        if (Math.abs(dd.slope) > 1) {\n\n            // Position horizontally on the left or the right depending on which side of the plot the point is on\n            if (dd.display.x <= this.parent.layout.width / 2) {\n                left = page_origin.x + dd.display.x + stroke_width + arrow_width + stroke_width;\n                arrow_type = 'left';\n                arrow_left = -1 * (arrow_width + stroke_width);\n            } else {\n                left = page_origin.x + dd.display.x - tooltip_box.width - stroke_width - arrow_width - stroke_width;\n                arrow_type = 'right';\n                arrow_left = tooltip_box.width - stroke_width;\n            }\n            // Position vertically centered unless we're at the top or bottom of the plot\n            if (dd.display.y - (tooltip_box.height / 2) <= 0) { // Too close to the top, push it down\n                top = page_origin.y + dd.display.y - (1.5 * arrow_width) - border_radius;\n                arrow_top = border_radius;\n            } else if (dd.display.y + (tooltip_box.height / 2) >= data_layer_height) { // Too close to the bottom, pull it up\n                top = page_origin.y + dd.display.y + arrow_width + border_radius - tooltip_box.height;\n                arrow_top = tooltip_box.height - (2 * arrow_width) - border_radius;\n            } else { // vertically centered\n                top = page_origin.y + dd.display.y - (tooltip_box.height / 2);\n                arrow_top = (tooltip_box.height / 2) - arrow_width;\n            }\n\n        } else {\n\n            // Position horizontally: attempt to center on the mouse's x coordinate\n            // pad to either side if bumping up against the edge of the data layer\n            var offset_right = Math.max((tooltip_box.width / 2) - dd.display.x, 0);\n            var offset_left = Math.max((tooltip_box.width / 2) + dd.display.x - data_layer_width, 0);\n            left = page_origin.x + dd.display.x - (tooltip_box.width / 2) - offset_left + offset_right;\n            var min_arrow_left = arrow_width / 2;\n            var max_arrow_left = tooltip_box.width - (2.5 * arrow_width);\n            arrow_left = (tooltip_box.width / 2) - arrow_width + offset_left - offset_right;\n            arrow_left = Math.min(Math.max(arrow_left, min_arrow_left), max_arrow_left);\n\n            // Position vertically above the line unless there's insufficient space\n            if (tooltip_box.height + stroke_width + arrow_width > dd.display.y) {\n                top = page_origin.y + dd.display.y + stroke_width + arrow_width;\n                arrow_type = 'up';\n                arrow_top = 0 - stroke_width - arrow_width;\n            } else {\n                top = page_origin.y + dd.display.y - (tooltip_box.height + stroke_width + arrow_width);\n                arrow_type = 'down';\n                arrow_top = tooltip_box.height - stroke_width;\n            }\n        }\n\n        // Apply positions to the main div\n        tooltip.selector.style({ left: left + 'px', top: top + 'px' });\n        // Create / update position on arrow connecting tooltip to data\n        if (!tooltip.arrow) {\n            tooltip.arrow = tooltip.selector.append('div').style('position', 'absolute');\n        }\n        tooltip.arrow\n            .attr('class', 'lz-data_layer-tooltip-arrow_' + arrow_type)\n            .style({ 'left': arrow_left + 'px', top: arrow_top + 'px' });\n\n    };\n\n    /**\n     * Implement the main render function\n     */\n    this.render = function() {\n\n        // Several vars needed to be in scope\n        var data_layer = this;\n        var panel = this.parent;\n        var x_field = this.layout.x_axis.field;\n        var y_field = this.layout.y_axis.field;\n        var x_scale = 'x_scale';\n        var y_scale = 'y' + this.layout.y_axis.axis + '_scale';\n\n        // Join data to the line selection\n        var selection = this.svg.group\n            .selectAll('path.lz-data_layer-line')\n            .data([this.data]);\n\n        // Create path element, apply class\n        this.path = selection.enter()\n            .append('path')\n            .attr('class', 'lz-data_layer-line');\n\n        // Generate the line\n        if (this.layout.style.fill && this.layout.style.fill !== 'none') {\n            // Filled curve: define the line as a filled boundary\n            this.line = d3.svg.area()\n                .x(function(d) { return parseFloat(panel[x_scale](d[x_field])); })\n                .y0(function(d) {return parseFloat(panel[y_scale](0));})\n                .y1(function(d) { return parseFloat(panel[y_scale](d[y_field])); });\n        } else {\n            // Basic line\n            this.line = d3.svg.line()\n                .x(function(d) { return parseFloat(panel[x_scale](d[x_field])); })\n                .y(function(d) { return parseFloat(panel[y_scale](d[y_field])); })\n                .interpolate(this.layout.interpolate);\n        }\n\n        // Apply line and style\n        if (this.canTransition()) {\n            selection\n                .transition()\n                .duration(this.layout.transition.duration || 0)\n                .ease(this.layout.transition.ease || 'cubic-in-out')\n                .attr('d', this.line)\n                .style(this.layout.style);\n        } else {\n            selection\n                .attr('d', this.line)\n                .style(this.layout.style);\n        }\n\n        // Apply tooltip, etc\n        if (this.layout.tooltip) {\n            // Generate an overlaying transparent \"hit area\" line for more intuitive mouse events\n            var hitarea_width = parseFloat(this.layout.hitarea_width).toString() + 'px';\n            var hitarea = this.svg.group\n                .selectAll('path.lz-data_layer-line-hitarea')\n                .data([this.data]);\n            hitarea.enter()\n                .append('path')\n                .attr('class', 'lz-data_layer-line-hitarea')\n                .style('stroke-width', hitarea_width);\n            var hitarea_line = d3.svg.line()\n                .x(function(d) { return parseFloat(panel[x_scale](d[x_field])); })\n                .y(function(d) { return parseFloat(panel[y_scale](d[y_field])); })\n                .interpolate(this.layout.interpolate);\n            hitarea\n                .attr('d', hitarea_line)\n                .on('mouseover', function() {\n                    clearTimeout(data_layer.tooltip_timeout);\n                    data_layer.mouse_event = this;\n                    var dd = data_layer.getMouseDisplayAndData();\n                    data_layer.createTooltip(dd.data);\n                })\n                .on('mousemove', function() {\n                    clearTimeout(data_layer.tooltip_timeout);\n                    data_layer.mouse_event = this;\n                    var dd = data_layer.getMouseDisplayAndData();\n                    data_layer.updateTooltip(dd.data);\n                    data_layer.positionTooltip(data_layer.getElementId());\n                })\n                .on('mouseout', function() {\n                    data_layer.tooltip_timeout = setTimeout(function() {\n                        data_layer.mouse_event = null;\n                        data_layer.destroyTooltip(data_layer.getElementId());\n                    }, 300);\n                });\n            hitarea.exit().remove();\n        }\n\n        // Remove old elements as needed\n        selection.exit().remove();\n\n    };\n\n    /**\n     * Redefine setElementStatus family of methods as line data layers will only ever have a single path element\n     * @param {String} status A member of `LocusZoom.DataLayer.Statuses.adjectives`\n     * @param {String|Object} element\n     * @param {Boolean} toggle\n     * @returns {LocusZoom.DataLayer}\n     */\n    this.setElementStatus = function(status, element, toggle) {\n        return this.setAllElementStatus(status, toggle);\n    };\n    this.setElementStatusByFilters = function(status, toggle) {\n        return this.setAllElementStatus(status, toggle);\n    };\n    this.setAllElementStatus = function(status, toggle) {\n        // Sanity check\n        if (typeof status == 'undefined' || LocusZoom.DataLayer.Statuses.adjectives.indexOf(status) === -1) {\n            throw new Error('Invalid status passed to DataLayer.setAllElementStatus()');\n        }\n        if (typeof this.state[this.state_id][status] == 'undefined') { return this; }\n        if (typeof toggle == 'undefined') { toggle = true; }\n\n        // Update global status flag\n        this.global_statuses[status] = toggle;\n\n        // Apply class to path based on global status flags\n        var path_class = 'lz-data_layer-line';\n        Object.keys(this.global_statuses).forEach(function(global_status) {\n            if (this.global_statuses[global_status]) { path_class += ' lz-data_layer-line-' + global_status; }\n        }.bind(this));\n        this.path.attr('class', path_class);\n\n        // Trigger layout changed event hook\n        this.parent.emit('layout_changed', true);\n        return this;\n    };\n\n    return this;\n\n});\n\n\n/***************************\n *  Orthogonal Line Data Layer\n *  Implements a horizontal or vertical line given an orientation and an offset in the layout\n *  Does not require a data source\n * @class\n * @augments LocusZoom.DataLayer\n*/\nLocusZoom.DataLayers.add('orthogonal_line', function(layout) {\n\n    // Define a default layout for this DataLayer type and merge it with the passed argument\n    this.DefaultLayout = {\n        style: {\n            'stroke': '#D3D3D3',\n            'stroke-width': '3px',\n            'stroke-dasharray': '10px 10px'\n        },\n        orientation: 'horizontal',\n        x_axis: {\n            axis: 1,\n            decoupled: true\n        },\n        y_axis: {\n            axis: 1,\n            decoupled: true\n        },\n        offset: 0\n    };\n    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n\n    // Require that orientation be \"horizontal\" or \"vertical\" only\n    if (['horizontal','vertical'].indexOf(layout.orientation) === -1) {\n        layout.orientation = 'horizontal';\n    }\n\n    // Vars for storing the data generated line\n    /** @member {Array} */\n    this.data = [];\n    /** @member {d3.svg.line} */\n    this.line = null;\n\n    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n    LocusZoom.DataLayer.apply(this, arguments);\n\n    /**\n     * Implement the main render function\n     */\n    this.render = function() {\n\n        // Several vars needed to be in scope\n        var panel = this.parent;\n        var x_scale = 'x_scale';\n        var y_scale = 'y' + this.layout.y_axis.axis + '_scale';\n        var x_extent = 'x_extent';\n        var y_extent = 'y' + this.layout.y_axis.axis + '_extent';\n        var x_range = 'x_range';\n        var y_range = 'y' + this.layout.y_axis.axis + '_range';\n\n        // Generate data using extents depending on orientation\n        if (this.layout.orientation === 'horizontal') {\n            this.data = [\n                { x: panel[x_extent][0], y: this.layout.offset },\n                { x: panel[x_extent][1], y: this.layout.offset }\n            ];\n        } else {\n            this.data = [\n                { x: this.layout.offset, y: panel[y_extent][0] },\n                { x: this.layout.offset, y: panel[y_extent][1] }\n            ];\n        }\n\n        // Join data to the line selection\n        var selection = this.svg.group\n            .selectAll('path.lz-data_layer-line')\n            .data([this.data]);\n\n        // Create path element, apply class\n        this.path = selection.enter()\n            .append('path')\n            .attr('class', 'lz-data_layer-line');\n\n        // Generate the line\n        this.line = d3.svg.line()\n            .x(function(d, i) {\n                var x = parseFloat(panel[x_scale](d['x']));\n                return isNaN(x) ? panel[x_range][i] : x;\n            })\n            .y(function(d, i) {\n                var y = parseFloat(panel[y_scale](d['y']));\n                return isNaN(y) ? panel[y_range][i] : y;\n            })\n            .interpolate('linear');\n\n        // Apply line and style\n        if (this.canTransition()) {\n            selection\n                .transition()\n                .duration(this.layout.transition.duration || 0)\n                .ease(this.layout.transition.ease || 'cubic-in-out')\n                .attr('d', this.line)\n                .style(this.layout.style);\n        } else {\n            selection\n                .attr('d', this.line)\n                .style(this.layout.style);\n        }\n\n        // Remove old elements as needed\n        selection.exit().remove();\n\n    };\n\n    return this;\n\n});\n","'use strict';\n\n/**\n * Scatter Data Layer\n * Implements a standard scatter plot\n * @class LocusZoom.DataLayers.scatter\n */\nLocusZoom.DataLayers.add('scatter', function(layout) {\n    // Define a default layout for this DataLayer type and merge it with the passed argument\n    this.DefaultLayout = {\n        point_size: 40,\n        point_shape: 'circle',\n        tooltip_positioning: 'horizontal',\n        color: '#888888',\n        fill_opacity: 1,\n        y_axis: {\n            axis: 1\n        },\n        id_field: 'id'\n    };\n    layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n\n    // Extra default for layout spacing\n    // Not in default layout since that would make the label attribute always present\n    if (layout.label && isNaN(layout.label.spacing)) {\n        layout.label.spacing = 4;\n    }\n\n    // Apply the arguments to set LocusZoom.DataLayer as the prototype\n    LocusZoom.DataLayer.apply(this, arguments);\n\n    // Reimplement the positionTooltip() method to be scatter-specific\n    this.positionTooltip = function(id) {\n        if (typeof id != 'string') {\n            throw new Error('Unable to position tooltip: id is not a string');\n        }\n        if (!this.tooltips[id]) {\n            throw new Error('Unable to position tooltip: id does not point to a valid tooltip');\n        }\n        var top, left, arrow_type, arrow_top, arrow_left;\n        var tooltip = this.tooltips[id];\n        var point_size = this.resolveScalableParameter(this.layout.point_size, tooltip.data);\n        var offset = Math.sqrt(point_size / Math.PI);\n        var arrow_width = 7; // as defined in the default stylesheet\n        var stroke_width = 1; // as defined in the default stylesheet\n        var border_radius = 6; // as defined in the default stylesheet\n        var page_origin = this.getPageOrigin();\n        var x_center = this.parent.x_scale(tooltip.data[this.layout.x_axis.field]);\n        var y_scale  = 'y' + this.layout.y_axis.axis + '_scale';\n        var y_center = this.parent[y_scale](tooltip.data[this.layout.y_axis.field]);\n        var tooltip_box = tooltip.selector.node().getBoundingClientRect();\n        var data_layer_height = this.parent.layout.height - (this.parent.layout.margin.top + this.parent.layout.margin.bottom);\n        var data_layer_width = this.parent.layout.width - (this.parent.layout.margin.left + this.parent.layout.margin.right);\n        if (this.layout.tooltip_positioning === 'vertical') {\n            // Position horizontally centered above the point\n            var offset_right = Math.max((tooltip_box.width / 2) - x_center, 0);\n            var offset_left = Math.max((tooltip_box.width / 2) + x_center - data_layer_width, 0);\n            left = page_origin.x + x_center - (tooltip_box.width / 2) - offset_left + offset_right;\n            arrow_left = (tooltip_box.width / 2) - (arrow_width / 2) + offset_left - offset_right - offset;\n            // Position vertically above the point unless there's insufficient space, then go below\n            if (tooltip_box.height + stroke_width + arrow_width > data_layer_height - (y_center + offset)) {\n                top = page_origin.y + y_center - (offset + tooltip_box.height + stroke_width + arrow_width);\n                arrow_type = 'down';\n                arrow_top = tooltip_box.height - stroke_width;\n            } else {\n                top = page_origin.y + y_center + offset + stroke_width + arrow_width;\n                arrow_type = 'up';\n                arrow_top = 0 - stroke_width - arrow_width;\n            }\n        } else {\n            // Position horizontally on the left or the right depending on which side of the plot the point is on\n            if (x_center <= this.parent.layout.width / 2) {\n                left = page_origin.x + x_center + offset + arrow_width + stroke_width;\n                arrow_type = 'left';\n                arrow_left = -1 * (arrow_width + stroke_width);\n            } else {\n                left = page_origin.x + x_center - tooltip_box.width - offset - arrow_width - stroke_width;\n                arrow_type = 'right';\n                arrow_left = tooltip_box.width - stroke_width;\n            }\n            // Position vertically centered unless we're at the top or bottom of the plot\n            data_layer_height = this.parent.layout.height - (this.parent.layout.margin.top + this.parent.layout.margin.bottom);\n            if (y_center - (tooltip_box.height / 2) <= 0) { // Too close to the top, push it down\n                top = page_origin.y + y_center - (1.5 * arrow_width) - border_radius;\n                arrow_top = border_radius;\n            } else if (y_center + (tooltip_box.height / 2) >= data_layer_height) { // Too close to the bottom, pull it up\n                top = page_origin.y + y_center + arrow_width + border_radius - tooltip_box.height;\n                arrow_top = tooltip_box.height - (2 * arrow_width) - border_radius;\n            } else { // vertically centered\n                top = page_origin.y + y_center - (tooltip_box.height / 2);\n                arrow_top = (tooltip_box.height / 2) - arrow_width;\n            }\n        }\n        // Apply positions to the main div\n        tooltip.selector.style('left', left + 'px').style('top', top + 'px');\n        // Create / update position on arrow connecting tooltip to data\n        if (!tooltip.arrow) {\n            tooltip.arrow = tooltip.selector.append('div').style('position', 'absolute');\n        }\n        tooltip.arrow\n            .attr('class', 'lz-data_layer-tooltip-arrow_' + arrow_type)\n            .style('left', arrow_left + 'px')\n            .style('top', arrow_top + 'px');\n    };\n\n    // Function to flip labels from being anchored at the start of the text to the end\n    // Both to keep labels from running outside the data layer and  also as a first\n    // pass on recursive separation\n    this.flip_labels = function() {\n        var data_layer = this;\n        var point_size = data_layer.resolveScalableParameter(data_layer.layout.point_size, {});\n        var spacing = data_layer.layout.label.spacing;\n        var handle_lines = Boolean(data_layer.layout.label.lines);\n        var min_x = 2 * spacing;\n        var max_x = data_layer.parent.layout.width - data_layer.parent.layout.margin.left - data_layer.parent.layout.margin.right - (2 * spacing);\n        var flip = function(dn, dnl) {\n            var dnx = +dn.attr('x');\n            var text_swing = (2 * spacing) + (2 * Math.sqrt(point_size));\n            if (handle_lines) {\n                var dnlx2 = +dnl.attr('x2');\n                var line_swing = spacing + (2 * Math.sqrt(point_size));\n            }\n            if (dn.style('text-anchor') === 'start') {\n                dn.style('text-anchor', 'end');\n                dn.attr('x', dnx - text_swing);\n                if (handle_lines) { dnl.attr('x2', dnlx2 - line_swing); }\n            } else {\n                dn.style('text-anchor', 'start');\n                dn.attr('x', dnx + text_swing);\n                if (handle_lines) { dnl.attr('x2', dnlx2 + line_swing); }\n            }\n        };\n        // Flip any going over the right edge from the right side to the left side\n        // (all labels start on the right side)\n        data_layer.label_texts.each(function (d, i) {\n            var a = this;\n            var da = d3.select(a);\n            var dax = +da.attr('x');\n            var abound = da.node().getBoundingClientRect();\n            if (dax + abound.width + spacing > max_x) {\n                var dal = handle_lines ? d3.select(data_layer.label_lines[0][i]) : null;\n                flip(da, dal);\n            }\n        });\n        // Second pass to flip any others that haven't flipped yet if they collide with another label\n        data_layer.label_texts.each(function (d, i) {\n            var a = this;\n            var da = d3.select(a);\n            if (da.style('text-anchor') === 'end') {\n                return;\n            }\n            var dax = +da.attr('x');\n            var abound = da.node().getBoundingClientRect();\n            var dal = handle_lines ? d3.select(data_layer.label_lines[0][i]) : null;\n            data_layer.label_texts.each(function () {\n                var b = this;\n                var db = d3.select(b);\n                var bbound = db.node().getBoundingClientRect();\n                var collision = abound.left < bbound.left + bbound.width + (2 * spacing) &&\n                    abound.left + abound.width + (2 * spacing) > bbound.left &&\n                    abound.top < bbound.top + bbound.height + (2 * spacing) &&\n                    abound.height + abound.top + (2 * spacing) > bbound.top;\n                if (collision) {\n                    flip(da, dal);\n                    // Double check that this flip didn't push the label past min_x. If it did, immediately flip back.\n                    dax = +da.attr('x');\n                    if (dax - abound.width - spacing < min_x) {\n                        flip(da, dal);\n                    }\n                }\n                return;\n            });\n        });\n    };\n\n    // Recursive function to space labels apart immediately after initial render\n    // Adapted from thudfactor's fiddle here: https://jsfiddle.net/thudfactor/HdwTH/\n    // TODO: Make labels also aware of data elements\n    this.separate_labels = function() {\n        this.seperate_iterations++;\n        var data_layer = this;\n        var alpha = 0.5;\n        if (!this.layout.label) {\n            // Guard against layout changing in the midst of iterative rerender\n            return;\n        }\n        var spacing = this.layout.label.spacing;\n        var again = false;\n        data_layer.label_texts.each(function () {\n            var a = this;\n            var da = d3.select(a);\n            var y1 = da.attr('y');\n            data_layer.label_texts.each(function () {\n                var b = this;\n                // a & b are the same element and don't collide.\n                if (a === b) {\n                    return;\n                }\n                var db = d3.select(b);\n                // a & b are on opposite sides of the chart and\n                // don't collide\n                if (da.attr('text-anchor') !== db.attr('text-anchor')) {\n                    return;\n                }\n                // Determine if the  bounding rects for the two text elements collide\n                var abound = da.node().getBoundingClientRect();\n                var bbound = db.node().getBoundingClientRect();\n                var collision = abound.left < bbound.left + bbound.width + (2 * spacing) &&\n                    abound.left + abound.width + (2 * spacing) > bbound.left &&\n                    abound.top < bbound.top + bbound.height + (2 * spacing) &&\n                    abound.height + abound.top + (2 * spacing) > bbound.top;\n                if (!collision) {\n                    return;\n                }\n                again = true;\n                // If the labels collide, we'll push each\n                // of the two labels up and down a little bit.\n                var y2 = db.attr('y');\n                var sign = abound.top < bbound.top ? 1 : -1;\n                var adjust = sign * alpha;\n                var new_a_y = +y1 - adjust;\n                var new_b_y = +y2 + adjust;\n                // Keep new values from extending outside the data layer\n                var min_y = 2 * spacing;\n                var max_y = data_layer.parent.layout.height - data_layer.parent.layout.margin.top - data_layer.parent.layout.margin.bottom - (2 * spacing);\n                var delta;\n                if (new_a_y - (abound.height / 2) < min_y) {\n                    delta = +y1 - new_a_y;\n                    new_a_y = +y1;\n                    new_b_y += delta;\n                } else if (new_b_y - (bbound.height / 2) < min_y) {\n                    delta = +y2 - new_b_y;\n                    new_b_y = +y2;\n                    new_a_y += delta;\n                }\n                if (new_a_y + (abound.height / 2) > max_y) {\n                    delta = new_a_y - +y1;\n                    new_a_y = +y1;\n                    new_b_y -= delta;\n                } else if (new_b_y + (bbound.height / 2) > max_y) {\n                    delta = new_b_y - +y2;\n                    new_b_y = +y2;\n                    new_a_y -= delta;\n                }\n                da.attr('y',new_a_y);\n                db.attr('y',new_b_y);\n            });\n        });\n        if (again) {\n            // Adjust lines to follow the labels\n            if (data_layer.layout.label.lines) {\n                var label_elements = data_layer.label_texts[0];\n                data_layer.label_lines.attr('y2',function(d,i) {\n                    var label_line = d3.select(label_elements[i]);\n                    return label_line.attr('y');\n                });\n            }\n            // After ~150 iterations we're probably beyond diminising returns, so stop recursing\n            if (this.seperate_iterations < 150) {\n                setTimeout(function() {\n                    this.separate_labels();\n                }.bind(this), 1);\n            }\n        }\n    };\n\n    // Implement the main render function\n    this.render = function() {\n\n        var data_layer = this;\n        var x_scale = 'x_scale';\n        var y_scale = 'y' + this.layout.y_axis.axis + '_scale';\n\n        if (this.layout.label) {\n            // Apply filters to generate a filtered data set\n            var filtered_data = this.data.filter(function(d) {\n                if (!data_layer.layout.label.filters) {\n                    return true;\n                } else {\n                    // Start by assuming a match, run through all filters to test if not a match on any one\n                    var match = true;\n                    data_layer.layout.label.filters.forEach(function(filter) {\n                        var field_value = (new LocusZoom.Data.Field(filter.field)).resolve(d);\n                        if (['!=', '='].indexOf(filter.operator) === -1 && isNaN(field_value)) {\n                            // If the filter can only be used with numbers, then the value must be numeric.\n                            match = false;\n                        } else {\n                            switch (filter.operator) {\n                            case '<':\n                                if (!(field_value < filter.value)) { match = false; }\n                                break;\n                            case '<=':\n                                if (!(field_value <= filter.value)) { match = false; }\n                                break;\n                            case '>':\n                                if (!(field_value > filter.value)) { match = false; }\n                                break;\n                            case '>=':\n                                if (!(field_value >= filter.value)) { match = false; }\n                                break;\n                            case '=':\n                                if (!(field_value === filter.value)) { match = false; }\n                                break;\n                            case '!=':\n                                // Deliberately allow weak comparisons to test for \"anything with a value present\" (null or undefined)\n                                // eslint-disable-next-line eqeqeq\n                                if (field_value == filter.value) { match = false; }\n                                break;\n                            default:\n                                // If we got here the operator is not valid, so the filter should fail\n                                match = false;\n                                break;\n                            }\n                        }\n                    });\n                    return match;\n                }\n            });\n            // Render label groups\n            var self = this;\n            this.label_groups = this.svg.group\n                .selectAll('g.lz-data_layer-' + this.layout.type + '-label')\n                .data(filtered_data, function(d) { return d[self.layout.id_field]  + '_label'; });\n            this.label_groups.enter()\n                .append('g')\n                .attr('class', 'lz-data_layer-' + this.layout.type + '-label');\n            // Render label texts\n            if (this.label_texts) { this.label_texts.remove(); }\n            this.label_texts = this.label_groups.append('text')\n                .attr('class', 'lz-data_layer-' + this.layout.type + '-label');\n            this.label_texts\n                .text(function(d) {\n                    return LocusZoom.parseFields(d, data_layer.layout.label.text || '');\n                })\n                .style(data_layer.layout.label.style || {})\n                .attr({\n                    'x': function(d) {\n                        var x = data_layer.parent[x_scale](d[data_layer.layout.x_axis.field])\n                              + Math.sqrt(data_layer.resolveScalableParameter(data_layer.layout.point_size, d))\n                              + data_layer.layout.label.spacing;\n                        if (isNaN(x)) { x = -1000; }\n                        return x;\n                    },\n                    'y': function(d) {\n                        var y = data_layer.parent[y_scale](d[data_layer.layout.y_axis.field]);\n                        if (isNaN(y)) { y = -1000; }\n                        return y;\n                    },\n                    'text-anchor': function() {\n                        return 'start';\n                    }\n                });\n            // Render label lines\n            if (data_layer.layout.label.lines) {\n                if (this.label_lines) { this.label_lines.remove(); }\n                this.label_lines = this.label_groups.append('line')\n                    .attr('class', 'lz-data_layer-' + this.layout.type + '-label');\n                this.label_lines\n                    .style(data_layer.layout.label.lines.style || {})\n                    .attr({\n                        'x1': function(d) {\n                            var x = data_layer.parent[x_scale](d[data_layer.layout.x_axis.field]);\n                            if (isNaN(x)) { x = -1000; }\n                            return x;\n                        },\n                        'y1': function(d) {\n                            var y = data_layer.parent[y_scale](d[data_layer.layout.y_axis.field]);\n                            if (isNaN(y)) { y = -1000; }\n                            return y;\n                        },\n                        'x2': function(d) {\n                            var x = data_layer.parent[x_scale](d[data_layer.layout.x_axis.field])\n                                  + Math.sqrt(data_layer.resolveScalableParameter(data_layer.layout.point_size, d))\n                                  + (data_layer.layout.label.spacing / 2);\n                            if (isNaN(x)) { x = -1000; }\n                            return x;\n                        },\n                        'y2': function(d) {\n                            var y = data_layer.parent[y_scale](d[data_layer.layout.y_axis.field]);\n                            if (isNaN(y)) { y = -1000; }\n                            return y;\n                        }\n                    });\n            }\n            // Remove labels when they're no longer in the filtered data set\n            this.label_groups.exit().remove();\n        } else {\n            // If the layout definition has changed (& no longer specifies labels), strip any previously rendered\n            if (this.label_groups) { this.label_groups.remove(); }\n            if (this.label_lines) { this.label_lines.remove(); }\n        }\n\n        // Generate main scatter data elements\n        var selection = this.svg.group\n            .selectAll('path.lz-data_layer-' + this.layout.type)\n            .data(this.data, function(d) { return d[this.layout.id_field]; }.bind(this));\n\n        // Create elements, apply class, ID, and initial position\n        var initial_y = isNaN(this.parent.layout.height) ? 0 : this.parent.layout.height;\n        selection.enter()\n            .append('path')\n            .attr('class', 'lz-data_layer-' + this.layout.type)\n            .attr('id', function(d) { return this.getElementId(d); }.bind(this))\n            .attr('transform', 'translate(0,' + initial_y + ')');\n\n        // Generate new values (or functions for them) for position, color, size, and shape\n        var transform = function(d) {\n            var x = this.parent[x_scale](d[this.layout.x_axis.field]);\n            var y = this.parent[y_scale](d[this.layout.y_axis.field]);\n            if (isNaN(x)) { x = -1000; }\n            if (isNaN(y)) { y = -1000; }\n            return 'translate(' + x + ',' + y + ')';\n        }.bind(this);\n\n        var fill = function(d) { return this.resolveScalableParameter(this.layout.color, d); }.bind(this);\n        var fill_opacity = function(d) { return this.resolveScalableParameter(this.layout.fill_opacity, d); }.bind(this);\n\n        var shape = d3.svg.symbol()\n            .size(function(d) { return this.resolveScalableParameter(this.layout.point_size, d); }.bind(this))\n            .type(function(d) { return this.resolveScalableParameter(this.layout.point_shape, d); }.bind(this));\n\n        // Apply position and color, using a transition if necessary\n\n        if (this.canTransition()) {\n            selection\n                .transition()\n                .duration(this.layout.transition.duration || 0)\n                .ease(this.layout.transition.ease || 'cubic-in-out')\n                .attr('transform', transform)\n                .attr('fill', fill)\n                .attr('fill-opacity', fill_opacity)\n                .attr('d', shape);\n        } else {\n            selection\n                .attr('transform', transform)\n                .attr('fill', fill)\n                .attr('fill-opacity', fill_opacity)\n                .attr('d', shape);\n        }\n\n        // Remove old elements as needed\n        selection.exit().remove();\n\n        // Apply default event emitters to selection\n        selection.on('click.event_emitter', function(element) {\n            this.parent.emit('element_clicked', element, true);\n        }.bind(this));\n\n        // Apply mouse behaviors\n        this.applyBehaviors(selection);\n\n        // Apply method to keep labels from overlapping each other\n        if (this.layout.label) {\n            this.flip_labels();\n            this.seperate_iterations = 0;\n            this.separate_labels();\n            // Apply default event emitters to selection\n            this.label_texts.on('click.event_emitter', function(element) {\n                this.parent.emit('element_clicked', element, true);\n            }.bind(this));\n            // Extend mouse behaviors to labels\n            this.applyBehaviors(this.label_texts);\n        }\n\n    };\n\n    // Method to set a passed element as the LD reference in the plot-level state\n    this.makeLDReference = function(element) {\n        var ref = null;\n        if (typeof element == 'undefined') {\n            throw new Error('makeLDReference requires one argument of any type');\n        } else if (typeof element == 'object') {\n            if (this.layout.id_field && typeof element[this.layout.id_field] != 'undefined') {\n                ref = element[this.layout.id_field].toString();\n            } else if (typeof element['id'] != 'undefined') {\n                ref = element['id'].toString();\n            } else {\n                ref = element.toString();\n            }\n        } else {\n            ref = element.toString();\n        }\n        this.parent_plot.applyState({ ldrefvar: ref });\n    };\n\n    return this;\n\n});\n\n/**\n * A scatter plot in which the x-axis represents categories, rather than individual positions.\n * For example, this can be used by PheWAS plots to show related groups. This plot allows the categories to be\n *   determined dynamically when data is first loaded.\n *\n * @class LocusZoom.DataLayers.category_scatter\n * @augments LocusZoom.DataLayers.scatter\n */\nLocusZoom.DataLayers.extend('scatter', 'category_scatter', {\n    /**\n     * This plot layer makes certain assumptions about the data passed in. Transform the raw array of records from\n     *   the datasource to prepare it for plotting, as follows:\n     * 1. The scatter plot assumes that all records are given in sequence (pre-grouped by `category_field`)\n     * 2. It assumes that all records have an x coordinate for individual plotting\n     * @private\n     */\n    _prepareData: function() {\n        var xField = this.layout.x_axis.field || 'x';\n        // The (namespaced) field from `this.data` that will be used to assign datapoints to a given category & color\n        var category_field = this.layout.x_axis.category_field;\n        if (!category_field) {\n            throw new Error('Layout for ' + this.layout.id + ' must specify category_field');\n        }\n        // Sort the data so that things in the same category are adjacent (case-insensitive by specified field)\n        var sourceData = this.data\n            .sort(function(a, b) {\n                var ak = a[category_field];\n                var bk = b[category_field];\n                var av = ak.toString ? ak.toString().toLowerCase() : ak;\n                var bv = bk.toString ? bk.toString().toLowerCase() : bk;\n                return (av === bv) ? 0 : (av < bv ? -1 : 1);});\n        sourceData.forEach(function(d, i) {\n            // Implementation detail: Scatter plot requires specifying an x-axis value, and most datasources do not\n            //   specify plotting positions. If a point is missing this field, fill in a synthetic value.\n            d[xField] = d[xField] || i;\n        });\n        return sourceData;\n    },\n\n    /**\n     * Identify the unique categories on the plot, and update the layout with an appropriate color scheme.\n     * Also identify the min and max x value associated with the category, which will be used to generate ticks\n     * @private\n     * @returns {Object.<String, Number[]>} Series of entries used to build category name ticks {category_name: [min_x, max_x]}\n     */\n    _generateCategoryBounds: function() {\n        // TODO: API may return null values in category_field; should we add placeholder category label?\n        // The (namespaced) field from `this.data` that will be used to assign datapoints to a given category & color\n        var category_field = this.layout.x_axis.category_field;\n        var xField = this.layout.x_axis.field || 'x';\n        var uniqueCategories = {};\n        this.data.forEach(function(item) {\n            var category = item[category_field];\n            var x = item[xField];\n            var bounds = uniqueCategories[category] || [x, x];\n            uniqueCategories[category] = [Math.min(bounds[0], x), Math.max(bounds[1], x)];\n        });\n\n        var categoryNames = Object.keys(uniqueCategories);\n        this._setDynamicColorScheme(categoryNames);\n\n        return uniqueCategories;\n    },\n\n    /**\n     * This layer relies on defining its own category-based color scheme. Find the correct color config object to\n     *  be modified.\n     * @param [from_source]\n     * @returns {Object} A mutable reference to the layout configuration object\n     * @private\n     */\n    _getColorScale: function(from_source) {\n        from_source = from_source || this.layout;\n        // If the layout does not use a supported coloring scheme, or is already complete, this method should do nothing\n\n        // For legacy reasons, layouts can specify color as an object (only one way to set color), as opposed to the\n        //  preferred mechanism of array (multiple coloring options)\n        var color_params = from_source.color || []; // Object or scalar, no other options allowed\n        if (Array.isArray(color_params)) {\n            color_params = color_params.find(function(item) { return item.scale_function === 'categorical_bin'; });\n        }\n        if (!color_params || color_params.scale_function !== 'categorical_bin') {\n            throw new Error('This layer requires that color options be provided as a `categorical_bin`');\n        }\n        return color_params;\n    },\n\n    /**\n     * Automatically define a color scheme for the layer based on data returned from the server.\n     *   If part of the color scheme has been specified, it will fill in remaining missing information.\n     *\n     * There are three scenarios:\n     * 1. The layout does not specify either category names or (color) values. Dynamically build both based on\n     *    the data and update the layout.\n     * 2. The layout specifies colors, but not categories. Use that exact color information provided, and dynamically\n     *     determine what categories are present in the data. (cycle through the available colors, reusing if there\n     *     are a lot of categories)\n     * 3. The layout specifies exactly what colors and categories to use (and they match the data!). This is useful to\n     *    specify an explicit mapping between color scheme and category names, when you want to be sure that the\n     *    plot matches a standard color scheme.\n     *    (If the layout specifies categories that do not match the data, the user specified categories will be ignored)\n     *\n     * This method will only act if the layout defines a `categorical_bin` scale function for coloring. It may be\n     *   overridden in a subclass to suit other types of coloring methods.\n     *\n     * @param {String[]} categoryNames\n     * @private\n     */\n    _setDynamicColorScheme: function(categoryNames) {\n        var colorParams = this._getColorScale(this.layout).parameters;\n        var baseParams = this._getColorScale(this._base_layout).parameters;\n\n        if (baseParams.categories.length && baseParams.values.length) {\n            // If there are preset category/color combos, make sure that they apply to the actual dataset\n            var parameters_categories_hash = {};\n            baseParams.categories.forEach(function (category) { parameters_categories_hash[category] = 1; });\n            if (categoryNames.every(function (name) { return parameters_categories_hash.hasOwnProperty(name); })) {\n                // The layout doesn't have to specify categories in order, but make sure they are all there\n                colorParams.categories = baseParams.categories;\n            } else {\n                colorParams.categories = categoryNames;\n            }\n        } else {\n            colorParams.categories = categoryNames;\n        }\n        // Prefer user-specified colors if provided. Make sure that there are enough colors for all the categories.\n        var colors;\n        if (baseParams.values.length) {\n            colors = baseParams.values;\n        } else {\n            var color_scale = categoryNames.length <= 10 ? d3.scale.category10 : d3.scale.category20;\n            colors = color_scale().range();\n        }\n        while (colors.length < categoryNames.length) { colors = colors.concat(colors); }\n        colors = colors.slice(0, categoryNames.length);  // List of hex values, should be of same length as categories array\n        colorParams.values = colors;\n    },\n\n    /**\n     *\n     * @param dimension\n     * @param {Object} [config] Parameters that customize how ticks are calculated (not style)\n     * @param {('left'|'center'|'right')} [config.position='left'] Align ticks with the center or edge of category\n     * @returns {Array}\n     */\n    getTicks: function(dimension, config) { // Overrides parent method\n        if (['x', 'y1', 'y2'].indexOf(dimension) === -1) {\n            throw new Error('Invalid dimension identifier');\n        }\n        var position = config.position || 'left';\n        if (['left', 'center', 'right'].indexOf(position) === -1) {\n            throw new Error('Invalid tick position');\n        }\n\n        var categoryBounds = this._categories;\n        if (!categoryBounds || !Object.keys(categoryBounds).length) {\n            return [];\n        }\n\n        if (dimension === 'y') {\n            return [];\n        }\n\n        if (dimension === 'x') {\n            // If colors have been defined by this layer, use them to make tick colors match scatterplot point colors\n            var colors = this._getColorScale(this.layout);\n            var knownCategories = colors.parameters.categories || [];\n            var knownColors = colors.parameters.values || [];\n\n            return Object.keys(categoryBounds).map(function (category, index) {\n                var bounds = categoryBounds[category];\n                var xPos;\n\n                switch(position) {\n                case 'left':\n                    xPos = bounds[0];\n                    break;\n                case 'center':\n                    // Center tick under one or many elements as appropriate\n                    var diff = bounds[1] - bounds[0];\n                    xPos = bounds[0] + (diff !== 0 ? diff : bounds[0]) / 2;\n                    break;\n                case 'right':\n                    xPos = bounds[1];\n                    break;\n                }\n                return {\n                    x: xPos,\n                    text: category,\n                    style: {\n                        'fill': knownColors[knownCategories.indexOf(category)] || '#000000'\n                    }\n                };\n            });\n        }\n    },\n\n    applyCustomDataMethods: function() {\n        this.data = this._prepareData();\n        /**\n         * Define category names and extents (boundaries) for plotting.  TODO: properties in constructor\n         * @member {Object.<String, Number[]>} Category names and extents, in the form {category_name: [min_x, max_x]}\n         */\n        this._categories = this._generateCategoryBounds();\n        return this;\n    }\n});\n","/* global LocusZoom */\n'use strict';\n\n/**\n * An SVG object used to display contextual information about a panel.\n * Panel layouts determine basic features of a legend - its position in the panel, orientation, title, etc.\n * Layouts of child data layers of the panel determine the actual content of the legend.\n *\n * @class\n * @param {LocusZoom.Panel} parent\n*/\nLocusZoom.Legend = function(parent) {\n    if (!(parent instanceof LocusZoom.Panel)) {\n        throw new Error('Unable to create legend, parent must be a locuszoom panel');\n    }\n    /** @member {LocusZoom.Panel} */\n    this.parent = parent;\n    /** @member {String} */\n    this.id = this.parent.getBaseId() + '.legend';\n\n    this.parent.layout.legend = LocusZoom.Layouts.merge(this.parent.layout.legend || {}, LocusZoom.Legend.DefaultLayout);\n    /** @member {Object} */\n    this.layout = this.parent.layout.legend;\n\n    /** @member {d3.selection} */\n    this.selector = null;\n    /** @member {d3.selection} */\n    this.background_rect = null;\n    /** @member {d3.selection[]} */\n    this.elements = [];\n    /**\n     * SVG selector for the group containing all elements in the legend\n     * @protected\n     * @member {d3.selection|null}\n     */\n    this.elements_group = null;\n\n    /**\n     * TODO: Not sure if this property is used; the external-facing methods are setting `layout.hidden` instead. Tentatively mark deprecated.\n     * @deprecated\n     * @protected\n     * @member {Boolean}\n     */\n    this.hidden = false;\n\n    // TODO Revisit constructor return value; see https://stackoverflow.com/a/3350364/1422268\n    return this.render();\n};\n\n/**\n * The default layout used by legends (used internally)\n * @protected\n * @member {Object}\n */\nLocusZoom.Legend.DefaultLayout = {\n    orientation: 'vertical',\n    origin: { x: 0, y: 0 },\n    width: 10,\n    height: 10,\n    padding: 5,\n    label_size: 12,\n    hidden: false\n};\n\n/**\n * Render the legend in the parent panel\n */\nLocusZoom.Legend.prototype.render = function() {\n\n    // Get a legend group selector if not yet defined\n    if (!this.selector) {\n        this.selector = this.parent.svg.group.append('g')\n            .attr('id', this.parent.getBaseId() + '.legend').attr('class', 'lz-legend');\n    }\n\n    // Get a legend background rect selector if not yet defined\n    if (!this.background_rect) {\n        this.background_rect = this.selector.append('rect')\n            .attr('width', 100).attr('height', 100).attr('class', 'lz-legend-background');\n    }\n\n    // Get a legend elements group selector if not yet defined\n    if (!this.elements_group) {\n        this.elements_group = this.selector.append('g');\n    }\n\n    // Remove all elements from the document and re-render from scratch\n    this.elements.forEach(function(element) {\n        element.remove();\n    });\n    this.elements = [];\n\n    // Gather all elements from data layers in order (top to bottom) and render them\n    var padding = +this.layout.padding || 1;\n    var x = padding;\n    var y = padding;\n    var line_height = 0;\n    this.parent.data_layer_ids_by_z_index.slice().reverse().forEach(function(id) {\n        if (Array.isArray(this.parent.data_layers[id].layout.legend)) {\n            this.parent.data_layers[id].layout.legend.forEach(function(element) {\n                var selector = this.elements_group.append('g')\n                    .attr('transform', 'translate(' + x + ',' + y + ')');\n                var label_size = +element.label_size || +this.layout.label_size || 12;\n                var label_x = 0;\n                var label_y = (label_size / 2) + (padding / 2);\n                line_height = Math.max(line_height, label_size + padding);\n                // Draw the legend element symbol (line, rect, shape, etc)\n                if (element.shape === 'line') {\n                    // Line symbol\n                    var length = +element.length || 16;\n                    var path_y = (label_size / 4) + (padding / 2);\n                    selector.append('path').attr('class', element.class || '')\n                        .attr('d', 'M0,' + path_y + 'L' + length + ',' + path_y)\n                        .style(element.style || {});\n                    label_x = length + padding;\n                } else if (element.shape === 'rect') {\n                    // Rect symbol\n                    var width = +element.width || 16;\n                    var height = +element.height || width;\n                    selector.append('rect').attr('class', element.class || '')\n                        .attr('width', width).attr('height', height)\n                        .attr('fill', element.color || {})\n                        .style(element.style || {});\n                    label_x = width + padding;\n                    line_height = Math.max(line_height, height + padding);\n                } else if (d3.svg.symbolTypes.indexOf(element.shape) !== -1) {\n                    // Shape symbol (circle, diamond, etc.)\n                    var size = +element.size || 40;\n                    var radius = Math.ceil(Math.sqrt(size / Math.PI));\n                    selector.append('path').attr('class', element.class || '')\n                        .attr('d', d3.svg.symbol().size(size).type(element.shape))\n                        .attr('transform', 'translate(' + radius + ',' + (radius + (padding / 2)) + ')')\n                        .attr('fill', element.color || {})\n                        .style(element.style || {});\n                    label_x = (2 * radius) + padding;\n                    label_y = Math.max((2 * radius) + (padding / 2), label_y);\n                    line_height = Math.max(line_height, (2 * radius) + padding);\n                }\n                // Draw the legend element label\n                selector.append('text').attr('text-anchor', 'left').attr('class', 'lz-label')\n                    .attr('x', label_x).attr('y', label_y).style({'font-size': label_size}).text(element.label);\n                // Position the legend element group based on legend layout orientation\n                var bcr = selector.node().getBoundingClientRect();\n                if (this.layout.orientation === 'vertical') {\n                    y += bcr.height + padding;\n                    line_height = 0;\n                } else {\n                    // Ensure this element does not exceed the panel width\n                    // (E.g. drop to the next line if it does, but only if it's not the only element on this line)\n                    var right_x = this.layout.origin.x + x + bcr.width;\n                    if (x > padding && right_x > this.parent.layout.width) {\n                        y += line_height;\n                        x = padding;\n                        selector.attr('transform', 'translate(' + x + ',' + y + ')');\n                    }\n                    x += bcr.width + (3 * padding);\n                }\n                // Store the element\n                this.elements.push(selector);\n            }.bind(this));\n        }\n    }.bind(this));\n\n    // Scale the background rect to the elements in the legend\n    var bcr = this.elements_group.node().getBoundingClientRect();\n    this.layout.width = bcr.width + (2 * this.layout.padding);\n    this.layout.height = bcr.height + (2 * this.layout.padding);\n    this.background_rect\n        .attr('width', this.layout.width)\n        .attr('height', this.layout.height);\n\n    // Set the visibility on the legend from the \"hidden\" flag\n    // TODO: `show()` and `hide()` call a full rerender; might be able to make this more lightweight?\n    this.selector.style({ visibility: this.layout.hidden ? 'hidden' : 'visible' });\n\n    // TODO: Annotate return type and make consistent\n    return this.position();\n};\n\n/**\n * Place the legend in position relative to the panel, as specified in the layout configuration\n * @returns {LocusZoom.Legend | null}\n * TODO: should this always be chainable?\n */\nLocusZoom.Legend.prototype.position = function() {\n    if (!this.selector) { return this; }\n    var bcr = this.selector.node().getBoundingClientRect();\n    if (!isNaN(+this.layout.pad_from_bottom)) {\n        this.layout.origin.y = this.parent.layout.height - bcr.height - +this.layout.pad_from_bottom;\n    }\n    if (!isNaN(+this.layout.pad_from_right)) {\n        this.layout.origin.x = this.parent.layout.width - bcr.width - +this.layout.pad_from_right;\n    }\n    this.selector.attr('transform', 'translate(' + this.layout.origin.x + ',' + this.layout.origin.y + ')');\n};\n\n/**\n * Hide the legend (triggers a re-render)\n * @public\n */\nLocusZoom.Legend.prototype.hide = function() {\n    this.layout.hidden = true;\n    this.render();\n};\n\n/**\n * Show the legend (triggers a re-render)\n * @public\n */\nLocusZoom.Legend.prototype.show = function() {\n    this.layout.hidden = false;\n    this.render();\n};\n","/* global LocusZoom */\n'use strict';\n\n/**\n * An independent LocusZoom object that renders a unique set of data and subpanels.\n * Many such LocusZoom objects can exist simultaneously on a single page, each having its own layout.\n *\n * This creates a new plot instance, but does not immediately render it. For practical use, it may be more convenient\n * to use the `LocusZoom.populate` helper method.\n *\n * @class\n * @param {String} id The ID of the plot. Often corresponds to the ID of the container element on the page\n *   where the plot is rendered..\n * @param {LocusZoom.DataSources} datasource Ensemble of data providers used by the plot\n * @param {Object} layout A JSON-serializable object of layout configuration parameters\n*/\nLocusZoom.Plot = function(id, datasource, layout) {\n    /** @member Boolean} */\n    this.initialized = false;\n    // TODO: This makes sense for all other locuszoom elements to have; determine whether this is interface boilerplate or something that can be removed\n    this.parent_plot = this;\n\n    /** @member {String} */\n    this.id = id;\n\n    /** @member {Element} */\n    this.container = null;\n    /**\n     * Selector for a node that will contain the plot. (set externally by populate methods)\n     * @member {d3.selection}\n     */\n    this.svg = null;\n\n    /** @member {Object.<String, Number>} */\n    this.panels = {};\n    /**\n     * TODO: This is currently used by external classes that manipulate the parent and may indicate room for a helper method in the api to coordinate boilerplate\n     * @protected\n     * @member {String[]}\n     */\n    this.panel_ids_by_y_index = [];\n\n    /**\n     * Notify each child panel of the plot of changes in panel ordering/ arrangement\n     */\n    this.applyPanelYIndexesToPanelLayouts = function() {\n        this.panel_ids_by_y_index.forEach(function(pid, idx) {\n            this.panels[pid].layout.y_index = idx;\n        }.bind(this));\n    };\n\n    /**\n     * Get the qualified ID pathname for the plot\n     * @returns {String}\n     */\n    this.getBaseId = function() {\n        return this.id;\n    };\n\n    /**\n     * Track update operations (reMap) performed on all child panels, and notify the parent plot when complete\n     * TODO: Reconsider whether we need to be tracking this as global state outside of context of specific operations\n     * @protected\n     * @member {Promise[]}\n     */\n    this.remap_promises = [];\n\n    if (typeof layout == 'undefined') {\n        /**\n         * The layout is a serializable object used to describe the composition of the Plot\n         *   If no layout was passed, use the Standard Association Layout\n         *   Otherwise merge whatever was passed with the Default Layout\n         *   TODO: Review description; we *always* merge with default layout?\n         * @member {Object}\n         */\n        this.layout = LocusZoom.Layouts.merge({}, LocusZoom.Layouts.get('plot', 'standard_association'));\n    } else {\n        this.layout = layout;\n    }\n    LocusZoom.Layouts.merge(this.layout, LocusZoom.Plot.DefaultLayout);\n\n    /**\n     * Values in the layout object may change during rendering etc. Retain a copy of the original plot state\n     * @member {Object}\n     */\n    this._base_layout = JSON.parse(JSON.stringify(this.layout));\n\n\n    /**\n     * Create a shortcut to the state in the layout on the Plot. Tracking in the layout allows the plot to be created\n     *   with initial state/setup.\n     *\n     * Tracks state of the plot, eg start and end position\n     * @member {Object}\n     */\n    this.state = this.layout.state;\n\n    /** @member {LocusZoom.Data.Requester} */\n    this.lzd = new LocusZoom.Data.Requester(datasource);\n\n    /**\n     * Window.onresize listener (responsive layouts only)\n     * TODO: .on appears to return a selection, not a listener? Check logic here\n     * https://github.com/d3/d3-selection/blob/00b904b9bcec4dfaf154ae0bbc777b1fc1d7bc08/test/selection/on-test.js#L11\n     * @deprecated\n     * @member {d3.selection}\n     */\n    this.window_onresize = null;\n\n    /**\n     * Known event hooks that the panel can respond to\n     * @protected\n     * @member {Object}\n     */\n    this.event_hooks = {\n        'layout_changed': [],\n        'data_requested': [],\n        'data_rendered': [],\n        'element_clicked': [], // Select or unselect\n        'element_selection': [], // Element becomes active (only)\n        'match_requested': [], // A data layer is attempting to highlight matching points (internal use only)\n        'panel_removed': [],\n        'state_changed': []  // Only triggered when a state change causes rerender\n    };\n\n    /**\n     * @callback eventCallback\n     * @param {object} eventData A description of the event\n     * @param {String|null} eventData.sourceID The unique identifier (eg plot or parent name) of the element that\n     *  triggered the event. Will be automatically filled in if not explicitly provided.\n     * @param {Object|null} eventData.context Any additional information to be passed to the callback, eg the data\n     *   associated with a clicked plot element\n     */\n\n    /**\n     * There are several events that a LocusZoom plot can \"emit\" when appropriate, and LocusZoom supports registering\n     *   \"hooks\" for these events which are essentially custom functions intended to fire at certain times.\n     *\n     * The following plot-level events are currently supported:\n     *   - `layout_changed` - context: plot - Any aspect of the plot's layout (including dimensions or state) has changed.\n     *   - `data_requested` - context: plot - A request for new data from any data source used in the plot has been made.\n     *   - `data_rendered` - context: plot - Data from a request has been received and rendered in the plot.\n     *   - `element_clicked` - context: plot - A data element in any of the plot's data layers has been clicked.\n     *   - `element_selection` - context: plot - Triggered when an element changes \"selection\" status, and identifies\n     *        whether the element is being selected or deselected.\n     *\n     * To register a hook for any of these events use `plot.on('event_name', function() {})`.\n     *\n     * There can be arbitrarily many functions registered to the same event. They will be executed in the order they\n     *   were registered. The this context bound to each event hook function is dependent on the type of event, as\n     *   denoted above. For example, when data_requested is emitted the context for this in the event hook will be the\n     *   plot itself, but when element_clicked is emitted the context for this in the event hook will be the element\n     *   that was clicked.\n     *\n     * @param {String} event The name of an event (as defined in `event_hooks`)\n     * @param {eventCallback} hook\n     * @returns {function} The registered event listener\n     */\n    this.on = function(event, hook) {\n        if (typeof 'event' != 'string' || !Array.isArray(this.event_hooks[event])) {\n            throw new Error('Unable to register event hook, invalid event: ' + event.toString());\n        }\n        if (typeof hook != 'function') {\n            throw new Error('Unable to register event hook, invalid hook function passed');\n        }\n        this.event_hooks[event].push(hook);\n        return hook;\n    };\n    /**\n     * Remove one or more previously defined event listeners\n     * @param {String} event The name of an event (as defined in `event_hooks`)\n     * @param {eventCallback} [hook] The callback to deregister\n     * @returns {LocusZoom.Plot}\n     */\n    this.off = function(event, hook) {\n        var theseHooks = this.event_hooks[event];\n        if (typeof 'event' != 'string' || !Array.isArray(theseHooks)) {\n            throw new Error('Unable to remove event hook, invalid event: ' + event.toString());\n        }\n        if (hook === undefined) {\n            // Deregistering all hooks for this event may break basic functionality, and should only be used during\n            //  cleanup operations (eg to prevent memory leaks)\n            this.event_hooks[event] = [];\n        } else {\n            var hookMatch = theseHooks.indexOf(hook);\n            if (hookMatch !== -1) {\n                theseHooks.splice(hookMatch, 1);\n            } else {\n                throw new Error('The specified event listener is not registered and therefore cannot be removed');\n            }\n        }\n        return this;\n    };\n    /**\n     * Handle running of event hooks when an event is emitted\n     * @param {string} event A known event name\n     * @param {*} eventData Data or event description that will be passed to the event listener\n     * @returns {LocusZoom.Plot}\n     */\n    this.emit = function(event, eventData) {\n        // TODO: there are small differences between the emit implementation between plots and panels. In the future,\n        //  DRY this code via mixins, and make sure to keep the interfaces compatible when refactoring.\n        if (typeof 'event' != 'string' || !Array.isArray(this.event_hooks[event])) {\n            throw new Error('LocusZoom attempted to throw an invalid event: ' + event.toString());\n        }\n        var sourceID = this.getBaseId();\n        var self = this;\n        this.event_hooks[event].forEach(function(hookToRun) {\n            var eventContext;\n            if (eventData && eventData.sourceID) {\n                // If we detect that an event originated elsewhere (via bubbling or externally), preserve the context\n                //  when re-emitting the event to plot-level listeners\n                eventContext = eventData;\n            } else {\n                eventContext = {sourceID: sourceID, data: eventData || null};\n            }\n            // By default, any handlers fired here (either directly, or bubbled) will see the plot as the\n            //  value of `this`. If a bound function is registered as a handler, the previously bound `this` will\n            //  override anything provided to `call` below.\n            hookToRun.call(self, eventContext);\n        });\n        return this;\n    };\n\n    /**\n     * Get an object with the x and y coordinates of the plot's origin in terms of the entire page\n     * Necessary for positioning any HTML elements over the plot\n     * @returns {{x: Number, y: Number, width: Number, height: Number}}\n     */\n    this.getPageOrigin = function() {\n        var bounding_client_rect = this.svg.node().getBoundingClientRect();\n        var x_offset = document.documentElement.scrollLeft || document.body.scrollLeft;\n        var y_offset = document.documentElement.scrollTop || document.body.scrollTop;\n        var container = this.svg.node();\n        while (container.parentNode !== null) {\n            container = container.parentNode;\n            if (container !== document && d3.select(container).style('position') !== 'static') {\n                x_offset = -1 * container.getBoundingClientRect().left;\n                y_offset = -1 * container.getBoundingClientRect().top;\n                break;\n            }\n        }\n        return {\n            x: x_offset + bounding_client_rect.left,\n            y: y_offset + bounding_client_rect.top,\n            width: bounding_client_rect.width,\n            height: bounding_client_rect.height\n        };\n    };\n\n    /**\n     * Get the top and left offset values for the plot's container element (the div that was populated)\n     * @returns {{top: number, left: number}}\n     */\n    this.getContainerOffset = function() {\n        var offset = { top: 0, left: 0 };\n        var container = this.container.offsetParent || null;\n        while (container !== null) {\n            offset.top += container.offsetTop;\n            offset.left += container.offsetLeft;\n            container = container.offsetParent || null;\n        }\n        return offset;\n    };\n\n    //\n    /**\n     * Event information describing interaction (e.g. panning and zooming) is stored on the plot\n     * TODO: Add/ document details of interaction structure as we expand\n     * @member {{panel_id: String, linked_panel_ids: Array, x_linked: *, dragging: *, zooming: *}}\n     * @returns {LocusZoom.Plot}\n     */\n    this.interaction = {};\n\n    /**\n     * Track whether the target panel can respond to mouse interaction events\n     * @param {String} panel_id\n     * @returns {boolean}\n     */\n    this.canInteract = function(panel_id) {\n        panel_id = panel_id || null;\n        if (panel_id) {\n            return ((typeof this.interaction.panel_id == 'undefined' || this.interaction.panel_id === panel_id) && !this.loading_data);\n        } else {\n            return !(this.interaction.dragging || this.interaction.zooming || this.loading_data);\n        }\n    };\n\n    // Initialize the layout\n    this.initializeLayout();\n    return this;\n};\n\n/**\n * Default/ expected configuration parameters for basic plotting; most plots will override\n *\n * @protected\n * @static\n * @type {Object}\n */\nLocusZoom.Plot.DefaultLayout = {\n    state: {},\n    width: 1,\n    height: 1,\n    min_width: 1,\n    min_height: 1,\n    responsive_resize: false, // Allowed values: false, \"width_only\", \"both\" (synonym for true)\n    aspect_ratio: 1,\n    panels: [],\n    dashboard: {\n        components: []\n    },\n    panel_boundaries: true,\n    mouse_guide: true\n};\n\n/**\n * Helper method to sum the proportional dimensions of panels, a value that's checked often as panels are added/removed\n * @param {('Height'|'Width')} dimension\n * @returns {number}\n */\nLocusZoom.Plot.prototype.sumProportional = function(dimension) {\n    if (dimension !== 'height' && dimension !== 'width') {\n        throw new Error('Bad dimension value passed to LocusZoom.Plot.prototype.sumProportional');\n    }\n    var total = 0;\n    for (var id in this.panels) {\n        // Ensure every panel contributing to the sum has a non-zero proportional dimension\n        if (!this.panels[id].layout['proportional_' + dimension]) {\n            this.panels[id].layout['proportional_' + dimension] = 1 / Object.keys(this.panels).length;\n        }\n        total += this.panels[id].layout['proportional_' + dimension];\n    }\n    return total;\n};\n\n/**\n * Resize the plot to fit the bounding container\n * @returns {LocusZoom.Plot}\n */\nLocusZoom.Plot.prototype.rescaleSVG = function() {\n    var clientRect = this.svg.node().getBoundingClientRect();\n    this.setDimensions(clientRect.width, clientRect.height);\n    return this;\n};\n\n/**\n * Prepare the plot for first use by performing parameter validation, setting up panels, and calculating dimensions\n * @returns {LocusZoom.Plot}\n */\nLocusZoom.Plot.prototype.initializeLayout = function() {\n\n    // Sanity check layout values\n    if (isNaN(this.layout.width) || this.layout.width <= 0) {\n        throw new Error('Plot layout parameter `width` must be a positive number');\n    }\n    if (isNaN(this.layout.height) || this.layout.height <= 0) {\n        throw new Error('Plot layout parameter `width` must be a positive number');\n    }\n    if (isNaN(this.layout.aspect_ratio) || this.layout.aspect_ratio <= 0) {\n        throw new Error('Plot layout parameter `aspect_ratio` must be a positive number');\n    }\n    if (this.layout.responsive_resize === true) {\n        // Backwards compatible support\n        console.warn('LocusZoom \"responsive_resize\" specifies a deprecated value. The new value should be \"both\". Please update your layout.');\n        this.layout.responsive_resize = 'both';\n    }\n    var RESIZE_MODES = [false, 'both', 'width_only'];\n    if (RESIZE_MODES.indexOf(this.layout.responsive_resize) === -1) {\n        throw new Error('LocusZoom option \"responsive_resize\" should specify one of the following modes: ' + RESIZE_MODES.join(', '));\n    }\n\n    // If this is a responsive layout then set a namespaced/unique onresize event listener on the window\n    if (this.layout.responsive_resize) {\n        this.window_onresize = d3.select(window).on('resize.lz-' + this.id, function() {\n            this.rescaleSVG();\n        }.bind(this));\n        // Forcing one additional setDimensions() call after the page is loaded clears up\n        // any disagreements between the initial layout and the loaded responsive container's size\n        d3.select(window).on('load.lz-' + this.id, function() {\n            this.setDimensions();\n        }.bind(this));\n    }\n\n    // Add panels\n    this.layout.panels.forEach(function(panel_layout) {\n        this.addPanel(panel_layout);\n    }.bind(this));\n\n    return this;\n};\n\n/**\n * Set the dimensions for a plot, and ensure that panels are sized and positioned correctly.\n *\n * If dimensions are provided, resizes each panel proportionally to match the new plot dimensions. Otherwise,\n *   calculates the appropriate plot dimensions based on all panels.\n * @param {Number} [width] If provided and larger than minimum size, set plot to this width\n * @param {Number} [height] If provided and larger than minimum size, set plot to this height\n * @returns {LocusZoom.Plot}\n */\nLocusZoom.Plot.prototype.setDimensions = function(width, height) {\n\n    var id;\n\n    // Update minimum allowable width and height by aggregating minimums from panels, then apply minimums to containing element.\n    var min_width = parseFloat(this.layout.min_width) || 0;\n    var min_height = parseFloat(this.layout.min_height) || 0;\n    for (id in this.panels) {\n        min_width = Math.max(min_width, this.panels[id].layout.min_width);\n        if (parseFloat(this.panels[id].layout.min_height) > 0 && parseFloat(this.panels[id].layout.proportional_height) > 0) {\n            min_height = Math.max(min_height, (this.panels[id].layout.min_height / this.panels[id].layout.proportional_height));\n        }\n    }\n    this.layout.min_width = Math.max(min_width, 1);\n    this.layout.min_height = Math.max(min_height, 1);\n    d3.select(this.svg.node().parentNode).style({\n        'min-width': this.layout.min_width + 'px',\n        'min-height': this.layout.min_height + 'px'\n    });\n\n    // If width and height arguments were passed then adjust them against plot minimums if necessary.\n    // Then resize the plot and proportionally resize panels to fit inside the new plot dimensions.\n    if (!isNaN(width) && width >= 0 && !isNaN(height) && height >= 0) {\n        this.layout.width = Math.max(Math.round(+width), this.layout.min_width);\n        this.layout.height = Math.max(Math.round(+height), this.layout.min_height);\n        this.layout.aspect_ratio = this.layout.width / this.layout.height;\n        // Override discrete values if resizing responsively\n        if (this.layout.responsive_resize) {\n            // All resize modes will affect width\n            if (this.svg) {\n                this.layout.width = Math.max(this.svg.node().parentNode.getBoundingClientRect().width, this.layout.min_width);\n            }\n\n            if (this.layout.responsive_resize === 'both') { // Then also change the height\n                this.layout.height = this.layout.width / this.layout.aspect_ratio;\n                if (this.layout.height < this.layout.min_height) {\n                    this.layout.height = this.layout.min_height;\n                    this.layout.width  = this.layout.height * this.layout.aspect_ratio;\n                }\n            }\n        }\n        // Resize/reposition panels to fit, update proportional origins if necessary\n        var y_offset = 0;\n        this.panel_ids_by_y_index.forEach(function(panel_id) {\n            var panel_width = this.layout.width;\n            var panel_height = this.panels[panel_id].layout.proportional_height * this.layout.height;\n            this.panels[panel_id].setDimensions(panel_width, panel_height);\n            this.panels[panel_id].setOrigin(0, y_offset);\n            this.panels[panel_id].layout.proportional_origin.x = 0;\n            this.panels[panel_id].layout.proportional_origin.y = y_offset / this.layout.height;\n            y_offset += panel_height;\n            this.panels[panel_id].dashboard.update();\n        }.bind(this));\n    }\n\n    // If width and height arguments were NOT passed (and panels exist) then determine the plot dimensions\n    // by making it conform to panel dimensions, assuming panels are already positioned correctly.\n    else if (Object.keys(this.panels).length) {\n        this.layout.width = 0;\n        this.layout.height = 0;\n        for (id in this.panels) {\n            this.layout.width = Math.max(this.panels[id].layout.width, this.layout.width);\n            this.layout.height += this.panels[id].layout.height;\n        }\n        this.layout.width = Math.max(this.layout.width, this.layout.min_width);\n        this.layout.height = Math.max(this.layout.height, this.layout.min_height);\n    }\n\n    // Keep aspect ratio in agreement with dimensions\n    this.layout.aspect_ratio = this.layout.width / this.layout.height;\n\n    // Apply layout width and height as discrete values or viewbox values\n    if (this.svg !== null) {\n        if (this.layout.responsive_resize === 'both') {\n            this.svg\n                .attr('viewBox', '0 0 ' + this.layout.width + ' ' + this.layout.height)\n                .attr('preserveAspectRatio', 'xMinYMin meet');\n        } else {\n            this.svg.attr('width', this.layout.width).attr('height', this.layout.height);\n        }\n    }\n\n    // If the plot has been initialized then trigger some necessary render functions\n    if (this.initialized) {\n        this.panel_boundaries.position();\n        this.dashboard.update();\n        this.curtain.update();\n        this.loader.update();\n    }\n\n    return this.emit('layout_changed');\n};\n\n/**\n * Create a new panel from a layout, and handle the work of initializing and placing the panel on the plot\n * @param {Object} layout\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Plot.prototype.addPanel = function(layout) {\n\n    // Sanity checks\n    if (typeof layout !== 'object') {\n        throw new Error('Invalid panel layout passed to LocusZoom.Plot.prototype.addPanel()');\n    }\n\n    // Create the Panel and set its parent\n    var panel = new LocusZoom.Panel(layout, this);\n\n    // Store the Panel on the Plot\n    this.panels[panel.id] = panel;\n\n    // If a discrete y_index was set in the layout then adjust other panel y_index values to accommodate this one\n    if (panel.layout.y_index !== null && !isNaN(panel.layout.y_index)\n        && this.panel_ids_by_y_index.length > 0) {\n        // Negative y_index values should count backwards from the end, so convert negatives to appropriate values here\n        if (panel.layout.y_index < 0) {\n            panel.layout.y_index = Math.max(this.panel_ids_by_y_index.length + panel.layout.y_index, 0);\n        }\n        this.panel_ids_by_y_index.splice(panel.layout.y_index, 0, panel.id);\n        this.applyPanelYIndexesToPanelLayouts();\n    } else {\n        var length = this.panel_ids_by_y_index.push(panel.id);\n        this.panels[panel.id].layout.y_index = length - 1;\n    }\n\n    // Determine if this panel was already in the layout.panels array.\n    // If it wasn't, add it. Either way store the layout.panels array index on the panel.\n    var layout_idx = null;\n    this.layout.panels.forEach(function(panel_layout, idx) {\n        if (panel_layout.id === panel.id) { layout_idx = idx; }\n    });\n    if (layout_idx === null) {\n        layout_idx = this.layout.panels.push(this.panels[panel.id].layout) - 1;\n    }\n    this.panels[panel.id].layout_idx = layout_idx;\n\n    // Call positionPanels() to keep panels from overlapping and ensure filling all available vertical space\n    if (this.initialized) {\n        this.positionPanels();\n        // Initialize and load data into the new panel\n        this.panels[panel.id].initialize();\n        this.panels[panel.id].reMap();\n        // An extra call to setDimensions with existing discrete dimensions fixes some rounding errors with tooltip\n        // positioning. TODO: make this additional call unnecessary.\n        this.setDimensions(this.layout.width, this.layout.height);\n    }\n\n    return this.panels[panel.id];\n};\n\n\n/**\n * Clear all state, tooltips, and other persisted data associated with one (or all) panel(s) in the plot\n *\n * This is useful when reloading an existing plot with new data, eg \"click for genome region\" links.\n *   This is a utility method for custom usage. It is not fired automatically during normal rerender of existing panels\n *   @param {String} [panelId] If provided, clear state for only this panel. Otherwise, clear state for all panels.\n *   @param {('wipe'|'reset')} [mode='wipe'] Optionally specify how state should be cleared. `wipe` deletes all data\n *     and is useful for when the panel is being removed; `reset` is best when the panel will be reused in place.\n * @returns {LocusZoom.Plot}\n */\nLocusZoom.Plot.prototype.clearPanelData = function(panelId, mode) {\n    mode = mode || 'wipe';\n\n    // TODO: Add unit tests for this method\n    var panelsList;\n    if (panelId) {\n        panelsList = [panelId];\n    } else {\n        panelsList = Object.keys(this.panels);\n    }\n    var self = this;\n    panelsList.forEach(function(pid) {\n        self.panels[pid].data_layer_ids_by_z_index.forEach(function(dlid) {\n            var layer = self.panels[pid].data_layers[dlid];\n            layer.destroyAllTooltips();\n\n            delete self.layout.state[pid + '.' + dlid];\n            if(mode === 'reset') {\n                layer.setDefaultState();\n            }\n        });\n    });\n    return this;\n};\n\n/**\n * Remove the panel from the plot, and clear any state, tooltips, or other visual elements belonging to nested content\n * @param {String} id\n * @returns {LocusZoom.Plot}\n */\nLocusZoom.Plot.prototype.removePanel = function(id) {\n    if (!this.panels[id]) {\n        throw new Error('Unable to remove panel, ID not found: ' + id);\n    }\n\n    // Hide all panel boundaries\n    this.panel_boundaries.hide();\n\n    // Destroy all tooltips and state vars for all data layers on the panel\n    this.clearPanelData(id);\n\n    // Remove all panel-level HTML overlay elements\n    this.panels[id].loader.hide();\n    this.panels[id].dashboard.destroy(true);\n    this.panels[id].curtain.hide();\n\n    // Remove the svg container for the panel if it exists\n    if (this.panels[id].svg.container) {\n        this.panels[id].svg.container.remove();\n    }\n\n    // Delete the panel and its presence in the plot layout and state\n    this.layout.panels.splice(this.panels[id].layout_idx, 1);\n    delete this.panels[id];\n    delete this.layout.state[id];\n\n    // Update layout_idx values for all remaining panels\n    this.layout.panels.forEach(function(panel_layout, idx) {\n        this.panels[panel_layout.id].layout_idx = idx;\n    }.bind(this));\n\n    // Remove the panel id from the y_index array\n    this.panel_ids_by_y_index.splice(this.panel_ids_by_y_index.indexOf(id), 1);\n    this.applyPanelYIndexesToPanelLayouts();\n\n    // Call positionPanels() to keep panels from overlapping and ensure filling all available vertical space\n    if (this.initialized) {\n        // Allow the plot to shrink when panels are removed, by forcing it to recalculate min dimensions from scratch\n        this.layout.min_height = this._base_layout.min_height;\n        this.layout.min_width = this._base_layout.min_width;\n\n        this.positionPanels();\n        // An extra call to setDimensions with existing discrete dimensions fixes some rounding errors with tooltip\n        // positioning. TODO: make this additional call unnecessary.\n        this.setDimensions(this.layout.width, this.layout.height);\n    }\n\n    this.emit('panel_removed', id);\n\n    return this;\n};\n\n\n/**\n * Automatically position panels based on panel positioning rules and values.\n * Keep panels from overlapping vertically by adjusting origins, and keep the sum of proportional heights at 1.\n *\n * TODO: This logic currently only supports dynamic positioning of panels to prevent overlap in a VERTICAL orientation.\n *      Some framework exists for positioning panels in horizontal orientations as well (width, proportional_width, origin.x, etc.)\n *      but the logic for keeping these user-definable values straight approaches the complexity of a 2D box-packing algorithm.\n *      That's complexity we don't need right now, and may not ever need, so it's on hiatus until a use case materializes.\n */\nLocusZoom.Plot.prototype.positionPanels = function() {\n\n    var id;\n\n    // We want to enforce that all x-linked panels have consistent horizontal margins\n    // (to ensure that aligned items stay aligned despite inconsistent initial layout parameters)\n    // NOTE: This assumes panels have consistent widths already. That should probably be enforced too!\n    var x_linked_margins = { left: 0, right: 0 };\n\n    // Proportional heights for newly added panels default to null unless explicitly set, so determine appropriate\n    // proportional heights for all panels with a null value from discretely set dimensions.\n    // Likewise handle default nulls for proportional widths, but instead just force a value of 1 (full width)\n    for (id in this.panels) {\n        if (this.panels[id].layout.proportional_height === null) {\n            this.panels[id].layout.proportional_height = this.panels[id].layout.height / this.layout.height;\n        }\n        if (this.panels[id].layout.proportional_width === null) {\n            this.panels[id].layout.proportional_width = 1;\n        }\n        if (this.panels[id].layout.interaction.x_linked) {\n            x_linked_margins.left = Math.max(x_linked_margins.left, this.panels[id].layout.margin.left);\n            x_linked_margins.right = Math.max(x_linked_margins.right, this.panels[id].layout.margin.right);\n        }\n    }\n\n    // Sum the proportional heights and then adjust all proportionally so that the sum is exactly 1\n    var total_proportional_height = this.sumProportional('height');\n    if (!total_proportional_height) {\n        return this;\n    }\n    var proportional_adjustment = 1 / total_proportional_height;\n    for (id in this.panels) {\n        this.panels[id].layout.proportional_height *= proportional_adjustment;\n    }\n\n    // Update origins on all panels without changing plot-level dimensions yet\n    // Also apply x-linked margins to x-linked panels, updating widths as needed\n    var y_offset = 0;\n    this.panel_ids_by_y_index.forEach(function(panel_id) {\n        this.panels[panel_id].setOrigin(0, y_offset);\n        this.panels[panel_id].layout.proportional_origin.x = 0;\n        y_offset += this.panels[panel_id].layout.height;\n        if (this.panels[panel_id].layout.interaction.x_linked) {\n            var delta = Math.max(x_linked_margins.left - this.panels[panel_id].layout.margin.left, 0)\n                      + Math.max(x_linked_margins.right - this.panels[panel_id].layout.margin.right, 0);\n            this.panels[panel_id].layout.width += delta;\n            this.panels[panel_id].layout.margin.left = x_linked_margins.left;\n            this.panels[panel_id].layout.margin.right = x_linked_margins.right;\n            this.panels[panel_id].layout.cliparea.origin.x = x_linked_margins.left;\n        }\n    }.bind(this));\n    var calculated_plot_height = y_offset;\n    this.panel_ids_by_y_index.forEach(function(panel_id) {\n        this.panels[panel_id].layout.proportional_origin.y = this.panels[panel_id].layout.origin.y / calculated_plot_height;\n    }.bind(this));\n\n    // Update dimensions on the plot to accommodate repositioned panels\n    this.setDimensions();\n\n    // Set dimensions on all panels using newly set plot-level dimensions and panel-level proportional dimensions\n    this.panel_ids_by_y_index.forEach(function(panel_id) {\n        this.panels[panel_id].setDimensions(this.layout.width * this.panels[panel_id].layout.proportional_width,\n                                            this.layout.height * this.panels[panel_id].layout.proportional_height);\n    }.bind(this));\n\n    return this;\n\n};\n\n/**\n * Prepare the first rendering of the plot. This includes initializing the individual panels, but also creates shared\n *   elements such as mouse events, panel guides/boundaries, and loader/curtain.\n *\n * @returns {LocusZoom.Plot}\n */\nLocusZoom.Plot.prototype.initialize = function() {\n\n    // Ensure proper responsive class is present on the containing node if called for\n    if (this.layout.responsive_resize) {\n        d3.select(this.container).classed('lz-container-responsive', true);\n    }\n\n    // Create an element/layer for containing mouse guides\n    if (this.layout.mouse_guide) {\n        var mouse_guide_svg = this.svg.append('g')\n            .attr('class', 'lz-mouse_guide').attr('id', this.id + '.mouse_guide');\n        var mouse_guide_vertical_svg = mouse_guide_svg.append('rect')\n            .attr('class', 'lz-mouse_guide-vertical').attr('x',-1);\n        var mouse_guide_horizontal_svg = mouse_guide_svg.append('rect')\n            .attr('class', 'lz-mouse_guide-horizontal').attr('y',-1);\n        this.mouse_guide = {\n            svg: mouse_guide_svg,\n            vertical: mouse_guide_vertical_svg,\n            horizontal: mouse_guide_horizontal_svg\n        };\n    }\n\n    // Add curtain and loader prototpyes to the plot\n    this.curtain = LocusZoom.generateCurtain.call(this);\n    this.loader = LocusZoom.generateLoader.call(this);\n\n    // Create the panel_boundaries object with show/position/hide methods\n    this.panel_boundaries = {\n        parent: this,\n        hide_timeout: null,\n        showing: false,\n        dragging: false,\n        selectors: [],\n        corner_selector: null,\n        show: function() {\n            // Generate panel boundaries\n            if (!this.showing && !this.parent.curtain.showing) {\n                this.showing = true;\n                // Loop through all panels to create a horizontal boundary for each\n                this.parent.panel_ids_by_y_index.forEach(function(panel_id, panel_idx) {\n                    var selector = d3.select(this.parent.svg.node().parentNode).insert('div', '.lz-data_layer-tooltip')\n                        .attr('class', 'lz-panel-boundary')\n                        .attr('title', 'Resize panel');\n                    selector.append('span');\n                    var panel_resize_drag = d3.behavior.drag();\n                    panel_resize_drag.on('dragstart', function() { this.dragging = true; }.bind(this));\n                    panel_resize_drag.on('dragend', function() { this.dragging = false; }.bind(this));\n                    panel_resize_drag.on('drag', function() {\n                        // First set the dimensions on the panel we're resizing\n                        var this_panel = this.parent.panels[this.parent.panel_ids_by_y_index[panel_idx]];\n                        var original_panel_height = this_panel.layout.height;\n                        this_panel.setDimensions(this_panel.layout.width, this_panel.layout.height + d3.event.dy);\n                        var panel_height_change = this_panel.layout.height - original_panel_height;\n                        var new_calculated_plot_height = this.parent.layout.height + panel_height_change;\n                        // Next loop through all panels.\n                        // Update proportional dimensions for all panels including the one we've resized using discrete heights.\n                        // Reposition panels with a greater y-index than this panel to their appropriate new origin.\n                        this.parent.panel_ids_by_y_index.forEach(function(loop_panel_id, loop_panel_idx) {\n                            var loop_panel = this.parent.panels[this.parent.panel_ids_by_y_index[loop_panel_idx]];\n                            loop_panel.layout.proportional_height = loop_panel.layout.height / new_calculated_plot_height;\n                            if (loop_panel_idx > panel_idx) {\n                                loop_panel.setOrigin(loop_panel.layout.origin.x, loop_panel.layout.origin.y + panel_height_change);\n                                loop_panel.dashboard.position();\n                            }\n                        }.bind(this));\n                        // Reset dimensions on the entire plot and reposition panel boundaries\n                        this.parent.positionPanels();\n                        this.position();\n                    }.bind(this));\n                    selector.call(panel_resize_drag);\n                    this.parent.panel_boundaries.selectors.push(selector);\n                }.bind(this));\n                // Create a corner boundary / resize element on the bottom-most panel that resizes the entire plot\n                var corner_selector = d3.select(this.parent.svg.node().parentNode).insert('div', '.lz-data_layer-tooltip')\n                    .attr('class', 'lz-panel-corner-boundary')\n                    .attr('title', 'Resize plot');\n                corner_selector.append('span').attr('class', 'lz-panel-corner-boundary-outer');\n                corner_selector.append('span').attr('class', 'lz-panel-corner-boundary-inner');\n                var corner_drag = d3.behavior.drag();\n                corner_drag.on('dragstart', function() { this.dragging = true; }.bind(this));\n                corner_drag.on('dragend', function() { this.dragging = false; }.bind(this));\n                corner_drag.on('drag', function() {\n                    this.setDimensions(this.layout.width + d3.event.dx, this.layout.height + d3.event.dy);\n                }.bind(this.parent));\n                corner_selector.call(corner_drag);\n                this.parent.panel_boundaries.corner_selector = corner_selector;\n            }\n            return this.position();\n        },\n        position: function() {\n            if (!this.showing) { return this; }\n            // Position panel boundaries\n            var plot_page_origin = this.parent.getPageOrigin();\n            this.selectors.forEach(function(selector, panel_idx) {\n                var panel_page_origin = this.parent.panels[this.parent.panel_ids_by_y_index[panel_idx]].getPageOrigin();\n                var left = plot_page_origin.x;\n                var top = panel_page_origin.y + this.parent.panels[this.parent.panel_ids_by_y_index[panel_idx]].layout.height - 12;\n                var width = this.parent.layout.width - 1;\n                selector.style({\n                    top: top + 'px',\n                    left: left + 'px',\n                    width: width + 'px'\n                });\n                selector.select('span').style({\n                    width: width + 'px'\n                });\n            }.bind(this));\n            // Position corner selector\n            var corner_padding = 10;\n            var corner_size = 16;\n            this.corner_selector.style({\n                top: (plot_page_origin.y + this.parent.layout.height - corner_padding - corner_size) + 'px',\n                left: (plot_page_origin.x + this.parent.layout.width - corner_padding - corner_size) + 'px'\n            });\n            return this;\n        },\n        hide: function() {\n            if (!this.showing) { return this; }\n            this.showing = false;\n            // Remove panel boundaries\n            this.selectors.forEach(function(selector) { selector.remove(); });\n            this.selectors = [];\n            // Remove corner boundary\n            this.corner_selector.remove();\n            this.corner_selector = null;\n            return this;\n        }\n    };\n\n    // Show panel boundaries stipulated by the layout (basic toggle, only show on mouse over plot)\n    if (this.layout.panel_boundaries) {\n        d3.select(this.svg.node().parentNode).on('mouseover.' + this.id + '.panel_boundaries', function() {\n            clearTimeout(this.panel_boundaries.hide_timeout);\n            this.panel_boundaries.show();\n        }.bind(this));\n        d3.select(this.svg.node().parentNode).on('mouseout.' + this.id + '.panel_boundaries', function() {\n            this.panel_boundaries.hide_timeout = setTimeout(function() {\n                this.panel_boundaries.hide();\n            }.bind(this), 300);\n        }.bind(this));\n    }\n\n    // Create the dashboard object and immediately show it\n    this.dashboard = new LocusZoom.Dashboard(this).show();\n\n    // Initialize all panels\n    for (var id in this.panels) {\n        this.panels[id].initialize();\n    }\n\n    // Define plot-level mouse events\n    var namespace = '.' + this.id;\n    if (this.layout.mouse_guide) {\n        var mouseout_mouse_guide = function() {\n            this.mouse_guide.vertical.attr('x', -1);\n            this.mouse_guide.horizontal.attr('y', -1);\n        }.bind(this);\n        var mousemove_mouse_guide = function() {\n            var coords = d3.mouse(this.svg.node());\n            this.mouse_guide.vertical.attr('x', coords[0]);\n            this.mouse_guide.horizontal.attr('y', coords[1]);\n        }.bind(this);\n        this.svg\n            .on('mouseout' + namespace + '-mouse_guide', mouseout_mouse_guide)\n            .on('touchleave' + namespace + '-mouse_guide', mouseout_mouse_guide)\n            .on('mousemove' + namespace + '-mouse_guide', mousemove_mouse_guide);\n    }\n    var mouseup = function() {\n        this.stopDrag();\n    }.bind(this);\n    var mousemove = function() {\n        if (this.interaction.dragging) {\n            var coords = d3.mouse(this.svg.node());\n            if (d3.event) { d3.event.preventDefault(); }\n            this.interaction.dragging.dragged_x = coords[0] - this.interaction.dragging.start_x;\n            this.interaction.dragging.dragged_y = coords[1] - this.interaction.dragging.start_y;\n            this.panels[this.interaction.panel_id].render();\n            this.interaction.linked_panel_ids.forEach(function(panel_id) {\n                this.panels[panel_id].render();\n            }.bind(this));\n        }\n    }.bind(this);\n    this.svg\n        .on('mouseup' + namespace, mouseup)\n        .on('touchend' + namespace, mouseup)\n        .on('mousemove' + namespace, mousemove)\n        .on('touchmove' + namespace, mousemove);\n\n    // Add an extra namespaced mouseup handler to the containing body, if there is one\n    // This helps to stop interaction events gracefully when dragging outside of the plot element\n    if (!d3.select('body').empty()) {\n        d3.select('body')\n            .on('mouseup' + namespace, mouseup)\n            .on('touchend' + namespace, mouseup);\n    }\n\n    this.on('match_requested', function(eventData) {\n        // Layers can broadcast that a specific point has been selected, and the plot will tell every other layer\n        //  to look for that value. Whenever a point is de-selected, it clears the match.\n        var data = eventData.data;\n        var to_send = (data.active ? data.value : null);\n        this.applyState({ lz_match_value: to_send });\n    }.bind(this));\n\n    this.initialized = true;\n\n    // An extra call to setDimensions with existing discrete dimensions fixes some rounding errors with tooltip\n    // positioning. TODO: make this additional call unnecessary.\n    var client_rect = this.svg.node().getBoundingClientRect();\n    var width = client_rect.width ? client_rect.width : this.layout.width;\n    var height = client_rect.height ? client_rect.height : this.layout.height;\n    this.setDimensions(width, height);\n\n    return this;\n\n};\n\n/**\n * Refresh (or fetch) a plot's data from sources, regardless of whether position or state has changed\n * @returns {Promise}\n */\nLocusZoom.Plot.prototype.refresh = function() {\n    return this.applyState();\n};\n\n\n/**\n * A user-defined callback function that can receive (and potentially act on) new plot data.\n * @callback externalDataCallback\n * @param {Object} new_data The body resulting from a data request. This represents the same information that would be passed to\n *  a data layer making an equivalent request.\n */\n\n/**\n * A user-defined callback function that can respond to errors received during a previous operation\n * @callback externalErrorCallback\n * @param err A representation of the error that occurred\n */\n\n/**\n * Allow newly fetched data to be made available outside the LocusZoom plot. For example, a callback could be\n *  registered to draw an HTML table of top GWAS hits, and update that table whenever the plot region changes.\n *\n * This is a convenience method for external hooks. It registers an event listener and returns parsed data,\n *  using the same fields syntax and underlying methods as data layers.\n *\n * @param {String[]} fields An array of field names and transforms, in the same syntax used by a data layer.\n *  Different data sources should be prefixed by the source name.\n * @param {externalDataCallback} success_callback Used defined function that is automatically called any time that\n *  new data is received by the plot.\n * @param {Object} [opts] Options\n * @param {externalErrorCallback} [opts.onerror] User defined function that is automatically called if a problem\n *  occurs during the data request or subsequent callback operations\n * @param {boolean} [opts.discrete=false] Normally the callback will subscribe to the combined body from the chain,\n *  which may not be in a format that matches what the external callback wants to do. If discrete=true, returns the\n *  uncombined record info\n *  @return {function} The newly created event listener, to allow for later cleanup/removal\n */\nLocusZoom.Plot.prototype.subscribeToData = function(fields, success_callback, opts) {\n    opts = opts || {};\n\n    // Register an event listener that is notified whenever new data has been rendered\n    var error_callback = opts.onerror || function(err) {\n        console.log('An error occurred while acting on an external callback', err);\n    };\n    var self = this;\n\n    var listener = function() {\n        try {\n            self.lzd.getData(self.state, fields)\n                .then(function (new_data) {\n                    success_callback(opts.discrete ? new_data.discrete : new_data.body);\n                }).catch(error_callback);\n        } catch (error) {\n            // In certain cases, errors are thrown before a promise can be generated, and LZ error display seems to rely on these errors bubbling up\n            error_callback(error);\n        }\n    };\n    this.on('data_rendered', listener);\n    return listener;\n};\n\n/**\n * Update state values and trigger a pull for fresh data on all data sources for all data layers\n * @param state_changes\n * @returns {Promise} A promise that resolves when all data fetch and update operations are complete\n */\nLocusZoom.Plot.prototype.applyState = function(state_changes) {\n    state_changes = state_changes || {};\n    if (typeof state_changes != 'object') {\n        throw new Error('LocusZoom.applyState only accepts an object; ' + (typeof state_changes) + ' given');\n    }\n\n    // First make a copy of the current (old) state to work with\n    var new_state = JSON.parse(JSON.stringify(this.state));\n\n    // Apply changes by top-level property to the new state\n    for (var property in state_changes) {\n        new_state[property] = state_changes[property];\n    }\n\n    // Validate the new state (may do nothing, may do a lot, depends on how the user has things set up)\n    new_state = LocusZoom.validateState(new_state, this.layout);\n\n    // Apply new state to the actual state\n    for (property in new_state) {\n        this.state[property] = new_state[property];\n    }\n\n    // Generate requests for all panels given new state\n    this.emit('data_requested');\n    this.remap_promises = [];\n    this.loading_data = true;\n    for (var id in this.panels) {\n        this.remap_promises.push(this.panels[id].reMap());\n    }\n\n    return Promise.all(this.remap_promises)\n        .catch(function(error) {\n            console.error(error);\n            this.curtain.show(error.message || error);\n            this.loading_data = false;\n        }.bind(this))\n        .then(function() {\n            // Update dashboard / components\n            this.dashboard.update();\n\n            // Apply panel-level state values\n            this.panel_ids_by_y_index.forEach(function(panel_id) {\n                var panel = this.panels[panel_id];\n                panel.dashboard.update();\n                // Apply data-layer-level state values\n                panel.data_layer_ids_by_z_index.forEach(function(data_layer_id) {\n                    var data_layer = this.data_layers[data_layer_id];\n                    var state_id = panel_id + '.' + data_layer_id;\n                    for (var property in this.state[state_id]) {\n                        if (!this.state[state_id].hasOwnProperty(property)) { continue; }\n                        if (Array.isArray(this.state[state_id][property])) {\n                            this.state[state_id][property].forEach(function(element_id) {\n                                try {\n                                    this.setElementStatus(property, this.getElementById(element_id), true);\n                                } catch (e) {\n                                    console.warn('Unable to apply state: ' + state_id + ', ' + property);\n                                    console.error(e);\n                                }\n                            }.bind(data_layer));\n                        }\n                    }\n                }.bind(panel));\n            }.bind(this));\n\n            // Emit events\n            this.emit('layout_changed');\n            this.emit('data_rendered');\n            this.emit('state_changed', state_changes);\n\n            this.loading_data = false;\n\n        }.bind(this));\n};\n\n/**\n * Register interactions along the specified axis, provided that the target panel allows interaction.\n *\n * @param {LocusZoom.Panel} panel\n * @param {('x_tick'|'y1_tick'|'y2_tick')} method The direction (axis) along which dragging is being performed.\n * @returns {LocusZoom.Plot}\n */\nLocusZoom.Plot.prototype.startDrag = function(panel, method) {\n\n    panel = panel || null;\n    method = method || null;\n\n    var axis = null;\n    switch (method) {\n    case 'background':\n    case 'x_tick':\n        axis = 'x';\n        break;\n    case 'y1_tick':\n        axis = 'y1';\n        break;\n    case 'y2_tick':\n        axis = 'y2';\n        break;\n    }\n\n    if (!(panel instanceof LocusZoom.Panel) || !axis || !this.canInteract()) { return this.stopDrag(); }\n\n    var coords = d3.mouse(this.svg.node());\n    this.interaction = {\n        panel_id: panel.id,\n        linked_panel_ids: panel.getLinkedPanelIds(axis),\n        dragging: {\n            method: method,\n            start_x: coords[0],\n            start_y: coords[1],\n            dragged_x: 0,\n            dragged_y: 0,\n            axis: axis\n        }\n    };\n\n    this.svg.style('cursor', 'all-scroll');\n\n    return this;\n\n};\n\n/**\n * Process drag interactions across the target panel and synchronize plot state across other panels in sync;\n *   clear the event when complete\n * @returns {LocusZoom.Plot}\n */\nLocusZoom.Plot.prototype.stopDrag = function() {\n\n    if (!this.interaction.dragging) { return this; }\n\n    if (typeof this.panels[this.interaction.panel_id] != 'object') {\n        this.interaction = {};\n        return this;\n    }\n    var panel = this.panels[this.interaction.panel_id];\n\n    // Helper function to find the appropriate axis layouts on child data layers\n    // Once found, apply the extent as floor/ceiling and remove all other directives\n    // This forces all associated axes to conform to the extent generated by a drag action\n    var overrideAxisLayout = function(axis, axis_number, extent) {\n        panel.data_layer_ids_by_z_index.forEach(function(id) {\n            if (panel.data_layers[id].layout[axis + '_axis'].axis === axis_number) {\n                panel.data_layers[id].layout[axis + '_axis'].floor = extent[0];\n                panel.data_layers[id].layout[axis + '_axis'].ceiling = extent[1];\n                delete panel.data_layers[id].layout[axis + '_axis'].lower_buffer;\n                delete panel.data_layers[id].layout[axis + '_axis'].upper_buffer;\n                delete panel.data_layers[id].layout[axis + '_axis'].min_extent;\n                delete panel.data_layers[id].layout[axis + '_axis'].ticks;\n            }\n        });\n    };\n\n    switch(this.interaction.dragging.method) {\n    case 'background':\n    case 'x_tick':\n        if (this.interaction.dragging.dragged_x !== 0) {\n            overrideAxisLayout('x', 1, panel.x_extent);\n            this.applyState({ start: panel.x_extent[0], end: panel.x_extent[1] });\n        }\n        break;\n    case 'y1_tick':\n    case 'y2_tick':\n        if (this.interaction.dragging.dragged_y !== 0) {\n            // TODO: Hardcoded assumption of only two possible axes with single-digit #s (switch/case)\n            var y_axis_number = parseInt(this.interaction.dragging.method[1]);\n            overrideAxisLayout('y', y_axis_number, panel['y' + y_axis_number + '_extent']);\n        }\n        break;\n    }\n\n    this.interaction = {};\n    this.svg.style('cursor', null);\n\n    return this;\n\n};\n","/* global LocusZoom */\n'use strict';\n\n/**\n * A panel is an abstract class representing a subdivision of the LocusZoom stage\n *   to display a distinct data representation as a collection of data layers.\n * @class\n * @param {Object} layout\n * @param {LocusZoom.Plot|null} parent\n*/\nLocusZoom.Panel = function(layout, parent) {\n\n    if (typeof layout !== 'object') {\n        throw new Error('Unable to create panel, invalid layout');\n    }\n\n    /** @member {LocusZoom.Plot|null} */\n    this.parent = parent || null;\n    /** @member {LocusZoom.Plot|null} */\n    this.parent_plot = parent;\n\n    // Ensure a valid ID is present. If there is no valid ID then generate one\n    if (typeof layout.id !== 'string' || !layout.id.length) {\n        if (!this.parent) {\n            layout.id = 'p' + Math.floor(Math.random() * Math.pow(10,8));\n        } else {\n            var id = null;\n            var generateID = function() {\n                id = 'p' + Math.floor(Math.random() * Math.pow(10,8));\n                if (id == null || typeof this.parent.panels[id] != 'undefined') {\n                    id = generateID();\n                }\n            }.bind(this);\n            layout.id = id;\n        }\n    } else if (this.parent) {\n        if (typeof this.parent.panels[layout.id] !== 'undefined') {\n            throw new Error('Cannot create panel with id [' + layout.id + ']; panel with that id already exists');\n        }\n    }\n    /** @member {String} */\n    this.id = layout.id;\n\n    /** @member {Boolean} */\n    this.initialized = false;\n    /**\n     * The index of this panel in the parent plot's `layout.panels`\n     * @member {number}\n     * */\n    this.layout_idx = null;\n    /** @member {Object} */\n    this.svg = {};\n\n    /**\n     * A JSON-serializable object used to describe the composition of the Panel\n     * @member {Object}\n     */\n    this.layout = LocusZoom.Layouts.merge(layout || {}, LocusZoom.Panel.DefaultLayout);\n\n    // Define state parameters specific to this panel\n    if (this.parent) {\n        /** @member {Object} */\n        this.state = this.parent.state;\n\n        /** @member {String} */\n        this.state_id = this.id;\n        this.state[this.state_id] = this.state[this.state_id] || {};\n    } else {\n        this.state = null;\n        this.state_id = null;\n    }\n\n    /** @member {Object} */\n    this.data_layers = {};\n    /** @member {String[]} */\n    this.data_layer_ids_by_z_index = [];\n\n    /** @protected */\n    this.applyDataLayerZIndexesToDataLayerLayouts = function() {\n        this.data_layer_ids_by_z_index.forEach(function(dlid, idx) {\n            this.data_layers[dlid].layout.z_index = idx;\n        }.bind(this));\n    }.bind(this);\n\n    /**\n     * Track data requests in progress\n     * @member {Promise[]}\n     *  @protected\n     */\n    this.data_promises = [];\n\n    /** @member {d3.scale} */\n    this.x_scale  = null;\n    /** @member {d3.scale} */\n    this.y1_scale = null;\n    /** @member {d3.scale} */\n    this.y2_scale = null;\n\n    /** @member {d3.extent} */\n    this.x_extent  = null;\n    /** @member {d3.extent} */\n    this.y1_extent = null;\n    /** @member {d3.extent} */\n    this.y2_extent = null;\n\n    /** @member {Number[]} */\n    this.x_ticks  = [];\n    /** @member {Number[]} */\n    this.y1_ticks = [];\n    /** @member {Number[]} */\n    this.y2_ticks = [];\n\n    /**\n     * A timeout ID as returned by setTimeout\n     * @protected\n     * @member {number}\n     */\n    this.zoom_timeout = null;\n\n    /** @returns {string} */\n    this.getBaseId = function() {\n        return this.parent.id + '.' + this.id;\n    };\n\n    /**\n     * Known event hooks that the panel can respond to\n     * @protected\n     * @member {Object}\n     */\n    this.event_hooks = {\n        'layout_changed': [],\n        'data_requested': [],\n        'data_rendered': [],\n        'element_clicked': [],\n        'element_selection': [],\n        'match_requested': [] // A data layer is attempting to highlight matching points (internal use only)\n    };\n\n    /**\n     * There are several events that a LocusZoom panel can \"emit\" when appropriate, and LocusZoom supports registering\n     *   \"hooks\" for these events which are essentially custom functions intended to fire at certain times.\n     *\n     * The following panel-level events are currently supported:\n     *   - `layout_changed` - context: panel - Any aspect of the panel's layout (including dimensions or state) has changed.\n     *   - `data_requested` - context: panel - A request for new data from any data source used in the panel has been made.\n     *   - `data_rendered` - context: panel - Data from a request has been received and rendered in the panel.\n     *   - `element_clicked` - context: panel - A data element in any of the panel's data layers has been clicked.\n     *   - `element_selection` - context: panel - Triggered when an element changes \"selection\" status, and identifies\n     *        whether the element is being selected or deselected.\n     *\n     * To register a hook for any of these events use `panel.on('event_name', function() {})`.\n     *\n     * There can be arbitrarily many functions registered to the same event. They will be executed in the order they\n     *   were registered. The this context bound to each event hook function is dependent on the type of event, as\n     *   denoted above. For example, when data_requested is emitted the context for this in the event hook will be the\n     *   panel itself, but when element_clicked is emitted the context for this in the event hook will be the element\n     *   that was clicked.\n     *\n     * @param {String} event The name of the event (as defined in `event_hooks`)\n     * @param {function} hook\n     * @returns {function} The registered event listener\n     */\n    this.on = function(event, hook) {\n        // TODO: Dry plot and panel event code into a shared mixin\n        if (typeof 'event' != 'string' || !Array.isArray(this.event_hooks[event])) {\n            throw new Error('Unable to register event hook, invalid event: ' + event.toString());\n        }\n        if (typeof hook != 'function') {\n            throw new Error('Unable to register event hook, invalid hook function passed');\n        }\n        this.event_hooks[event].push(hook);\n        return hook;\n    };\n    /**\n     * Remove one or more previously defined event listeners\n     * @param {String} event The name of an event (as defined in `event_hooks`)\n     * @param {eventCallback} [hook] The callback to deregister\n     * @returns {LocusZoom.Panel}\n     */\n    this.off = function(event, hook) {\n        var theseHooks = this.event_hooks[event];\n        if (typeof 'event' != 'string' || !Array.isArray(theseHooks)) {\n            throw new Error('Unable to remove event hook, invalid event: ' + event.toString());\n        }\n        if (hook === undefined) {\n            // Deregistering all hooks for this event may break basic functionality, and should only be used during\n            //  cleanup operations (eg to prevent memory leaks)\n            this.event_hooks[event] = [];\n        } else {\n            var hookMatch = theseHooks.indexOf(hook);\n            if (hookMatch !== -1) {\n                theseHooks.splice(hookMatch, 1);\n            } else {\n                throw new Error('The specified event listener is not registered and therefore cannot be removed');\n            }\n        }\n        return this;\n    };\n    /**\n     * Handle running of event hooks when an event is emitted\n     *\n     * There is a shorter overloaded form of this method: if the event does not have any data, the second\n     *   argument can be a boolean to control bubbling\n     *\n     * @param {string} event A known event name\n     * @param {*} [eventData] Data or event description that will be passed to the event listener\n     * @param {boolean} [bubble=false] Whether to bubble the event to the parent\n     * @returns {LocusZoom.Panel}\n     */\n    this.emit = function(event, eventData, bubble)  {\n        bubble = bubble || false;\n\n        // TODO: DRY this with the parent plot implementation. Ensure interfaces remain compatible.\n        // TODO: Improve documentation for overloaded method signature (JSDoc may have trouble here)\n        if (typeof 'event' != 'string' || !Array.isArray(this.event_hooks[event])) {\n            throw new Error('LocusZoom attempted to throw an invalid event: ' + event.toString());\n        }\n        if (typeof eventData === 'boolean' && arguments.length === 2) {\n            // Overloaded method signature: emit(event, bubble)\n            bubble = eventData;\n            eventData = null;\n        }\n        var sourceID = this.getBaseId();\n        var self = this;\n        var eventContext = {sourceID: sourceID, data: eventData || null};\n        this.event_hooks[event].forEach(function(hookToRun) {\n            // By default, any handlers fired here will see the panel as the value of `this`. If a bound function is\n            // registered as a handler, the previously bound `this` will override anything provided to `call` below.\n            hookToRun.call(self, eventContext);\n        });\n        if (bubble && this.parent) {\n            this.parent.emit(event, eventContext);\n        }\n        return this;\n    };\n\n    /**\n     * Get an object with the x and y coordinates of the panel's origin in terms of the entire page\n     * Necessary for positioning any HTML elements over the panel\n     * @returns {{x: Number, y: Number}}\n     */\n    this.getPageOrigin = function() {\n        var plot_origin = this.parent.getPageOrigin();\n        return {\n            x: plot_origin.x + this.layout.origin.x,\n            y: plot_origin.y + this.layout.origin.y\n        };\n    };\n\n    // Initialize the layout\n    this.initializeLayout();\n\n    return this;\n\n};\n\n/**\n * Default panel layout\n * @static\n * @type {Object}\n */\nLocusZoom.Panel.DefaultLayout = {\n    title: { text: '', style: {}, x: 10, y: 22 },\n    y_index: null,\n    width:  0,\n    height: 0,\n    origin: { x: 0, y: null },\n    min_width: 1,\n    min_height: 1,\n    proportional_width: null,\n    proportional_height: null,\n    proportional_origin: { x: 0, y: null },\n    margin: { top: 0, right: 0, bottom: 0, left: 0 },\n    background_click: 'clear_selections',\n    dashboard: {\n        components: []\n    },\n    cliparea: {\n        height: 0,\n        width: 0,\n        origin: { x: 0, y: 0 }\n    },\n    axes: {  // These are the only axes supported!!\n        x:  {},\n        y1: {},\n        y2: {}\n    },\n    legend: null,\n    interaction: {\n        drag_background_to_pan: false,\n        drag_x_ticks_to_scale: false,\n        drag_y1_ticks_to_scale: false,\n        drag_y2_ticks_to_scale: false,\n        scroll_to_zoom: false,\n        x_linked: false,\n        y1_linked: false,\n        y2_linked: false\n    },\n    data_layers: []\n};\n\n/**\n * Prepare the panel for first use by performing parameter validation, creating axes, setting default dimensions,\n *   and preparing / positioning data layers as appropriate.\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Panel.prototype.initializeLayout = function() {\n\n    // If the layout is missing BOTH width and proportional width then set the proportional width to 1.\n    // This will default the panel to taking up the full width of the plot.\n    if (this.layout.width === 0 && this.layout.proportional_width === null) {\n        this.layout.proportional_width = 1;\n    }\n\n    // If the layout is missing BOTH height and proportional height then set the proportional height to\n    // an equal share of the plot's current height.\n    if (this.layout.height === 0 && this.layout.proportional_height === null) {\n        var panel_count = Object.keys(this.parent.panels).length;\n        if (panel_count > 0) {\n            this.layout.proportional_height = (1 / panel_count);\n        } else {\n            this.layout.proportional_height = 1;\n        }\n    }\n\n    // Set panel dimensions, origin, and margin\n    this.setDimensions();\n    this.setOrigin();\n    this.setMargin();\n\n    // Set ranges\n    // TODO: Define stub values in constructor\n    this.x_range = [0, this.layout.cliparea.width];\n    this.y1_range = [this.layout.cliparea.height, 0];\n    this.y2_range = [this.layout.cliparea.height, 0];\n\n    // Initialize panel axes\n    ['x', 'y1', 'y2'].forEach(function(axis) {\n        if (!Object.keys(this.layout.axes[axis]).length || this.layout.axes[axis].render === false) {\n            // The default layout sets the axis to an empty object, so set its render boolean here\n            this.layout.axes[axis].render = false;\n        } else {\n            this.layout.axes[axis].render = true;\n            this.layout.axes[axis].label = this.layout.axes[axis].label || null;\n            this.layout.axes[axis].label_function = this.layout.axes[axis].label_function || null;\n        }\n    }.bind(this));\n\n    // Add data layers (which define x and y extents)\n    this.layout.data_layers.forEach(function(data_layer_layout) {\n        this.addDataLayer(data_layer_layout);\n    }.bind(this));\n\n    return this;\n\n};\n\n/**\n * Set the dimensions for the panel. If passed with no arguments will calculate optimal size based on layout\n *   directives and the available area within the plot. If passed discrete width (number) and height (number) will\n *   attempt to resize the panel to them, but may be limited by minimum dimensions defined on the plot or panel.\n *\n * @public\n * @param {number} [width]\n * @param {number} [height]\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Panel.prototype.setDimensions = function(width, height) {\n    if (typeof width != 'undefined' && typeof height != 'undefined') {\n        if (!isNaN(width) && width >= 0 && !isNaN(height) && height >= 0) {\n            this.layout.width = Math.max(Math.round(+width), this.layout.min_width);\n            this.layout.height = Math.max(Math.round(+height), this.layout.min_height);\n        }\n    } else {\n        if (this.layout.proportional_width !== null) {\n            this.layout.width = Math.max(this.layout.proportional_width * this.parent.layout.width, this.layout.min_width);\n        }\n        if (this.layout.proportional_height !== null) {\n            this.layout.height = Math.max(this.layout.proportional_height * this.parent.layout.height, this.layout.min_height);\n        }\n    }\n    this.layout.cliparea.width = Math.max(this.layout.width - (this.layout.margin.left + this.layout.margin.right), 0);\n    this.layout.cliparea.height = Math.max(this.layout.height - (this.layout.margin.top + this.layout.margin.bottom), 0);\n    if (this.svg.clipRect) {\n        this.svg.clipRect.attr('width', this.layout.width).attr('height', this.layout.height);\n    }\n    if (this.initialized) {\n        this.render();\n        this.curtain.update();\n        this.loader.update();\n        this.dashboard.update();\n        if (this.legend) { this.legend.position(); }\n    }\n    return this;\n};\n\n/**\n * Set panel origin on the plot, and re-render as appropriate\n *\n * @public\n * @param {number} x\n * @param {number} y\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Panel.prototype.setOrigin = function(x, y) {\n    if (!isNaN(x) && x >= 0) { this.layout.origin.x = Math.max(Math.round(+x), 0); }\n    if (!isNaN(y) && y >= 0) { this.layout.origin.y = Math.max(Math.round(+y), 0); }\n    if (this.initialized) { this.render(); }\n    return this;\n};\n\n/**\n * Set margins around this panel\n * @public\n * @param {number} top\n * @param {number} right\n * @param {number} bottom\n * @param {number} left\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Panel.prototype.setMargin = function(top, right, bottom, left) {\n    var extra;\n    if (!isNaN(top)    && top    >= 0) { this.layout.margin.top    = Math.max(Math.round(+top),    0); }\n    if (!isNaN(right)  && right  >= 0) { this.layout.margin.right  = Math.max(Math.round(+right),  0); }\n    if (!isNaN(bottom) && bottom >= 0) { this.layout.margin.bottom = Math.max(Math.round(+bottom), 0); }\n    if (!isNaN(left)   && left   >= 0) { this.layout.margin.left   = Math.max(Math.round(+left),   0); }\n    if (this.layout.margin.top + this.layout.margin.bottom > this.layout.height) {\n        extra = Math.floor(((this.layout.margin.top + this.layout.margin.bottom) - this.layout.height) / 2);\n        this.layout.margin.top -= extra;\n        this.layout.margin.bottom -= extra;\n    }\n    if (this.layout.margin.left + this.layout.margin.right > this.layout.width) {\n        extra = Math.floor(((this.layout.margin.left + this.layout.margin.right) - this.layout.width) / 2);\n        this.layout.margin.left -= extra;\n        this.layout.margin.right -= extra;\n    }\n    ['top', 'right', 'bottom', 'left'].forEach(function(m) {\n        this.layout.margin[m] = Math.max(this.layout.margin[m], 0);\n    }.bind(this));\n    this.layout.cliparea.width = Math.max(this.layout.width - (this.layout.margin.left + this.layout.margin.right), 0);\n    this.layout.cliparea.height = Math.max(this.layout.height - (this.layout.margin.top + this.layout.margin.bottom), 0);\n    this.layout.cliparea.origin.x = this.layout.margin.left;\n    this.layout.cliparea.origin.y = this.layout.margin.top;\n\n    if (this.initialized) { this.render(); }\n    return this;\n};\n\n/**\n * Set the title for the panel. If passed an object, will merge the object with the existing layout configuration, so\n *   that all or only some of the title layout object's parameters can be customized. If passed null, false, or an empty\n *   string, the title DOM element will be set to display: none.\n *\n * @param {string|object|null} title The title text, or an object with additional configuration\n * @param {string} title.text Text to display. Since titles are rendered as SVG text, HTML and newlines will not be rendered.\n * @param {number} title.x X-offset, in pixels, for the title's text anchor (default left) relative to the top-left corner of the panel.\n * @param {number} title.y Y-offset, in pixels, for the title's text anchor (default left) relative to the top-left corner of the panel.\n    NOTE: SVG y values go from the top down, so the SVG origin of (0,0) is in the top left corner.\n * @param {object} title.style CSS styles object to be applied to the title's DOM element.\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Panel.prototype.setTitle = function(title) {\n    if (typeof this.layout.title == 'string') {\n        var text = this.layout.title;\n        this.layout.title = { text: text, x: 0, y: 0, style: {} };\n    }\n    if (typeof title == 'string') {\n        this.layout.title.text = title;\n    } else if (typeof title == 'object' && title !== null) {\n        this.layout.title = LocusZoom.Layouts.merge(title, this.layout.title);\n    }\n    if (this.layout.title.text.length) {\n        this.title.attr('display', null)\n            .attr('x', parseFloat(this.layout.title.x))\n            .attr('y', parseFloat(this.layout.title.y))\n            .style(this.layout.title.style)\n            .text(this.layout.title.text);\n    } else {\n        this.title.attr('display', 'none');\n    }\n    return this;\n};\n\n\n/**\n * Prepare the first rendering of the panel. This includes drawing the individual data layers, but also creates shared\n *   elements such as axes,  title, and loader/curtain.\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Panel.prototype.initialize = function() {\n\n    // Append a container group element to house the main panel group element and the clip path\n    // Position with initial layout parameters\n    this.svg.container = this.parent.svg.append('g')\n        .attr('id', this.getBaseId() + '.panel_container')\n        .attr('transform', 'translate(' + (this.layout.origin.x || 0) + ',' + (this.layout.origin.y || 0) + ')');\n\n    // Append clip path to the parent svg element, size with initial layout parameters\n    var clipPath = this.svg.container.append('clipPath')\n        .attr('id', this.getBaseId() + '.clip');\n    this.svg.clipRect = clipPath.append('rect')\n        .attr('width', this.layout.width).attr('height', this.layout.height);\n\n    // Append svg group for rendering all panel child elements, clipped by the clip path\n    this.svg.group = this.svg.container.append('g')\n        .attr('id', this.getBaseId() + '.panel')\n        .attr('clip-path', 'url(#' + this.getBaseId() + '.clip)');\n\n    // Add curtain and loader prototypes to the panel\n    /** @member {Object} */\n    this.curtain = LocusZoom.generateCurtain.call(this);\n    /** @member {Object} */\n    this.loader = LocusZoom.generateLoader.call(this);\n\n    /**\n     * Create the dashboard object and hang components on it as defined by panel layout\n     * @member {LocusZoom.Dashboard}\n     */\n    this.dashboard = new LocusZoom.Dashboard(this);\n\n    // Inner border\n    this.inner_border = this.svg.group.append('rect')\n        .attr('class', 'lz-panel-background')\n        .on('click', function() {\n            if (this.layout.background_click === 'clear_selections') { this.clearSelections(); }\n        }.bind(this));\n\n    // Add the title\n    /** @member {Element} */\n    this.title = this.svg.group.append('text').attr('class', 'lz-panel-title');\n    if (typeof this.layout.title != 'undefined') { this.setTitle(); }\n\n    // Initialize Axes\n    this.svg.x_axis = this.svg.group.append('g')\n        .attr('id', this.getBaseId() + '.x_axis').attr('class', 'lz-x lz-axis');\n    if (this.layout.axes.x.render) {\n        this.svg.x_axis_label = this.svg.x_axis.append('text')\n            .attr('class', 'lz-x lz-axis lz-label')\n            .attr('text-anchor', 'middle');\n    }\n    this.svg.y1_axis = this.svg.group.append('g')\n        .attr('id', this.getBaseId() + '.y1_axis').attr('class', 'lz-y lz-y1 lz-axis');\n    if (this.layout.axes.y1.render) {\n        this.svg.y1_axis_label = this.svg.y1_axis.append('text')\n            .attr('class', 'lz-y1 lz-axis lz-label')\n            .attr('text-anchor', 'middle');\n    }\n    this.svg.y2_axis = this.svg.group.append('g')\n        .attr('id', this.getBaseId() + '.y2_axis').attr('class', 'lz-y lz-y2 lz-axis');\n    if (this.layout.axes.y2.render) {\n        this.svg.y2_axis_label = this.svg.y2_axis.append('text')\n            .attr('class', 'lz-y2 lz-axis lz-label')\n            .attr('text-anchor', 'middle');\n    }\n\n    // Initialize child Data Layers\n    this.data_layer_ids_by_z_index.forEach(function(id) {\n        this.data_layers[id].initialize();\n    }.bind(this));\n\n    /**\n     * Legend object, as defined by panel layout and child data layer layouts\n     * @member {LocusZoom.Legend}\n     * */\n    this.legend = null;\n    if (this.layout.legend) {\n        this.legend = new LocusZoom.Legend(this);\n    }\n\n    // Establish panel background drag interaction mousedown event handler (on the panel background)\n    if (this.layout.interaction.drag_background_to_pan) {\n        var namespace = '.' + this.parent.id + '.' + this.id + '.interaction.drag';\n        var mousedown = function() {\n            this.parent.startDrag(this, 'background');\n        }.bind(this);\n        this.svg.container.select('.lz-panel-background')\n            .on('mousedown' + namespace + '.background', mousedown)\n            .on('touchstart' + namespace + '.background', mousedown);\n    }\n\n    return this;\n\n};\n\n/**\n * Refresh the sort order of all data layers (called by data layer moveUp and moveDown methods)\n */\nLocusZoom.Panel.prototype.resortDataLayers = function() {\n    var sort = [];\n    this.data_layer_ids_by_z_index.forEach(function(id) {\n        sort.push(this.data_layers[id].layout.z_index);\n    }.bind(this));\n    this.svg.group.selectAll('g.lz-data_layer-container').data(sort).sort(d3.ascending);\n    this.applyDataLayerZIndexesToDataLayerLayouts();\n};\n\n/**\n * Get an array of panel IDs that are axis-linked to this panel\n * @param {('x'|'y1'|'y2')} axis\n * @returns {Array}\n */\nLocusZoom.Panel.prototype.getLinkedPanelIds = function(axis) {\n    axis = axis || null;\n    var linked_panel_ids = [];\n    if (['x','y1','y2'].indexOf(axis) === -1) { return linked_panel_ids; }\n    if (!this.layout.interaction[axis + '_linked']) { return linked_panel_ids; }\n    this.parent.panel_ids_by_y_index.forEach(function(panel_id) {\n        if (panel_id !== this.id && this.parent.panels[panel_id].layout.interaction[axis + '_linked']) {\n            linked_panel_ids.push(panel_id);\n        }\n    }.bind(this));\n    return linked_panel_ids;\n};\n\n/**\n * Move a panel up relative to others by y-index\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Panel.prototype.moveUp = function() {\n    if (this.parent.panel_ids_by_y_index[this.layout.y_index - 1]) {\n        this.parent.panel_ids_by_y_index[this.layout.y_index] = this.parent.panel_ids_by_y_index[this.layout.y_index - 1];\n        this.parent.panel_ids_by_y_index[this.layout.y_index - 1] = this.id;\n        this.parent.applyPanelYIndexesToPanelLayouts();\n        this.parent.positionPanels();\n    }\n    return this;\n};\n\n/**\n * Move a panel down (y-axis) relative to others in the plot\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Panel.prototype.moveDown = function() {\n    if (this.parent.panel_ids_by_y_index[this.layout.y_index + 1]) {\n        this.parent.panel_ids_by_y_index[this.layout.y_index] = this.parent.panel_ids_by_y_index[this.layout.y_index + 1];\n        this.parent.panel_ids_by_y_index[this.layout.y_index + 1] = this.id;\n        this.parent.applyPanelYIndexesToPanelLayouts();\n        this.parent.positionPanels();\n    }\n    return this;\n};\n\n/**\n * Create a new data layer from a provided layout object. Should have the keys specified in `DefaultLayout`\n * Will automatically add at the top (depth/z-index) of the panel unless explicitly directed differently\n *   in the layout provided.\n * @param {object} layout\n * @returns {*}\n */\nLocusZoom.Panel.prototype.addDataLayer = function(layout) {\n\n    // Sanity checks\n    if (typeof layout !== 'object' || typeof layout.id !== 'string' || !layout.id.length) {\n        throw new Error('Invalid data layer layout passed to LocusZoom.Panel.prototype.addDataLayer()');\n    }\n    if (typeof this.data_layers[layout.id] !== 'undefined') {\n        throw new Error('Cannot create data_layer with id [' + layout.id + ']; data layer with that id already exists in the panel');\n    }\n    if (typeof layout.type !== 'string') {\n        throw new Error('Invalid data layer type in layout passed to LocusZoom.Panel.prototype.addDataLayer()');\n    }\n\n    // If the layout defines a y axis make sure the axis number is set and is 1 or 2 (default to 1)\n    if (typeof layout.y_axis == 'object' && (typeof layout.y_axis.axis == 'undefined' || [1,2].indexOf(layout.y_axis.axis) === -1)) {\n        layout.y_axis.axis = 1;\n    }\n\n    // Create the Data Layer\n    var data_layer = LocusZoom.DataLayers.get(layout.type, layout, this);\n\n    // Store the Data Layer on the Panel\n    this.data_layers[data_layer.id] = data_layer;\n\n    // If a discrete z_index was set in the layout then adjust other data layer z_index values to accommodate this one\n    if (data_layer.layout.z_index !== null && !isNaN(data_layer.layout.z_index)\n        && this.data_layer_ids_by_z_index.length > 0) {\n        // Negative z_index values should count backwards from the end, so convert negatives to appropriate values here\n        if (data_layer.layout.z_index < 0) {\n            data_layer.layout.z_index = Math.max(this.data_layer_ids_by_z_index.length + data_layer.layout.z_index, 0);\n        }\n        this.data_layer_ids_by_z_index.splice(data_layer.layout.z_index, 0, data_layer.id);\n        this.data_layer_ids_by_z_index.forEach(function(dlid, idx) {\n            this.data_layers[dlid].layout.z_index = idx;\n        }.bind(this));\n    } else {\n        var length = this.data_layer_ids_by_z_index.push(data_layer.id);\n        this.data_layers[data_layer.id].layout.z_index = length - 1;\n    }\n\n    // Determine if this data layer was already in the layout.data_layers array.\n    // If it wasn't, add it. Either way store the layout.data_layers array index on the data_layer.\n    var layout_idx = null;\n    this.layout.data_layers.forEach(function(data_layer_layout, idx) {\n        if (data_layer_layout.id === data_layer.id) { layout_idx = idx; }\n    });\n    if (layout_idx === null) {\n        layout_idx = this.layout.data_layers.push(this.data_layers[data_layer.id].layout) - 1;\n    }\n    this.data_layers[data_layer.id].layout_idx = layout_idx;\n\n    return this.data_layers[data_layer.id];\n};\n\n/**\n * Remove a data layer by id\n * @param {string} id\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Panel.prototype.removeDataLayer = function(id) {\n    if (!this.data_layers[id]) {\n        throw new Error('Unable to remove data layer, ID not found: ' + id);\n    }\n\n    // Destroy all tooltips for the data layer\n    this.data_layers[id].destroyAllTooltips();\n\n    // Remove the svg container for the data layer if it exists\n    if (this.data_layers[id].svg.container) {\n        this.data_layers[id].svg.container.remove();\n    }\n\n    // Delete the data layer and its presence in the panel layout and state\n    this.layout.data_layers.splice(this.data_layers[id].layout_idx, 1);\n    delete this.state[this.data_layers[id].state_id];\n    delete this.data_layers[id];\n\n    // Remove the data_layer id from the z_index array\n    this.data_layer_ids_by_z_index.splice(this.data_layer_ids_by_z_index.indexOf(id), 1);\n\n    // Update layout_idx and layout.z_index values for all remaining data_layers\n    this.applyDataLayerZIndexesToDataLayerLayouts();\n    this.layout.data_layers.forEach(function(data_layer_layout, idx) {\n        this.data_layers[data_layer_layout.id].layout_idx = idx;\n    }.bind(this));\n\n    return this;\n};\n\n/**\n * Clear all selections on all data layers\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Panel.prototype.clearSelections = function() {\n    this.data_layer_ids_by_z_index.forEach(function(id) {\n        this.data_layers[id].setAllElementStatus('selected', false);\n    }.bind(this));\n    return this;\n};\n\n/**\n * When the parent plot changes state, adjust the panel accordingly. For example, this may include fetching new data\n *   from the API as the viewing region changes\n * @returns {Promise}\n */\nLocusZoom.Panel.prototype.reMap = function() {\n    this.emit('data_requested');\n    this.data_promises = [];\n\n    // Remove any previous error messages before attempting to load new data\n    this.curtain.hide();\n    // Trigger reMap on each Data Layer\n    for (var id in this.data_layers) {\n        try {\n            this.data_promises.push(this.data_layers[id].reMap());\n        } catch (error) {\n            console.error(error);\n            this.curtain.show(error.message || error);\n        }\n    }\n    // When all finished trigger a render\n    return Promise.all(this.data_promises)\n        .then(function() {\n            this.initialized = true;\n            this.render();\n            this.emit('layout_changed', true);\n            this.emit('data_rendered');\n        }.bind(this))\n        .catch(function(error) {\n            console.error(error);\n            this.curtain.show(error.message || error);\n        }.bind(this));\n};\n\n/**\n * Iterate over data layers to generate panel axis extents\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Panel.prototype.generateExtents = function() {\n\n    // Reset extents\n    ['x', 'y1', 'y2'].forEach(function(axis) {\n        this[axis + '_extent'] = null;\n    }.bind(this));\n\n    // Loop through the data layers\n    for (var id in this.data_layers) {\n\n        var data_layer = this.data_layers[id];\n\n        // If defined and not decoupled, merge the x extent of the data layer with the panel's x extent\n        if (data_layer.layout.x_axis && !data_layer.layout.x_axis.decoupled) {\n            this.x_extent = d3.extent((this.x_extent || []).concat(data_layer.getAxisExtent('x')));\n        }\n\n        // If defined and not decoupled, merge the y extent of the data layer with the panel's appropriate y extent\n        if (data_layer.layout.y_axis && !data_layer.layout.y_axis.decoupled) {\n            var y_axis = 'y' + data_layer.layout.y_axis.axis;\n            this[y_axis + '_extent'] = d3.extent((this[y_axis + '_extent'] || []).concat(data_layer.getAxisExtent('y')));\n        }\n\n    }\n\n    // Override x_extent from state if explicitly defined to do so\n    if (this.layout.axes.x && this.layout.axes.x.extent === 'state') {\n        this.x_extent = [ this.state.start, this.state.end ];\n    }\n\n    return this;\n\n};\n\n/**\n * Generate an array of ticks for an axis. These ticks are generated in one of three ways (highest wins):\n *   1. An array of specific tick marks\n *   2. Query each data layer for what ticks are appropriate, and allow a panel-level tick configuration parameter\n *     object to override the layer's default presentation settings\n *   3. Generate generic tick marks based on the extent of the data\n * @param {('x'|'y1'|'y2')} axis The string identifier of the axis\n * @returns {Number[]|Object[]}  TODO: number format?\n *   An array of numbers: interpreted as an array of axis value offsets for positioning.\n *   An array of objects: each object must have an 'x' attribute to position the tick.\n *   Other supported object keys:\n *     * text: string to render for a given tick\n *     * style: d3-compatible CSS style object\n *     * transform: SVG transform attribute string\n *     * color: string or LocusZoom scalable parameter object\n */\nLocusZoom.Panel.prototype.generateTicks = function(axis) {\n\n    // Parse an explicit 'ticks' attribute in the axis layout\n    if (this.layout.axes[axis].ticks) {\n        var layout = this.layout.axes[axis];\n\n        var baseTickConfig = layout.ticks;\n        if (Array.isArray(baseTickConfig)) {\n            // Array of specific ticks hard-coded into a panel will override any ticks that an individual layer might specify\n            return baseTickConfig;\n        }\n\n        if (typeof baseTickConfig === 'object') {\n            // If the layout specifies base configuration for ticks- but without specific positions- then ask each\n            //   data layer to report the tick marks that it thinks it needs\n            // TODO: Few layers currently need to specify custom ticks (which is ok!). But if it becomes common, consider adding mechanisms to deduplicate ticks across layers\n            var self = this;\n\n            // Pass any layer-specific customizations for how ticks are calculated. (styles are overridden separately)\n            var config = { position: baseTickConfig.position };\n\n            var combinedTicks = this.data_layer_ids_by_z_index.reduce(function(acc, data_layer_id) {\n                var nextLayer = self.data_layers[data_layer_id];\n                return acc.concat(nextLayer.getTicks(axis, config));\n            }, []);\n\n            return combinedTicks.map(function(item) {\n                // The layer makes suggestions, but tick configuration params specified on the panel take precedence\n                var itemConfig = {};\n                itemConfig = LocusZoom.Layouts.merge(itemConfig, baseTickConfig);\n                return LocusZoom.Layouts.merge(itemConfig, item);\n            });\n        }\n    }\n\n    // If no other configuration is provided, attempt to generate ticks from the extent\n    if (this[axis + '_extent']) {\n        return LocusZoom.prettyTicks(this[axis + '_extent'], 'both');\n    }\n    return [];\n};\n\n/**\n * Update rendering of this panel whenever an event triggers a redraw. Assumes that the panel has already been\n *   prepared the first time via `initialize`\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Panel.prototype.render = function() {\n\n    // Position the panel container\n    this.svg.container.attr('transform', 'translate(' + this.layout.origin.x +  ',' + this.layout.origin.y + ')');\n\n    // Set size on the clip rect\n    this.svg.clipRect.attr('width', this.layout.width).attr('height', this.layout.height);\n\n    // Set and position the inner border, style if necessary\n    this.inner_border\n        .attr('x', this.layout.margin.left).attr('y', this.layout.margin.top)\n        .attr('width', this.layout.width - (this.layout.margin.left + this.layout.margin.right))\n        .attr('height', this.layout.height - (this.layout.margin.top + this.layout.margin.bottom));\n    if (this.layout.inner_border) {\n        this.inner_border.style({ 'stroke-width': 1, 'stroke': this.layout.inner_border });\n    }\n\n    // Set/update panel title if necessary\n    this.setTitle();\n\n    // Regenerate all extents\n    this.generateExtents();\n\n    // Helper function to constrain any procedurally generated vectors (e.g. ranges, extents)\n    // Constraints applied here keep vectors from going to infinity or beyond a definable power of ten\n    var constrain = function(value, limit_exponent) {\n        var neg_min = Math.pow(-10, limit_exponent);\n        var neg_max = Math.pow(-10, -limit_exponent);\n        var pos_min = Math.pow(10, -limit_exponent);\n        var pos_max = Math.pow(10, limit_exponent);\n        if (value === Infinity) { value = pos_max; }\n        if (value === -Infinity) { value = neg_min; }\n        if (value === 0) { value = pos_min; }\n        if (value > 0) { value = Math.max(Math.min(value, pos_max), pos_min); }\n        if (value < 0) { value = Math.max(Math.min(value, neg_max), neg_min); }\n        return value;\n    };\n\n    // Define default and shifted ranges for all axes\n    var ranges = {};\n    if (this.x_extent) {\n        var base_x_range = { start: 0, end: this.layout.cliparea.width };\n        if (this.layout.axes.x.range) {\n            base_x_range.start = this.layout.axes.x.range.start || base_x_range.start;\n            base_x_range.end = this.layout.axes.x.range.end || base_x_range.end;\n        }\n        ranges.x = [base_x_range.start, base_x_range.end];\n        ranges.x_shifted = [base_x_range.start, base_x_range.end];\n    }\n    if (this.y1_extent) {\n        var base_y1_range = { start: this.layout.cliparea.height, end: 0 };\n        if (this.layout.axes.y1.range) {\n            base_y1_range.start = this.layout.axes.y1.range.start || base_y1_range.start;\n            base_y1_range.end = this.layout.axes.y1.range.end || base_y1_range.end;\n        }\n        ranges.y1 = [base_y1_range.start, base_y1_range.end];\n        ranges.y1_shifted = [base_y1_range.start, base_y1_range.end];\n    }\n    if (this.y2_extent) {\n        var base_y2_range = { start: this.layout.cliparea.height, end: 0 };\n        if (this.layout.axes.y2.range) {\n            base_y2_range.start = this.layout.axes.y2.range.start || base_y2_range.start;\n            base_y2_range.end = this.layout.axes.y2.range.end || base_y2_range.end;\n        }\n        ranges.y2 = [base_y2_range.start, base_y2_range.end];\n        ranges.y2_shifted = [base_y2_range.start, base_y2_range.end];\n    }\n\n    // Shift ranges based on any drag or zoom interactions currently underway\n    if (this.parent.interaction.panel_id && (this.parent.interaction.panel_id === this.id || this.parent.interaction.linked_panel_ids.indexOf(this.id) !== -1)) {\n        var anchor, scalar = null;\n        if (this.parent.interaction.zooming && typeof this.x_scale == 'function') {\n            var current_extent_size = Math.abs(this.x_extent[1] - this.x_extent[0]);\n            var current_scaled_extent_size = Math.round(this.x_scale.invert(ranges.x_shifted[1])) - Math.round(this.x_scale.invert(ranges.x_shifted[0]));\n            var zoom_factor = this.parent.interaction.zooming.scale;\n            var potential_extent_size = Math.floor(current_scaled_extent_size * (1 / zoom_factor));\n            if (zoom_factor < 1 && !isNaN(this.parent.layout.max_region_scale)) {\n                zoom_factor = 1 / (Math.min(potential_extent_size, this.parent.layout.max_region_scale) / current_scaled_extent_size);\n            } else if (zoom_factor > 1 && !isNaN(this.parent.layout.min_region_scale)) {\n                zoom_factor = 1 / (Math.max(potential_extent_size, this.parent.layout.min_region_scale) / current_scaled_extent_size);\n            }\n            var new_extent_size = Math.floor(current_extent_size * zoom_factor);\n            anchor = this.parent.interaction.zooming.center - this.layout.margin.left - this.layout.origin.x;\n            var offset_ratio = anchor / this.layout.cliparea.width;\n            var new_x_extent_start = Math.max(Math.floor(this.x_scale.invert(ranges.x_shifted[0]) - ((new_extent_size - current_scaled_extent_size) * offset_ratio)), 1);\n            ranges.x_shifted = [ this.x_scale(new_x_extent_start), this.x_scale(new_x_extent_start + new_extent_size) ];\n        } else if (this.parent.interaction.dragging) {\n            switch (this.parent.interaction.dragging.method) {\n            case 'background':\n                ranges.x_shifted[0] = +this.parent.interaction.dragging.dragged_x;\n                ranges.x_shifted[1] = this.layout.cliparea.width + this.parent.interaction.dragging.dragged_x;\n                break;\n            case 'x_tick':\n                if (d3.event && d3.event.shiftKey) {\n                    ranges.x_shifted[0] = +this.parent.interaction.dragging.dragged_x;\n                    ranges.x_shifted[1] = this.layout.cliparea.width + this.parent.interaction.dragging.dragged_x;\n                } else {\n                    anchor = this.parent.interaction.dragging.start_x - this.layout.margin.left - this.layout.origin.x;\n                    scalar = constrain(anchor / (anchor + this.parent.interaction.dragging.dragged_x), 3);\n                    ranges.x_shifted[0] = 0;\n                    ranges.x_shifted[1] = Math.max(this.layout.cliparea.width * (1 / scalar), 1);\n                }\n                break;\n            case 'y1_tick':\n            case 'y2_tick':\n                var y_shifted = 'y' + this.parent.interaction.dragging.method[1] + '_shifted';\n                if (d3.event && d3.event.shiftKey) {\n                    ranges[y_shifted][0] = this.layout.cliparea.height + this.parent.interaction.dragging.dragged_y;\n                    ranges[y_shifted][1] = +this.parent.interaction.dragging.dragged_y;\n                } else {\n                    anchor = this.layout.cliparea.height - (this.parent.interaction.dragging.start_y - this.layout.margin.top - this.layout.origin.y);\n                    scalar = constrain(anchor / (anchor - this.parent.interaction.dragging.dragged_y), 3);\n                    ranges[y_shifted][0] = this.layout.cliparea.height;\n                    ranges[y_shifted][1] = this.layout.cliparea.height - (this.layout.cliparea.height * (1 / scalar));\n                }\n            }\n        }\n    }\n\n    // Generate scales and ticks for all axes, then render them\n    ['x', 'y1', 'y2'].forEach(function(axis) {\n        if (!this[axis + '_extent']) { return; }\n\n        // Base Scale\n        this[axis + '_scale'] = d3.scale.linear()\n            .domain(this[axis + '_extent'])\n            .range(ranges[axis + '_shifted']);\n\n        // Shift the extent\n        this[axis + '_extent'] = [\n            this[axis + '_scale'].invert(ranges[axis][0]),\n            this[axis + '_scale'].invert(ranges[axis][1])\n        ];\n\n        // Finalize Scale\n        this[axis + '_scale'] = d3.scale.linear()\n            .domain(this[axis + '_extent']).range(ranges[axis]);\n\n        // Render axis (and generate ticks as needed)\n        this.renderAxis(axis);\n    }.bind(this));\n\n    // Establish mousewheel zoom event handers on the panel (namespacing not passed through by d3, so not used here)\n    if (this.layout.interaction.scroll_to_zoom) {\n        var zoom_handler = function() {\n            // Look for a shift key press while scrolling to execute.\n            // If not present, gracefully raise a notification and allow conventional scrolling\n            if (!d3.event.shiftKey) {\n                if (this.parent.canInteract(this.id)) {\n                    this.loader.show('Press <tt>[SHIFT]</tt> while scrolling to zoom').hide(1000);\n                }\n                return;\n            }\n            d3.event.preventDefault();\n            if (!this.parent.canInteract(this.id)) { return; }\n            var coords = d3.mouse(this.svg.container.node());\n            var delta = Math.max(-1, Math.min(1, (d3.event.wheelDelta || -d3.event.detail || -d3.event.deltaY)));\n            if (delta === 0) { return; }\n            this.parent.interaction = {\n                panel_id: this.id,\n                linked_panel_ids: this.getLinkedPanelIds('x'),\n                zooming: {\n                    scale: (delta < 1) ? 0.9 : 1.1,\n                    center: coords[0]\n                }\n            };\n            this.render();\n            this.parent.interaction.linked_panel_ids.forEach(function(panel_id) {\n                this.parent.panels[panel_id].render();\n            }.bind(this));\n            if (this.zoom_timeout !== null) { clearTimeout(this.zoom_timeout); }\n            this.zoom_timeout = setTimeout(function() {\n                this.parent.interaction = {};\n                this.parent.applyState({ start: this.x_extent[0], end: this.x_extent[1] });\n            }.bind(this), 500);\n        }.bind(this);\n        this.zoom_listener = d3.behavior.zoom();\n        this.svg.container.call(this.zoom_listener)\n            .on('wheel.zoom', zoom_handler)\n            .on('mousewheel.zoom', zoom_handler)\n            .on('DOMMouseScroll.zoom', zoom_handler);\n    }\n\n    // Render data layers in order by z-index\n    this.data_layer_ids_by_z_index.forEach(function(data_layer_id) {\n        this.data_layers[data_layer_id].draw().render();\n    }.bind(this));\n\n    return this;\n};\n\n\n/**\n * Render ticks for a particular axis\n * @param {('x'|'y1'|'y2')} axis The identifier of the axes\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Panel.prototype.renderAxis = function(axis) {\n\n    if (['x', 'y1', 'y2'].indexOf(axis) === -1) {\n        throw new Error('Unable to render axis; invalid axis identifier: ' + axis);\n    }\n\n    var canRender = this.layout.axes[axis].render\n        && typeof this[axis + '_scale'] == 'function'\n        && !isNaN(this[axis + '_scale'](0));\n\n    // If the axis has already been rendered then check if we can/can't render it\n    // Make sure the axis element is shown/hidden to suit\n    if (this[axis + '_axis']) {\n        this.svg.container.select('g.lz-axis.lz-' + axis).style('display', canRender ? null : 'none');\n    }\n\n    if (!canRender) { return this; }\n\n    // Axis-specific values to plug in where needed\n    var axis_params = {\n        x: {\n            position: 'translate(' + this.layout.margin.left + ',' + (this.layout.height - this.layout.margin.bottom) + ')',\n            orientation: 'bottom',\n            label_x: this.layout.cliparea.width / 2,\n            label_y: (this.layout.axes[axis].label_offset || 0),\n            label_rotate: null\n        },\n        y1: {\n            position: 'translate(' + this.layout.margin.left + ',' + this.layout.margin.top + ')',\n            orientation: 'left',\n            label_x: -1 * (this.layout.axes[axis].label_offset || 0),\n            label_y: this.layout.cliparea.height / 2,\n            label_rotate: -90\n        },\n        y2: {\n            position: 'translate(' + (this.layout.width - this.layout.margin.right) + ',' + this.layout.margin.top + ')',\n            orientation: 'right',\n            label_x: (this.layout.axes[axis].label_offset || 0),\n            label_y: this.layout.cliparea.height / 2,\n            label_rotate: -90\n        }\n    };\n\n    // Generate Ticks\n    this[axis + '_ticks'] = this.generateTicks(axis);\n\n    // Determine if the ticks are all numbers (d3-automated tick rendering) or not (manual tick rendering)\n    var ticksAreAllNumbers = (function(ticks) {\n        for (var i = 0; i < ticks.length; i++) {\n            if (isNaN(ticks[i])) {\n                return false;\n            }\n        }\n        return true;\n    })(this[axis + '_ticks']);\n\n    // Initialize the axis; set scale and orientation\n    this[axis + '_axis'] = d3.svg.axis().scale(this[axis + '_scale']).orient(axis_params[axis].orientation).tickPadding(3);\n\n    // Set tick values and format\n    if (ticksAreAllNumbers) {\n        this[axis + '_axis'].tickValues(this[axis + '_ticks']);\n        if (this.layout.axes[axis].tick_format === 'region') {\n            this[axis + '_axis'].tickFormat(function(d) { return LocusZoom.positionIntToString(d, 6); });\n        }\n    } else {\n        var ticks = this[axis + '_ticks'].map(function(t) {\n            return(t[axis.substr(0,1)]);\n        });\n        this[axis + '_axis'].tickValues(ticks)\n            .tickFormat(function(t, i) { return this[axis + '_ticks'][i].text; }.bind(this));\n    }\n\n    // Position the axis in the SVG and apply the axis construct\n    this.svg[axis + '_axis']\n        .attr('transform', axis_params[axis].position)\n        .call(this[axis + '_axis']);\n\n    // If necessary manually apply styles and transforms to ticks as specified by the layout\n    if (!ticksAreAllNumbers) {\n        var tick_selector = d3.selectAll('g#' + this.getBaseId().replace('.','\\\\.') + '\\\\.' + axis + '_axis g.tick');\n        var panel = this;\n        tick_selector.each(function(d, i) {\n            var selector = d3.select(this).select('text');\n            if (panel[axis + '_ticks'][i].style) {\n                selector.style(panel[axis + '_ticks'][i].style);\n            }\n            if (panel[axis + '_ticks'][i].transform) {\n                selector.attr('transform', panel[axis + '_ticks'][i].transform);\n            }\n        });\n    }\n\n    // Render the axis label if necessary\n    var label = this.layout.axes[axis].label || null;\n    if (label !== null) {\n        this.svg[axis + '_axis_label']\n            .attr('x', axis_params[axis].label_x).attr('y', axis_params[axis].label_y)\n            .text(LocusZoom.parseFields(this.state, label));\n        if (axis_params[axis].label_rotate !== null) {\n            this.svg[axis + '_axis_label']\n                .attr('transform', 'rotate(' + axis_params[axis].label_rotate + ' ' + axis_params[axis].label_x + ',' + axis_params[axis].label_y + ')');\n        }\n    }\n\n    // Attach interactive handlers to ticks as needed\n    ['x', 'y1', 'y2'].forEach(function(axis) {\n        if (this.layout.interaction['drag_' + axis + '_ticks_to_scale']) {\n            var namespace = '.' + this.parent.id + '.' + this.id + '.interaction.drag';\n            var tick_mouseover = function() {\n                if (typeof d3.select(this).node().focus == 'function') { d3.select(this).node().focus(); }\n                var cursor = (axis === 'x') ? 'ew-resize' : 'ns-resize';\n                if (d3.event && d3.event.shiftKey) { cursor = 'move'; }\n                d3.select(this)\n                    .style({'font-weight': 'bold', 'cursor': cursor})\n                    .on('keydown' + namespace, tick_mouseover)\n                    .on('keyup' + namespace, tick_mouseover);\n            };\n            this.svg.container.selectAll('.lz-axis.lz-' + axis + ' .tick text')\n                .attr('tabindex', 0) // necessary to make the tick focusable so keypress events can be captured\n                .on('mouseover' + namespace, tick_mouseover)\n                .on('mouseout' + namespace,  function() {\n                    d3.select(this).style({'font-weight': 'normal'});\n                    d3.select(this).on('keydown' + namespace, null).on('keyup' + namespace, null);\n                })\n                .on('mousedown' + namespace, function() {\n                    this.parent.startDrag(this, axis + '_tick');\n                }.bind(this));\n        }\n    }.bind(this));\n\n    return this;\n\n};\n\n/**\n * Force the height of this panel to the largest absolute height of the data in\n *   all child data layers (if not null for any child data layers)\n * @param {number} [target_height] A target height, which will be used in situations when the expected height can be\n *   pre-calculated (eg when the layers are transitioning)\n */\nLocusZoom.Panel.prototype.scaleHeightToData = function(target_height) {\n    target_height = +target_height || null;\n    if (target_height === null) {\n        this.data_layer_ids_by_z_index.forEach(function(id) {\n            var dh = this.data_layers[id].getAbsoluteDataHeight();\n            if (+dh) {\n                if (target_height === null) { target_height = +dh; }\n                else { target_height = Math.max(target_height, +dh); }\n            }\n        }.bind(this));\n    }\n    if (+target_height) {\n        target_height += +this.layout.margin.top + +this.layout.margin.bottom;\n        this.setDimensions(this.layout.width, target_height);\n        this.parent.setDimensions();\n        this.parent.panel_ids_by_y_index.forEach(function(id) {\n            this.parent.panels[id].layout.proportional_height = null;\n        }.bind(this));\n        this.parent.positionPanels();\n    }\n};\n\n/**\n * Methods to set/unset element statuses across all data layers\n * @param {String} status\n * @param {Boolean} toggle\n * @param {Array} filters\n * @param {Boolean} exclusive\n */\nLocusZoom.Panel.prototype.setElementStatusByFilters = function(status, toggle, filters, exclusive) {\n    this.data_layer_ids_by_z_index.forEach(function(id) {\n        this.data_layers[id].setElementStatusByFilters(status, toggle, filters, exclusive);\n    }.bind(this));\n};\n/**\n * Set/unset element statuses across all data layers\n * @param {String} status\n * @param {Boolean} toggle\n */\nLocusZoom.Panel.prototype.setAllElementStatus = function(status, toggle) {\n    this.data_layer_ids_by_z_index.forEach(function(id) {\n        this.data_layers[id].setAllElementStatus(status, toggle);\n    }.bind(this));\n};\n// TODO: Capture documentation for dynamically generated methods\nLocusZoom.DataLayer.Statuses.verbs.forEach(function(verb, idx) {\n    var adjective = LocusZoom.DataLayer.Statuses.adjectives[idx];\n    var antiverb = 'un' + verb;\n    // Set/unset status for arbitrarily many elements given a set of filters\n    LocusZoom.Panel.prototype[verb + 'ElementsByFilters'] = function(filters, exclusive) {\n        if (typeof exclusive == 'undefined') { exclusive = false; } else { exclusive = !!exclusive; }\n        return this.setElementStatusByFilters(adjective, true, filters, exclusive);\n    };\n    LocusZoom.Panel.prototype[antiverb + 'ElementsByFilters'] = function(filters, exclusive) {\n        if (typeof exclusive == 'undefined') { exclusive = false; } else { exclusive = !!exclusive; }\n        return this.setElementStatusByFilters(adjective, false, filters, exclusive);\n    };\n    // Set/unset status for all elements\n    LocusZoom.Panel.prototype[verb + 'AllElements'] = function() {\n        this.setAllElementStatus(adjective, true);\n        return this;\n    };\n    LocusZoom.Panel.prototype[antiverb + 'AllElements'] = function() {\n        this.setAllElementStatus(adjective, false);\n        return this;\n    };\n});\n\n\n/**\n * Add a \"basic\" loader to a panel\n * This method is just a shortcut for adding the most commonly used type of loading indicator, which appears when\n *   data is requested, animates (e.g. shows an infinitely cycling progress bar as opposed to one that loads from\n *   0-100% based on actual load progress), and disappears when new data is loaded and rendered.\n *\n *\n * @param {Boolean} show_immediately\n * @returns {LocusZoom.Panel}\n */\nLocusZoom.Panel.prototype.addBasicLoader = function(show_immediately) {\n    if (typeof show_immediately != 'undefined') { show_immediately = true; }\n    if (show_immediately) {\n        this.loader.show('Loading...').animate();\n    }\n    this.on('data_requested', function() {\n        this.loader.show('Loading...').animate();\n    }.bind(this));\n    this.on('data_rendered', function() {\n        this.loader.hide();\n    }.bind(this));\n    return this;\n};\n"]}